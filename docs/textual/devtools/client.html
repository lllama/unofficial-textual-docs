<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.devtools.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.devtools.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import asyncio
import inspect
import json
import msgpack
import pickle
from time import time
from asyncio import Queue, Task, QueueFull
from io import StringIO
from typing import Type, Any, NamedTuple

import aiohttp
from aiohttp import ClientResponseError, ClientConnectorError, ClientWebSocketResponse
from rich.console import Console
from rich.segment import Segment


DEVTOOLS_PORT = 8081
WEBSOCKET_CONNECT_TIMEOUT = 3
LOG_QUEUE_MAXSIZE = 512


class DevtoolsLog(NamedTuple):
    &#34;&#34;&#34;A devtools log message.

    Attributes:
        objects_or_string (tuple[Any, ...]): Corresponds to the data that will
            ultimately be passed to Console.print in order to generate the log
            Segments.
        caller (inspect.FrameInfo): Information about where this log message was
            created. In other words, where did the user call `print` or `App.log`
            from. Used to display line number and file name in the devtools window.
    &#34;&#34;&#34;

    objects_or_string: tuple[Any, ...] | str
    caller: inspect.FrameInfo


class DevtoolsConsole(Console):
    def __init__(self, *args, **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)
        self.record = True

    def export_segments(self) -&gt; list[Segment]:
        &#34;&#34;&#34;Return the list of Segments that have be printed using this console

        Returns:
            list[Segment]: The list of Segments that have been printed using this console
        &#34;&#34;&#34;
        with self._record_buffer_lock:
            segments = self._record_buffer[:]
            self._record_buffer.clear()
        return segments


class DevtoolsConnectionError(Exception):
    &#34;&#34;&#34;Raise when the devtools client is unable to connect to the server&#34;&#34;&#34;


class ClientShutdown:
    &#34;&#34;&#34;Sentinel type sent to client queue(s) to indicate shutdown&#34;&#34;&#34;


class DevtoolsClient:
    &#34;&#34;&#34;Client responsible for websocket communication with the devtools server.
    Communicates using a simple JSON protocol.

    Messages have the format `{&#34;type&#34;: &lt;str&gt;, &#34;payload&#34;: &lt;json&gt;}`.

    Valid values for `&#34;type&#34;` (that can be sent from client -&gt; server) are
    `&#34;client_log&#34;` (for log messages) and `&#34;client_spillover&#34;` (for reporting
    to the server that messages were discarded due to rate limiting).

    A `&#34;client_log&#34;` message has a `&#34;payload&#34;` format as follows:
    ```
    {&#34;timestamp&#34;: &lt;int, unix timestamp&gt;,
     &#34;path&#34;: &lt;str, path of file&gt;,
     &#34;line_number&#34;: &lt;int, line number log was made from&gt;,
     &#34;encoded_segments&#34;: &lt;str, pickled then b64 encoded Segments to log&gt;}
    ```

    A `&#34;client_spillover&#34;` message has a `&#34;payload&#34;` format as follows:
    ```
    {&#34;spillover&#34;: &lt;int, the number of messages discarded by rate-limiting&gt;}
    ```

    Args:
        host (str): The host the devtools server is running on, defaults to &#34;127.0.0.1&#34;
        port (int): The port the devtools server is accessed via, defaults to 8081
    &#34;&#34;&#34;

    def __init__(self, host: str = &#34;127.0.0.1&#34;, port: int = DEVTOOLS_PORT) -&gt; None:
        self.url: str = f&#34;ws://{host}:{port}&#34;
        self.session: aiohttp.ClientSession | None = None
        self.log_queue_task: Task | None = None
        self.update_console_task: Task | None = None
        self.console: DevtoolsConsole = DevtoolsConsole(file=StringIO())
        self.websocket: ClientWebSocketResponse | None = None
        self.log_queue: Queue[str | bytes | Type[ClientShutdown]] | None = None
        self.spillover: int = 0

    async def connect(self) -&gt; None:
        &#34;&#34;&#34;Connect to the devtools server.

        Raises:
            DevtoolsConnectionError: If we&#39;re unable to establish
                a connection to the server for any reason.
        &#34;&#34;&#34;
        self.session = aiohttp.ClientSession()
        self.log_queue = Queue(maxsize=LOG_QUEUE_MAXSIZE)
        try:
            self.websocket = await self.session.ws_connect(
                f&#34;{self.url}/textual-devtools-websocket&#34;,
                timeout=WEBSOCKET_CONNECT_TIMEOUT,
            )
        except (ClientConnectorError, ClientResponseError):
            raise DevtoolsConnectionError()

        log_queue = self.log_queue
        websocket = self.websocket

        async def update_console():
            &#34;&#34;&#34;Coroutine function scheduled as a Task, which listens on
            the websocket for updates from the server regarding any changes
            in the server Console dimensions. When the client learns of this
            change, it will update its own Console to ensure it renders at
            the correct width for server-side display.
            &#34;&#34;&#34;
            async for message in self.websocket:
                if message.type == aiohttp.WSMsgType.TEXT:
                    message_json = json.loads(message.data)
                    if message_json[&#34;type&#34;] == &#34;server_info&#34;:
                        payload = message_json[&#34;payload&#34;]
                        self.console.width = payload[&#34;width&#34;]
                        self.console.height = payload[&#34;height&#34;]

        async def send_queued_logs():
            &#34;&#34;&#34;Coroutine function which is scheduled as a Task, which consumes
            messages from the log queue and sends them to the server via websocket.
            &#34;&#34;&#34;
            while True:
                log = await log_queue.get()
                if log is ClientShutdown:
                    log_queue.task_done()
                    break
                if isinstance(log, str):
                    await websocket.send_str(log)
                else:
                    await websocket.send_bytes(log)
                log_queue.task_done()

        self.log_queue_task = asyncio.create_task(send_queued_logs())
        self.update_console_task = asyncio.create_task(update_console())

    async def _stop_log_queue_processing(self) -&gt; None:
        &#34;&#34;&#34;Schedule end of processing of the log queue, meaning that any messages a
        user logs will be added to the queue, but not consumed and sent to
        the server.
        &#34;&#34;&#34;
        if self.log_queue is not None:
            await self.log_queue.put(ClientShutdown)
        if self.log_queue_task:
            await self.log_queue_task

    async def _stop_incoming_message_processing(self) -&gt; None:
        &#34;&#34;&#34;Schedule stop of the task which listens for incoming messages from the
        server around changes in the server console size.
        &#34;&#34;&#34;
        if self.websocket:
            await self.websocket.close()
        if self.update_console_task:
            await self.update_console_task
        if self.session:
            await self.session.close()

    async def disconnect(self) -&gt; None:
        &#34;&#34;&#34;Disconnect from the devtools server by stopping tasks and
        closing connections.
        &#34;&#34;&#34;
        await self._stop_log_queue_processing()
        await self._stop_incoming_message_processing()

    @property
    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;Checks connection to devtools server.

        Returns:
            bool: True if this host is connected to the server. False otherwise.
        &#34;&#34;&#34;
        if not self.session or not self.websocket:
            return False
        return not (self.session.closed or self.websocket.closed)

    def log(self, log: DevtoolsLog) -&gt; None:
        &#34;&#34;&#34;Queue a log to be sent to the devtools server for display.

        Args:
            log (DevtoolsLog): The log to write to devtools
        &#34;&#34;&#34;
        if isinstance(log.objects_or_string, str):
            self.console.print(log.objects_or_string)
        else:
            self.console.print(*log.objects_or_string)

        segments = self.console.export_segments()

        encoded_segments = self._encode_segments(segments)
        message: bytes | None = msgpack.packb(
            {
                &#34;type&#34;: &#34;client_log&#34;,
                &#34;payload&#34;: {
                    &#34;timestamp&#34;: int(time()),
                    &#34;path&#34;: getattr(log.caller, &#34;filename&#34;, &#34;&#34;),
                    &#34;line_number&#34;: getattr(log.caller, &#34;lineno&#34;, 0),
                    &#34;segments&#34;: encoded_segments,
                },
            }
        )
        assert message is not None
        try:
            if self.log_queue:
                self.log_queue.put_nowait(message)
                if self.spillover &gt; 0 and self.log_queue.qsize() &lt; LOG_QUEUE_MAXSIZE:
                    # Tell the server how many messages we had to discard due
                    # to the log queue filling to capacity on the client.
                    spillover_message = json.dumps(
                        {
                            &#34;type&#34;: &#34;client_spillover&#34;,
                            &#34;payload&#34;: {
                                &#34;spillover&#34;: self.spillover,
                            },
                        }
                    )
                    self.log_queue.put_nowait(spillover_message)
                    self.spillover = 0
        except QueueFull:
            self.spillover += 1

    @classmethod
    def _encode_segments(cls, segments: list[Segment]) -&gt; bytes:
        &#34;&#34;&#34;Pickle a list of Segments

        Args:
            segments (list[Segment]): A list of Segments to encode

        Returns:
            bytes: The Segment list pickled with the latest protocol.
        &#34;&#34;&#34;
        pickled = pickle.dumps(segments, protocol=4)
        return pickled</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.devtools.client.ClientShutdown"><code class="flex name class">
<span>class <span class="ident">ClientShutdown</span></span>
</code></dt>
<dd>
<div class="desc"><p>Sentinel type sent to client queue(s) to indicate shutdown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClientShutdown:
    &#34;&#34;&#34;Sentinel type sent to client queue(s) to indicate shutdown&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="textual.devtools.client.DevtoolsClient"><code class="flex name class">
<span>class <span class="ident">DevtoolsClient</span></span>
<span>(</span><span>host: str = '127.0.0.1', port: int = 8081)</span>
</code></dt>
<dd>
<div class="desc"><p>Client responsible for websocket communication with the devtools server.
Communicates using a simple JSON protocol.</p>
<p>Messages have the format <code>{"type": &lt;str&gt;, "payload": &lt;json&gt;}</code>.</p>
<p>Valid values for <code>"type"</code> (that can be sent from client -&gt; server) are
<code>"client_log"</code> (for log messages) and <code>"client_spillover"</code> (for reporting
to the server that messages were discarded due to rate limiting).</p>
<p>A <code>"client_log"</code> message has a <code>"payload"</code> format as follows:</p>
<pre><code>{&quot;timestamp&quot;: &lt;int, unix timestamp&gt;,
 &quot;path&quot;: &lt;str, path of file&gt;,
 &quot;line_number&quot;: &lt;int, line number log was made from&gt;,
 &quot;encoded_segments&quot;: &lt;str, pickled then b64 encoded Segments to log&gt;}
</code></pre>
<p>A <code>"client_spillover"</code> message has a <code>"payload"</code> format as follows:</p>
<pre><code>{&quot;spillover&quot;: &lt;int, the number of messages discarded by rate-limiting&gt;}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The host the devtools server is running on, defaults to "127.0.0.1"</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port the devtools server is accessed via, defaults to 8081</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DevtoolsClient:
    &#34;&#34;&#34;Client responsible for websocket communication with the devtools server.
    Communicates using a simple JSON protocol.

    Messages have the format `{&#34;type&#34;: &lt;str&gt;, &#34;payload&#34;: &lt;json&gt;}`.

    Valid values for `&#34;type&#34;` (that can be sent from client -&gt; server) are
    `&#34;client_log&#34;` (for log messages) and `&#34;client_spillover&#34;` (for reporting
    to the server that messages were discarded due to rate limiting).

    A `&#34;client_log&#34;` message has a `&#34;payload&#34;` format as follows:
    ```
    {&#34;timestamp&#34;: &lt;int, unix timestamp&gt;,
     &#34;path&#34;: &lt;str, path of file&gt;,
     &#34;line_number&#34;: &lt;int, line number log was made from&gt;,
     &#34;encoded_segments&#34;: &lt;str, pickled then b64 encoded Segments to log&gt;}
    ```

    A `&#34;client_spillover&#34;` message has a `&#34;payload&#34;` format as follows:
    ```
    {&#34;spillover&#34;: &lt;int, the number of messages discarded by rate-limiting&gt;}
    ```

    Args:
        host (str): The host the devtools server is running on, defaults to &#34;127.0.0.1&#34;
        port (int): The port the devtools server is accessed via, defaults to 8081
    &#34;&#34;&#34;

    def __init__(self, host: str = &#34;127.0.0.1&#34;, port: int = DEVTOOLS_PORT) -&gt; None:
        self.url: str = f&#34;ws://{host}:{port}&#34;
        self.session: aiohttp.ClientSession | None = None
        self.log_queue_task: Task | None = None
        self.update_console_task: Task | None = None
        self.console: DevtoolsConsole = DevtoolsConsole(file=StringIO())
        self.websocket: ClientWebSocketResponse | None = None
        self.log_queue: Queue[str | bytes | Type[ClientShutdown]] | None = None
        self.spillover: int = 0

    async def connect(self) -&gt; None:
        &#34;&#34;&#34;Connect to the devtools server.

        Raises:
            DevtoolsConnectionError: If we&#39;re unable to establish
                a connection to the server for any reason.
        &#34;&#34;&#34;
        self.session = aiohttp.ClientSession()
        self.log_queue = Queue(maxsize=LOG_QUEUE_MAXSIZE)
        try:
            self.websocket = await self.session.ws_connect(
                f&#34;{self.url}/textual-devtools-websocket&#34;,
                timeout=WEBSOCKET_CONNECT_TIMEOUT,
            )
        except (ClientConnectorError, ClientResponseError):
            raise DevtoolsConnectionError()

        log_queue = self.log_queue
        websocket = self.websocket

        async def update_console():
            &#34;&#34;&#34;Coroutine function scheduled as a Task, which listens on
            the websocket for updates from the server regarding any changes
            in the server Console dimensions. When the client learns of this
            change, it will update its own Console to ensure it renders at
            the correct width for server-side display.
            &#34;&#34;&#34;
            async for message in self.websocket:
                if message.type == aiohttp.WSMsgType.TEXT:
                    message_json = json.loads(message.data)
                    if message_json[&#34;type&#34;] == &#34;server_info&#34;:
                        payload = message_json[&#34;payload&#34;]
                        self.console.width = payload[&#34;width&#34;]
                        self.console.height = payload[&#34;height&#34;]

        async def send_queued_logs():
            &#34;&#34;&#34;Coroutine function which is scheduled as a Task, which consumes
            messages from the log queue and sends them to the server via websocket.
            &#34;&#34;&#34;
            while True:
                log = await log_queue.get()
                if log is ClientShutdown:
                    log_queue.task_done()
                    break
                if isinstance(log, str):
                    await websocket.send_str(log)
                else:
                    await websocket.send_bytes(log)
                log_queue.task_done()

        self.log_queue_task = asyncio.create_task(send_queued_logs())
        self.update_console_task = asyncio.create_task(update_console())

    async def _stop_log_queue_processing(self) -&gt; None:
        &#34;&#34;&#34;Schedule end of processing of the log queue, meaning that any messages a
        user logs will be added to the queue, but not consumed and sent to
        the server.
        &#34;&#34;&#34;
        if self.log_queue is not None:
            await self.log_queue.put(ClientShutdown)
        if self.log_queue_task:
            await self.log_queue_task

    async def _stop_incoming_message_processing(self) -&gt; None:
        &#34;&#34;&#34;Schedule stop of the task which listens for incoming messages from the
        server around changes in the server console size.
        &#34;&#34;&#34;
        if self.websocket:
            await self.websocket.close()
        if self.update_console_task:
            await self.update_console_task
        if self.session:
            await self.session.close()

    async def disconnect(self) -&gt; None:
        &#34;&#34;&#34;Disconnect from the devtools server by stopping tasks and
        closing connections.
        &#34;&#34;&#34;
        await self._stop_log_queue_processing()
        await self._stop_incoming_message_processing()

    @property
    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;Checks connection to devtools server.

        Returns:
            bool: True if this host is connected to the server. False otherwise.
        &#34;&#34;&#34;
        if not self.session or not self.websocket:
            return False
        return not (self.session.closed or self.websocket.closed)

    def log(self, log: DevtoolsLog) -&gt; None:
        &#34;&#34;&#34;Queue a log to be sent to the devtools server for display.

        Args:
            log (DevtoolsLog): The log to write to devtools
        &#34;&#34;&#34;
        if isinstance(log.objects_or_string, str):
            self.console.print(log.objects_or_string)
        else:
            self.console.print(*log.objects_or_string)

        segments = self.console.export_segments()

        encoded_segments = self._encode_segments(segments)
        message: bytes | None = msgpack.packb(
            {
                &#34;type&#34;: &#34;client_log&#34;,
                &#34;payload&#34;: {
                    &#34;timestamp&#34;: int(time()),
                    &#34;path&#34;: getattr(log.caller, &#34;filename&#34;, &#34;&#34;),
                    &#34;line_number&#34;: getattr(log.caller, &#34;lineno&#34;, 0),
                    &#34;segments&#34;: encoded_segments,
                },
            }
        )
        assert message is not None
        try:
            if self.log_queue:
                self.log_queue.put_nowait(message)
                if self.spillover &gt; 0 and self.log_queue.qsize() &lt; LOG_QUEUE_MAXSIZE:
                    # Tell the server how many messages we had to discard due
                    # to the log queue filling to capacity on the client.
                    spillover_message = json.dumps(
                        {
                            &#34;type&#34;: &#34;client_spillover&#34;,
                            &#34;payload&#34;: {
                                &#34;spillover&#34;: self.spillover,
                            },
                        }
                    )
                    self.log_queue.put_nowait(spillover_message)
                    self.spillover = 0
        except QueueFull:
            self.spillover += 1

    @classmethod
    def _encode_segments(cls, segments: list[Segment]) -&gt; bytes:
        &#34;&#34;&#34;Pickle a list of Segments

        Args:
            segments (list[Segment]): A list of Segments to encode

        Returns:
            bytes: The Segment list pickled with the latest protocol.
        &#34;&#34;&#34;
        pickled = pickle.dumps(segments, protocol=4)
        return pickled</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="textual.devtools.client.DevtoolsClient.is_connected"><code class="name">var <span class="ident">is_connected</span> : bool</code></dt>
<dd>
<div class="desc"><p>Checks connection to devtools server.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if this host is connected to the server. False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_connected(self) -&gt; bool:
    &#34;&#34;&#34;Checks connection to devtools server.

    Returns:
        bool: True if this host is connected to the server. False otherwise.
    &#34;&#34;&#34;
    if not self.session or not self.websocket:
        return False
    return not (self.session.closed or self.websocket.closed)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.devtools.client.DevtoolsClient.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the devtools server.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="textual.devtools.client.DevtoolsConnectionError" href="#textual.devtools.client.DevtoolsConnectionError">DevtoolsConnectionError</a></code></dt>
<dd>If we're unable to establish
a connection to the server for any reason.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self) -&gt; None:
    &#34;&#34;&#34;Connect to the devtools server.

    Raises:
        DevtoolsConnectionError: If we&#39;re unable to establish
            a connection to the server for any reason.
    &#34;&#34;&#34;
    self.session = aiohttp.ClientSession()
    self.log_queue = Queue(maxsize=LOG_QUEUE_MAXSIZE)
    try:
        self.websocket = await self.session.ws_connect(
            f&#34;{self.url}/textual-devtools-websocket&#34;,
            timeout=WEBSOCKET_CONNECT_TIMEOUT,
        )
    except (ClientConnectorError, ClientResponseError):
        raise DevtoolsConnectionError()

    log_queue = self.log_queue
    websocket = self.websocket

    async def update_console():
        &#34;&#34;&#34;Coroutine function scheduled as a Task, which listens on
        the websocket for updates from the server regarding any changes
        in the server Console dimensions. When the client learns of this
        change, it will update its own Console to ensure it renders at
        the correct width for server-side display.
        &#34;&#34;&#34;
        async for message in self.websocket:
            if message.type == aiohttp.WSMsgType.TEXT:
                message_json = json.loads(message.data)
                if message_json[&#34;type&#34;] == &#34;server_info&#34;:
                    payload = message_json[&#34;payload&#34;]
                    self.console.width = payload[&#34;width&#34;]
                    self.console.height = payload[&#34;height&#34;]

    async def send_queued_logs():
        &#34;&#34;&#34;Coroutine function which is scheduled as a Task, which consumes
        messages from the log queue and sends them to the server via websocket.
        &#34;&#34;&#34;
        while True:
            log = await log_queue.get()
            if log is ClientShutdown:
                log_queue.task_done()
                break
            if isinstance(log, str):
                await websocket.send_str(log)
            else:
                await websocket.send_bytes(log)
            log_queue.task_done()

    self.log_queue_task = asyncio.create_task(send_queued_logs())
    self.update_console_task = asyncio.create_task(update_console())</code></pre>
</details>
</dd>
<dt id="textual.devtools.client.DevtoolsClient.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from the devtools server by stopping tasks and
closing connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self) -&gt; None:
    &#34;&#34;&#34;Disconnect from the devtools server by stopping tasks and
    closing connections.
    &#34;&#34;&#34;
    await self._stop_log_queue_processing()
    await self._stop_incoming_message_processing()</code></pre>
</details>
</dd>
<dt id="textual.devtools.client.DevtoolsClient.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, log: <a title="textual.devtools.client.DevtoolsLog" href="#textual.devtools.client.DevtoolsLog">DevtoolsLog</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Queue a log to be sent to the devtools server for display.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>log</code></strong> :&ensp;<code><a title="textual.devtools.client.DevtoolsLog" href="#textual.devtools.client.DevtoolsLog">DevtoolsLog</a></code></dt>
<dd>The log to write to devtools</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, log: DevtoolsLog) -&gt; None:
    &#34;&#34;&#34;Queue a log to be sent to the devtools server for display.

    Args:
        log (DevtoolsLog): The log to write to devtools
    &#34;&#34;&#34;
    if isinstance(log.objects_or_string, str):
        self.console.print(log.objects_or_string)
    else:
        self.console.print(*log.objects_or_string)

    segments = self.console.export_segments()

    encoded_segments = self._encode_segments(segments)
    message: bytes | None = msgpack.packb(
        {
            &#34;type&#34;: &#34;client_log&#34;,
            &#34;payload&#34;: {
                &#34;timestamp&#34;: int(time()),
                &#34;path&#34;: getattr(log.caller, &#34;filename&#34;, &#34;&#34;),
                &#34;line_number&#34;: getattr(log.caller, &#34;lineno&#34;, 0),
                &#34;segments&#34;: encoded_segments,
            },
        }
    )
    assert message is not None
    try:
        if self.log_queue:
            self.log_queue.put_nowait(message)
            if self.spillover &gt; 0 and self.log_queue.qsize() &lt; LOG_QUEUE_MAXSIZE:
                # Tell the server how many messages we had to discard due
                # to the log queue filling to capacity on the client.
                spillover_message = json.dumps(
                    {
                        &#34;type&#34;: &#34;client_spillover&#34;,
                        &#34;payload&#34;: {
                            &#34;spillover&#34;: self.spillover,
                        },
                    }
                )
                self.log_queue.put_nowait(spillover_message)
                self.spillover = 0
    except QueueFull:
        self.spillover += 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.devtools.client.DevtoolsConnectionError"><code class="flex name class">
<span>class <span class="ident">DevtoolsConnectionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raise when the devtools client is unable to connect to the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DevtoolsConnectionError(Exception):
    &#34;&#34;&#34;Raise when the devtools client is unable to connect to the server&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textual.devtools.client.DevtoolsConsole"><code class="flex name class">
<span>class <span class="ident">DevtoolsConsole</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A high level console interface.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>color_system</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color system supported by your terminal,
either <code>"standard"</code>, <code>"256"</code> or <code>"truecolor"</code>. Leave as <code>"auto"</code> to autodetect.</dd>
<dt><strong><code>force_terminal</code></strong> :&ensp;<code>Optional[bool]</code>, optional</dt>
<dd>Enable/disable terminal control codes, or None to auto-detect terminal. Defaults to None.</dd>
<dt><strong><code>force_jupyter</code></strong> :&ensp;<code>Optional[bool]</code>, optional</dt>
<dd>Enable/disable Jupyter rendering, or None to auto-detect Jupyter. Defaults to None.</dd>
<dt><strong><code>force_interactive</code></strong> :&ensp;<code>Optional[bool]</code>, optional</dt>
<dd>Enable/disable interactive mode, or None to auto detect. Defaults to None.</dd>
<dt><strong><code>soft_wrap</code></strong> :&ensp;<code>Optional[bool]</code>, optional</dt>
<dd>Set soft wrap default on print method. Defaults to False.</dd>
<dt><strong><code>theme</code></strong> :&ensp;<code>Theme</code>, optional</dt>
<dd>An optional style theme object, or <code>None</code> for default theme.</dd>
<dt><strong><code>stderr</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use stderr rather than stdout if <code>file</code> is not specified. Defaults to False.</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>IO</code>, optional</dt>
<dd>A file object where the console should write to. Defaults to stdout.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool, Optional</code></dt>
<dd>Boolean to suppress all output. Defaults to False.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the terminal. Leave as default to auto-detect width.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The height of the terminal. Leave as default to auto-detect height.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>StyleType</code>, optional</dt>
<dd>Style to apply to all output, or None for no style. Defaults to None.</dd>
<dt><strong><code>no_color</code></strong> :&ensp;<code>Optional[bool]</code>, optional</dt>
<dd>Enabled no color mode, or None to auto detect. Defaults to None.</dd>
<dt><strong><code>tab_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of spaces used to replace a tab character. Defaults to 8.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Boolean to enable recording of terminal output,
required to call :meth:<code>export_html</code>, :meth:<code>export_svg</code>, and :meth:<code>export_text</code>. Defaults to False.</dd>
<dt><strong><code>markup</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Boolean to enable :ref:<code>console_markup</code>. Defaults to True.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Enable emoji code. Defaults to True.</dd>
<dt><strong><code>emoji_variant</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optional emoji variant, either "text" or "emoji". Defaults to None.</dd>
<dt><strong><code>highlight</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Enable automatic highlighting. Defaults to True.</dd>
<dt><strong><code>log_time</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Boolean to enable logging of time by :meth:<code>log</code> methods. Defaults to True.</dd>
<dt><strong><code>log_path</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Boolean to enable the logging of the caller by :meth:<code>log</code>. Defaults to True.</dd>
<dt><strong><code>log_time_format</code></strong> :&ensp;<code>Union[str, TimeFormatterCallable]</code>, optional</dt>
<dd>If <code>log_time</code> is enabled, either string for strftime or callable that formats the time. Defaults to "[%X] ".</dd>
<dt><strong><code>highlighter</code></strong> :&ensp;<code>HighlighterType</code>, optional</dt>
<dd>Default highlighter.</dd>
<dt><strong><code>legacy_windows</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Enable legacy Windows mode, or <code>None</code> to auto detect. Defaults to <code>None</code>.</dd>
<dt><strong><code>safe_box</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Restrict box options that don't render on legacy Windows.</dd>
<dt><strong><code>get_datetime</code></strong> :&ensp;<code>Callable[[], datetime]</code>, optional</dt>
<dd>Callable that gets the current time as a datetime.datetime object (used by Console.log),
or None for datetime.now.</dd>
<dt><strong><code>get_time</code></strong> :&ensp;<code>Callable[[], time]</code>, optional</dt>
<dd>Callable that gets the current time in seconds, default uses time.monotonic.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DevtoolsConsole(Console):
    def __init__(self, *args, **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)
        self.record = True

    def export_segments(self) -&gt; list[Segment]:
        &#34;&#34;&#34;Return the list of Segments that have be printed using this console

        Returns:
            list[Segment]: The list of Segments that have been printed using this console
        &#34;&#34;&#34;
        with self._record_buffer_lock:
            segments = self._record_buffer[:]
            self._record_buffer.clear()
        return segments</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>rich.console.Console</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="textual.devtools.client.DevtoolsConsole.export_segments"><code class="name flex">
<span>def <span class="ident">export_segments</span></span>(<span>self) ‑> list[Segment]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of Segments that have be printed using this console</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[Segment]</code></dt>
<dd>The list of Segments that have been printed using this console</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_segments(self) -&gt; list[Segment]:
    &#34;&#34;&#34;Return the list of Segments that have be printed using this console

    Returns:
        list[Segment]: The list of Segments that have been printed using this console
    &#34;&#34;&#34;
    with self._record_buffer_lock:
        segments = self._record_buffer[:]
        self._record_buffer.clear()
    return segments</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.devtools.client.DevtoolsLog"><code class="flex name class">
<span>class <span class="ident">DevtoolsLog</span></span>
<span>(</span><span>objects_or_string: tuple[Any, ...] | str, caller: inspect.FrameInfo)</span>
</code></dt>
<dd>
<div class="desc"><p>A devtools log message.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>objects_or_string</code></strong> :&ensp;<code>tuple[Any, &hellip;]</code></dt>
<dd>Corresponds to the data that will
ultimately be passed to Console.print in order to generate the log
Segments.</dd>
<dt><strong><code>caller</code></strong> :&ensp;<code>inspect.FrameInfo</code></dt>
<dd>Information about where this log message was
created. In other words, where did the user call <code>print</code> or <code>App.log</code>
from. Used to display line number and file name in the devtools window.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DevtoolsLog(NamedTuple):
    &#34;&#34;&#34;A devtools log message.

    Attributes:
        objects_or_string (tuple[Any, ...]): Corresponds to the data that will
            ultimately be passed to Console.print in order to generate the log
            Segments.
        caller (inspect.FrameInfo): Information about where this log message was
            created. In other words, where did the user call `print` or `App.log`
            from. Used to display line number and file name in the devtools window.
    &#34;&#34;&#34;

    objects_or_string: tuple[Any, ...] | str
    caller: inspect.FrameInfo</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="textual.devtools.client.DevtoolsLog.caller"><code class="name">var <span class="ident">caller</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="textual.devtools.client.DevtoolsLog.objects_or_string"><code class="name">var <span class="ident">objects_or_string</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual.devtools" href="index.html">textual.devtools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.devtools.client.ClientShutdown" href="#textual.devtools.client.ClientShutdown">ClientShutdown</a></code></h4>
</li>
<li>
<h4><code><a title="textual.devtools.client.DevtoolsClient" href="#textual.devtools.client.DevtoolsClient">DevtoolsClient</a></code></h4>
<ul class="">
<li><code><a title="textual.devtools.client.DevtoolsClient.connect" href="#textual.devtools.client.DevtoolsClient.connect">connect</a></code></li>
<li><code><a title="textual.devtools.client.DevtoolsClient.disconnect" href="#textual.devtools.client.DevtoolsClient.disconnect">disconnect</a></code></li>
<li><code><a title="textual.devtools.client.DevtoolsClient.is_connected" href="#textual.devtools.client.DevtoolsClient.is_connected">is_connected</a></code></li>
<li><code><a title="textual.devtools.client.DevtoolsClient.log" href="#textual.devtools.client.DevtoolsClient.log">log</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.devtools.client.DevtoolsConnectionError" href="#textual.devtools.client.DevtoolsConnectionError">DevtoolsConnectionError</a></code></h4>
</li>
<li>
<h4><code><a title="textual.devtools.client.DevtoolsConsole" href="#textual.devtools.client.DevtoolsConsole">DevtoolsConsole</a></code></h4>
<ul class="">
<li><code><a title="textual.devtools.client.DevtoolsConsole.export_segments" href="#textual.devtools.client.DevtoolsConsole.export_segments">export_segments</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.devtools.client.DevtoolsLog" href="#textual.devtools.client.DevtoolsLog">DevtoolsLog</a></code></h4>
<ul class="">
<li><code><a title="textual.devtools.client.DevtoolsLog.caller" href="#textual.devtools.client.DevtoolsLog.caller">caller</a></code></li>
<li><code><a title="textual.devtools.client.DevtoolsLog.objects_or_string" href="#textual.devtools.client.DevtoolsLog.objects_or_string">objects_or_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>