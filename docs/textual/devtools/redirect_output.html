<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.devtools.redirect_output API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.devtools.redirect_output</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import inspect
from io import TextIOWrapper
from typing import TYPE_CHECKING, cast
from textual.devtools.client import DevtoolsLog

if TYPE_CHECKING:
    from textual.devtools.client import DevtoolsClient


class StdoutRedirector:
    &#34;&#34;&#34;
    A write-only file-like object which redirects anything written to it to the devtools
    instance associated with the given Textual application. Used within Textual to redirect
    data written using `print` (or any other stdout writes) to the devtools and/or to the
    log file.
    &#34;&#34;&#34;

    def __init__(
        self, devtools: DevtoolsClient, log_file: TextIOWrapper | None
    ) -&gt; None:
        &#34;&#34;&#34;
        Args:
            devtools (DevtoolsClient): The running Textual app instance.
            log_file (TextIOWrapper): The log file for the Textual App.
        &#34;&#34;&#34;
        self.devtools = devtools
        self.log_file = log_file
        self._buffer: list[DevtoolsLog] = []

    def write(self, string: str) -&gt; None:
        &#34;&#34;&#34;Write the log string to the internal buffer. If the string contains
        a newline character `\n`, the whole string will be buffered and then the
        buffer will be flushed immediately after.

        Args:
            string (str): The string to write to the buffer.
        &#34;&#34;&#34;

        if not (self.devtools.is_connected or self.log_file is not None):
            return

        caller = inspect.stack()[1]
        self._buffer.append(DevtoolsLog(string, caller=caller))

        # By default, `print` adds a &#34;\n&#34; suffix which results in a buffer
        # flush. You can choose a different suffix with the `end` parameter.
        # If you modify the `end` parameter to something other than &#34;\n&#34;,
        # then `print` will no longer flush automatically. However, if a
        # string you are printing contains a &#34;\n&#34;, that will trigger
        # a flush after that string has been buffered, regardless of the value
        # of `end`.
        if &#34;\n&#34; in string:
            self.flush()

    def flush(self) -&gt; None:
        &#34;&#34;&#34;Flush the buffer. This will send all buffered log messages to
        the devtools server and the log file. In the case of the devtools,
        where possible, log messages will be batched and sent as one.
        &#34;&#34;&#34;
        self._write_to_log_file()
        self._write_to_devtools()
        self._buffer.clear()

    def _write_to_devtools(self) -&gt; None:
        &#34;&#34;&#34;Send the contents of the buffer to the devtools.&#34;&#34;&#34;
        if not self.devtools.is_connected:
            return

        log_batch: list[DevtoolsLog] = []
        for log in self._buffer:
            end_of_batch = log_batch and (
                log_batch[-1].caller.filename != log.caller.filename
                or log_batch[-1].caller.lineno != log.caller.lineno
            )
            if end_of_batch:
                self._log_devtools_batched(log_batch)
                log_batch.clear()
            log_batch.append(log)
        if log_batch:
            self._log_devtools_batched(log_batch)

    def _write_to_log_file(self) -&gt; None:
        &#34;&#34;&#34;Write the contents of the buffer to the log file.&#34;&#34;&#34;
        if not self.log_file:
            return

        try:
            log_text = &#34;&#34;.join(str(log.objects_or_string) for log in self._buffer)
            self.log_file.write(log_text)
            self.log_file.flush()
        except OSError:
            # An error writing to the log file should not be
            # considered fatal.
            pass

    def _log_devtools_batched(self, log_batch: list[DevtoolsLog]) -&gt; None:
        &#34;&#34;&#34;Write a single batch of logs to devtools. A batch means contiguous logs
        which have been written from the same line number and file path.
        A single `print` call may correspond to multiple writes.
        e.g. `print(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;)` is 3 calls to `write`, so we batch
        up these 3 write calls since they come from the same location, so that
        they appear inside the same log message in the devtools window
        rather than a single `print` statement resulting in 3 separate
        logs being displayed.

        Args:
            log_batch (list[DevtoolsLog]): A batch of logs to send to the
                devtools server as one. Log content will be joined together.
        &#34;&#34;&#34;

        # This code is only called via stdout.write, and so by this point we know
        # that the log message content is a string. The cast below tells mypy this.
        batched_log = &#34;&#34;.join(cast(str, log.objects_or_string) for log in log_batch)
        batched_log = batched_log.rstrip()
        self.devtools.log(DevtoolsLog(batched_log, caller=log_batch[-1].caller))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.devtools.redirect_output.StdoutRedirector"><code class="flex name class">
<span>class <span class="ident">StdoutRedirector</span></span>
<span>(</span><span>devtools: DevtoolsClient, log_file: TextIOWrapper | None)</span>
</code></dt>
<dd>
<div class="desc"><p>A write-only file-like object which redirects anything written to it to the devtools
instance associated with the given Textual application. Used within Textual to redirect
data written using <code>print</code> (or any other stdout writes) to the devtools and/or to the
log file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>devtools</code></strong> :&ensp;<code>DevtoolsClient</code></dt>
<dd>The running Textual app instance.</dd>
<dt><strong><code>log_file</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>The log file for the Textual App.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StdoutRedirector:
    &#34;&#34;&#34;
    A write-only file-like object which redirects anything written to it to the devtools
    instance associated with the given Textual application. Used within Textual to redirect
    data written using `print` (or any other stdout writes) to the devtools and/or to the
    log file.
    &#34;&#34;&#34;

    def __init__(
        self, devtools: DevtoolsClient, log_file: TextIOWrapper | None
    ) -&gt; None:
        &#34;&#34;&#34;
        Args:
            devtools (DevtoolsClient): The running Textual app instance.
            log_file (TextIOWrapper): The log file for the Textual App.
        &#34;&#34;&#34;
        self.devtools = devtools
        self.log_file = log_file
        self._buffer: list[DevtoolsLog] = []

    def write(self, string: str) -&gt; None:
        &#34;&#34;&#34;Write the log string to the internal buffer. If the string contains
        a newline character `\n`, the whole string will be buffered and then the
        buffer will be flushed immediately after.

        Args:
            string (str): The string to write to the buffer.
        &#34;&#34;&#34;

        if not (self.devtools.is_connected or self.log_file is not None):
            return

        caller = inspect.stack()[1]
        self._buffer.append(DevtoolsLog(string, caller=caller))

        # By default, `print` adds a &#34;\n&#34; suffix which results in a buffer
        # flush. You can choose a different suffix with the `end` parameter.
        # If you modify the `end` parameter to something other than &#34;\n&#34;,
        # then `print` will no longer flush automatically. However, if a
        # string you are printing contains a &#34;\n&#34;, that will trigger
        # a flush after that string has been buffered, regardless of the value
        # of `end`.
        if &#34;\n&#34; in string:
            self.flush()

    def flush(self) -&gt; None:
        &#34;&#34;&#34;Flush the buffer. This will send all buffered log messages to
        the devtools server and the log file. In the case of the devtools,
        where possible, log messages will be batched and sent as one.
        &#34;&#34;&#34;
        self._write_to_log_file()
        self._write_to_devtools()
        self._buffer.clear()

    def _write_to_devtools(self) -&gt; None:
        &#34;&#34;&#34;Send the contents of the buffer to the devtools.&#34;&#34;&#34;
        if not self.devtools.is_connected:
            return

        log_batch: list[DevtoolsLog] = []
        for log in self._buffer:
            end_of_batch = log_batch and (
                log_batch[-1].caller.filename != log.caller.filename
                or log_batch[-1].caller.lineno != log.caller.lineno
            )
            if end_of_batch:
                self._log_devtools_batched(log_batch)
                log_batch.clear()
            log_batch.append(log)
        if log_batch:
            self._log_devtools_batched(log_batch)

    def _write_to_log_file(self) -&gt; None:
        &#34;&#34;&#34;Write the contents of the buffer to the log file.&#34;&#34;&#34;
        if not self.log_file:
            return

        try:
            log_text = &#34;&#34;.join(str(log.objects_or_string) for log in self._buffer)
            self.log_file.write(log_text)
            self.log_file.flush()
        except OSError:
            # An error writing to the log file should not be
            # considered fatal.
            pass

    def _log_devtools_batched(self, log_batch: list[DevtoolsLog]) -&gt; None:
        &#34;&#34;&#34;Write a single batch of logs to devtools. A batch means contiguous logs
        which have been written from the same line number and file path.
        A single `print` call may correspond to multiple writes.
        e.g. `print(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;)` is 3 calls to `write`, so we batch
        up these 3 write calls since they come from the same location, so that
        they appear inside the same log message in the devtools window
        rather than a single `print` statement resulting in 3 separate
        logs being displayed.

        Args:
            log_batch (list[DevtoolsLog]): A batch of logs to send to the
                devtools server as one. Log content will be joined together.
        &#34;&#34;&#34;

        # This code is only called via stdout.write, and so by this point we know
        # that the log message content is a string. The cast below tells mypy this.
        batched_log = &#34;&#34;.join(cast(str, log.objects_or_string) for log in log_batch)
        batched_log = batched_log.rstrip()
        self.devtools.log(DevtoolsLog(batched_log, caller=log_batch[-1].caller))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="textual.devtools.redirect_output.StdoutRedirector.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Flush the buffer. This will send all buffered log messages to
the devtools server and the log file. In the case of the devtools,
where possible, log messages will be batched and sent as one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self) -&gt; None:
    &#34;&#34;&#34;Flush the buffer. This will send all buffered log messages to
    the devtools server and the log file. In the case of the devtools,
    where possible, log messages will be batched and sent as one.
    &#34;&#34;&#34;
    self._write_to_log_file()
    self._write_to_devtools()
    self._buffer.clear()</code></pre>
</details>
</dd>
<dt id="textual.devtools.redirect_output.StdoutRedirector.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, string: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Write the log string to the internal buffer. If the string contains
a newline character <code></code>, the whole string will be buffered and then the
buffer will be flushed immediately after.</p>
<pre><code>    Args:
        string (str): The string to write to the buffer.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, string: str) -&gt; None:
    &#34;&#34;&#34;Write the log string to the internal buffer. If the string contains
    a newline character `\n`, the whole string will be buffered and then the
    buffer will be flushed immediately after.

    Args:
        string (str): The string to write to the buffer.
    &#34;&#34;&#34;

    if not (self.devtools.is_connected or self.log_file is not None):
        return

    caller = inspect.stack()[1]
    self._buffer.append(DevtoolsLog(string, caller=caller))

    # By default, `print` adds a &#34;\n&#34; suffix which results in a buffer
    # flush. You can choose a different suffix with the `end` parameter.
    # If you modify the `end` parameter to something other than &#34;\n&#34;,
    # then `print` will no longer flush automatically. However, if a
    # string you are printing contains a &#34;\n&#34;, that will trigger
    # a flush after that string has been buffered, regardless of the value
    # of `end`.
    if &#34;\n&#34; in string:
        self.flush()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual.devtools" href="index.html">textual.devtools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.devtools.redirect_output.StdoutRedirector" href="#textual.devtools.redirect_output.StdoutRedirector">StdoutRedirector</a></code></h4>
<ul class="">
<li><code><a title="textual.devtools.redirect_output.StdoutRedirector.flush" href="#textual.devtools.redirect_output.StdoutRedirector.flush">flush</a></code></li>
<li><code><a title="textual.devtools.redirect_output.StdoutRedirector.write" href="#textual.devtools.redirect_output.StdoutRedirector.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>