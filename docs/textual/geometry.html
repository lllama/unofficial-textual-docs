<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.geometry API documentation</title>
<meta name="description" content="Functions and classes to manage terminal geometry (anything involving coordinates or dimensions)." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.geometry</code></h1>
</header>
<section id="section-intro">
<p>Functions and classes to manage terminal geometry (anything involving coordinates or dimensions).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

Functions and classes to manage terminal geometry (anything involving coordinates or dimensions).

&#34;&#34;&#34;

from __future__ import annotations

from typing import Any, cast, NamedTuple, Tuple, Union, TypeVar

SpacingDimensions = Union[int, Tuple[int], Tuple[int, int], Tuple[int, int, int, int]]

T = TypeVar(&#34;T&#34;, int, float)


def clamp(value: T, minimum: T, maximum: T) -&gt; T:
    &#34;&#34;&#34;Clamps a value between two other values.

    Args:
        value (T): A value
        minimum (T): Minimum value
        maximum (T): maximum value

    Returns:
        T: New value that is not less than the minimum or greater than the maximum.
    &#34;&#34;&#34;
    if minimum &gt; maximum:
        maximum, minimum = minimum, maximum
    if value &lt; minimum:
        return minimum
    elif value &gt; maximum:
        return maximum
    else:
        return value


class Offset(NamedTuple):
    &#34;&#34;&#34;A point defined by x and y coordinates.&#34;&#34;&#34;

    x: int = 0
    y: int = 0

    @property
    def is_origin(self) -&gt; bool:
        &#34;&#34;&#34;Check if the point is at the origin (0, 0)&#34;&#34;&#34;
        return self == (0, 0)

    def __bool__(self) -&gt; bool:
        return self != (0, 0)

    def __add__(self, other: object) -&gt; Offset:
        if isinstance(other, tuple):
            _x, _y = self
            x, y = other
            return Offset(_x + x, _y + y)
        return NotImplemented

    def __sub__(self, other: object) -&gt; Offset:
        if isinstance(other, tuple):
            _x, _y = self
            x, y = other
            return Offset(_x - x, _y - y)
        return NotImplemented

    def __mul__(self, other: object) -&gt; Offset:
        if isinstance(other, (float, int)):
            x, y = self
            return Offset(int(x * other), int(y * other))
        return NotImplemented

    def blend(self, destination: Offset, factor: float) -&gt; Offset:
        &#34;&#34;&#34;Blend (interpolate) to a new point.

        Args:
            destination (Point): Point where progress is 1.0
            factor (float): A value between 0 and 1.0

        Returns:
            Point: A new point on a line between self and destination
        &#34;&#34;&#34;
        x1, y1 = self
        x2, y2 = destination
        return Offset(int(x1 + (x2 - x1) * factor), int((y1 + (y2 - y1) * factor)))

    def get_distance_to(self, other: Offset) -&gt; float:
        &#34;&#34;&#34;Get the distance to another offset.

        Args:
            other (Offset): An offset

        Returns:
            float: Distance to other offset
        &#34;&#34;&#34;
        x1, y1 = self
        x2, y2 = other
        distance = ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) ** 0.5
        return distance


class Size(NamedTuple):
    &#34;&#34;&#34;An area defined by its width and height.&#34;&#34;&#34;

    width: int = 0
    height: int = 0

    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;A Size is Falsy if it has area 0.&#34;&#34;&#34;
        return self.width * self.height != 0

    @property
    def area(self) -&gt; int:
        &#34;&#34;&#34;Get the area of the size.

        Returns:
            int: Area in cells.
        &#34;&#34;&#34;
        return self.width * self.height

    @property
    def region(self) -&gt; Region:
        &#34;&#34;&#34;Get a region of the same size.&#34;&#34;&#34;
        width, height = self
        return Region(0, 0, width, height)

    def __add__(self, other: object) -&gt; Size:
        if isinstance(other, tuple):
            width, height = self
            width2, height2 = other
            return Size(max(0, width + width2), max(0, height + height2))
        return NotImplemented

    def __sub__(self, other: object) -&gt; Size:
        if isinstance(other, tuple):
            width, height = self
            width2, height2 = other
            return Size(max(0, width - width2), max(0, height - height2))
        return NotImplemented

    def contains(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the size.

        Args:
            x (int): X coordinate (column)
            y (int): Y coordinate (row)

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        width, height = self
        return width &gt; x &gt;= 0 and height &gt; y &gt;= 0

    def contains_point(self, point: tuple[int, int]) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the size.

        Args:
            point (tuple[int, int]): A tuple of x and y coordinates.

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        x, y = point
        width, height = self
        return width &gt; x &gt;= 0 and height &gt; y &gt;= 0

    def __contains__(self, other: Any) -&gt; bool:
        try:
            x, y = other
        except Exception:
            raise TypeError(
                &#34;Dimensions.__contains__ requires an iterable of two integers&#34;
            )
        width, height = self
        return width &gt; x &gt;= 0 and height &gt; y &gt;= 0


class Region(NamedTuple):
    &#34;&#34;&#34;Defines a rectangular region.&#34;&#34;&#34;

    x: int = 0
    y: int = 0
    width: int = 0
    height: int = 0

    @classmethod
    def from_corners(cls, x1: int, y1: int, x2: int, y2: int) -&gt; Region:
        &#34;&#34;&#34;Construct a Region form the top left and bottom right corners.

        Args:
            x1 (int): Top left x
            y1 (int): Top left y
            x2 (int): Bottom right x
            y2 (int): Bottom right y

        Returns:
            Region: A new region.
        &#34;&#34;&#34;
        return cls(x1, y1, x2 - x1, y2 - y1)

    @classmethod
    def from_origin(cls, origin: tuple[int, int], size: tuple[int, int]) -&gt; Region:
        &#34;&#34;&#34;Create a region from origin and size.

        Args:
            origin (Point): Origin (top left point)
            size (tuple[int, int]): Dimensions of region.

        Returns:
            Region: A region instance.
        &#34;&#34;&#34;
        x, y = origin
        width, height = size
        return cls(x, y, width, height)

    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;A Region is considered False when it has no area.&#34;&#34;&#34;
        return bool(self.width and self.height)

    @property
    def x_extents(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Get the starting and ending x coord.

        The end value is non inclusive.

        Returns:
            tuple[int, int]: [description]
        &#34;&#34;&#34;
        return (self.x, self.x + self.width)

    @property
    def y_extents(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Get the starting and ending x coord.

        The end value is non inclusive.

        Returns:
            tuple[int, int]: [description]
        &#34;&#34;&#34;
        return (self.y, self.y + self.height)

    @property
    def x_max(self) -&gt; int:
        &#34;&#34;&#34;Maximum X value (non inclusive)&#34;&#34;&#34;
        return self.x + self.width

    @property
    def y_max(self) -&gt; int:
        &#34;&#34;&#34;Maximum Y value (non inclusive)&#34;&#34;&#34;
        return self.y + self.height

    @property
    def area(self) -&gt; int:
        &#34;&#34;&#34;Get the area within the region.&#34;&#34;&#34;
        return self.width * self.height

    @property
    def origin(self) -&gt; Offset:
        &#34;&#34;&#34;Get the start point of the region.&#34;&#34;&#34;
        return Offset(self.x, self.y)

    @property
    def size(self) -&gt; Size:
        &#34;&#34;&#34;Get the size of the region.&#34;&#34;&#34;
        return Size(self.width, self.height)

    @property
    def corners(self) -&gt; tuple[int, int, int, int]:
        &#34;&#34;&#34;Get the maxima and minima of region.

        Returns:
            tuple[int, int, int, int]: A tuple of (&lt;min x&gt;, &lt;max x&gt;, &lt;min y&gt;, &lt;max y&gt;)
        &#34;&#34;&#34;
        x, y, width, height = self
        return x, y, x + width, y + height

    @property
    def x_range(self) -&gt; range:
        &#34;&#34;&#34;A range object for X coordinates&#34;&#34;&#34;
        return range(self.x, self.x + self.width)

    @property
    def y_range(self) -&gt; range:
        &#34;&#34;&#34;A range object for Y coordinates&#34;&#34;&#34;
        return range(self.y, self.y + self.height)

    @property
    def reset_origin(self) -&gt; Region:
        &#34;&#34;&#34;An region of the same size at the origin.&#34;&#34;&#34;
        _, _, width, height = self
        return Region(0, 0, width, height)

    def __add__(self, other: object) -&gt; Region:
        if isinstance(other, tuple):
            ox, oy = other
            x, y, width, height = self
            return Region(x + ox, y + oy, width, height)
        return NotImplemented

    def __sub__(self, other: object) -&gt; Region:
        if isinstance(other, tuple):
            ox, oy = other
            x, y, width, height = self
            return Region(x - ox, y - oy, width, height)
        return NotImplemented

    def expand(self, size: tuple[int, int]) -&gt; Region:
        &#34;&#34;&#34;Increase the size of the region by adding a border.

        Args:
            size (tuple[int, int]): Additional width and height.

        Returns:
            Region: A new region.
        &#34;&#34;&#34;
        expand_width, expand_height = size
        x, y, width, height = self
        return Region(
            x - expand_width,
            y - expand_height,
            width + expand_width * 2,
            height + expand_height * 2,
        )

    def overlaps(self, other: Region) -&gt; bool:
        &#34;&#34;&#34;Check if another region overlaps this region.

        Args:
            other (Region): A Region.

        Returns:
            bool: True if other region shares any cells with this region.
        &#34;&#34;&#34;
        x, y, x2, y2 = self.corners
        ox, oy, ox2, oy2 = other.corners

        return ((x2 &gt; ox &gt;= x) or (x2 &gt; ox2 &gt; x) or (ox &lt; x and ox2 &gt;= x2)) and (
            (y2 &gt; oy &gt;= y) or (y2 &gt; oy2 &gt; y) or (oy &lt; y and oy2 &gt;= y2)
        )

    def contains(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the region.

        Args:
            x (int): X coordinate (column)
            y (int): Y coordinate (row)

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        self_x, self_y, width, height = self
        return (self_x + width &gt; x &gt;= self_x) and (self_y + height &gt; y &gt;= self_y)

    def contains_point(self, point: tuple[int, int]) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the region.

        Args:
            point (tuple[int, int]): A tuple of x and y coordinates.

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners
        try:
            ox, oy = point
        except Exception:
            raise TypeError(f&#34;a tuple of two integers is required, not {point!r}&#34;)
        return (x2 &gt; ox &gt;= x1) and (y2 &gt; oy &gt;= y1)

    def contains_region(self, other: Region) -&gt; bool:
        &#34;&#34;&#34;Check if a region is entirely contained within this region.

        Args:
            other (Region): A region.

        Returns:
            bool: True if the other region fits perfectly within this region.
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners
        ox, oy, ox2, oy2 = other.corners
        return (x2 &gt;= ox &gt;= x1 and y2 &gt;= oy &gt;= y1) and (
            x2 &gt;= ox2 &gt;= x1 and y2 &gt;= oy2 &gt;= y1
        )

    def translate(self, x: int = 0, y: int = 0) -&gt; Region:
        &#34;&#34;&#34;Move the origin of the Region.

        Args:
            translate_x (int): Value to add to x coordinate.
            translate_y (int): Value to add to y coordinate.

        Returns:
            Region: A new region shifted by x, y
        &#34;&#34;&#34;

        self_x, self_y, width, height = self
        return Region(self_x + x, self_y + y, width, height)

    def __contains__(self, other: Any) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in this region.&#34;&#34;&#34;
        if isinstance(other, Region):
            return self.contains_region(other)
        else:
            try:
                return self.contains_point(other)
            except TypeError:
                return False

    def clip(self, width: int, height: int) -&gt; Region:
        &#34;&#34;&#34;Clip this region to fit within width, height.

        Args:
            width (int): Width of bounds.
            height (int): Height of bounds.

        Returns:
            Region: Clipped region.
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners

        _clamp = clamp
        new_region = Region.from_corners(
            _clamp(x1, 0, width),
            _clamp(y1, 0, height),
            _clamp(x2, 0, width),
            _clamp(y2, 0, height),
        )
        return new_region

    def shrink(self, margin: tuple[int, int, int, int]) -&gt; Region:
        &#34;&#34;&#34;Shrink a region by pushing each edge inwards.

        Args:
            margin (Spacing): Defines how many cells to shrink the Region by at each edge.

        Returns:
            Region: The new, smaller region.
        &#34;&#34;&#34;

        top, right, bottom, left = margin
        x, y, width, height = self
        return Region(
            x=x + left,
            y=y + top,
            width=max(0, width - left - right),
            height=max(0, height - top - bottom),
        )

    def intersection(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Get that covers both regions.

        Args:
            region (Region): A region that overlaps this region.

        Returns:
            Region: A new region that fits within ``region``.
        &#34;&#34;&#34;
        # Unrolled because this method is used a lot
        x1, y1, w1, h1 = self
        cx1, cy1, w2, h2 = region
        x2 = x1 + w1
        y2 = y1 + h1
        cx2 = cx1 + w2
        cy2 = cy1 + h2

        rx1 = cx2 if x1 &gt; cx2 else (cx1 if x1 &lt; cx1 else x1)
        ry1 = cy2 if y1 &gt; cy2 else (cy1 if y1 &lt; cy1 else y1)
        rx2 = cx2 if x2 &gt; cx2 else (cx1 if x2 &lt; cx1 else x2)
        ry2 = cy2 if y2 &gt; cy2 else (cy1 if y2 &lt; cy1 else y2)

        return Region(rx1, ry1, rx2 - rx1, ry2 - ry1)

    def union(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Get a new region that contains both regions.

        Args:
            region (Region): [description]

        Returns:
            Region: [description]
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners
        ox1, oy1, ox2, oy2 = region.corners

        union_region = self.from_corners(
            min(x1, ox1), min(y1, oy1), max(x2, ox2), max(y2, oy2)
        )
        return union_region

    def split(self, cut_x: int, cut_y: int) -&gt; tuple[Region, Region, Region, Region]:
        &#34;&#34;&#34;Split a region in to 4 from given x and y offsets (cuts).

                   cut_x ↓
                ┌────────┐┌───┐
                │        ││   │
                │    0   ││ 1 │
                │        ││   │
        cut_y → └────────┘└───┘
                ┌────────┐┌───┐
                │    2   ││ 3 │
                └────────┘└───┘

        Args:
            cut_x (int): Offset from self.x where the cut should be made. If negative, the cut
                is taken from the right edge.
            cut_y (int): Offset from self.y where the cut should be made. If negative, the cut
                is taken from the lower edge.

        Returns:
            tuple[Region, Region, Region, Region]: Four new regions which add up to the original (self).
        &#34;&#34;&#34;

        x, y, width, height = self
        if cut_x &lt; 0:
            cut_x = width + cut_x
        if cut_y &lt; 0:
            cut_y = height + cut_y

        _Region = Region
        return (
            _Region(x, y, cut_x, cut_y),
            _Region(x + cut_x, y, width - cut_x, cut_y),
            _Region(x, y + cut_y, cut_x, height - cut_y),
            _Region(x + cut_x, y + cut_y, width - cut_x, height - cut_y),
        )

    def split_vertical(self, cut: int) -&gt; tuple[Region, Region]:
        &#34;&#34;&#34;Split a region in to two, from a given x offset.

                 cut ↓
            ┌────────┐┌───┐
            │    0   ││ 1 │
            │        ││   │
            └────────┘└───┘

        Args:
            cut (int): An offset from self.x where the cut should be made. If cut is negative,
                it is taken from the right edge.

        Returns:
            tuple[Region, Region]: Two regions, which add up to the original (self).
        &#34;&#34;&#34;

        x, y, width, height = self
        if cut &lt; 0:
            cut = width + cut

        return (
            Region(x, y, cut, height),
            Region(x + cut, y, width - cut, height),
        )

    def split_horizontal(self, cut: int) -&gt; tuple[Region, Region]:
        &#34;&#34;&#34;Split a region in to two, from a given x offset.

                    ┌─────────┐
                    │    0    │
                    │         │
            cut →   └─────────┘
                    ┌─────────┐
                    │    1    │
                    └─────────┘

        Args:
            cut (int): An offset from self.x where the cut should be made. May be negative,
                for the offset to start from the right edge.

        Returns:
            tuple[Region, Region]: Two regions, which add up to the original (self).
        &#34;&#34;&#34;
        x, y, width, height = self
        if cut &lt; 0:
            cut = height + cut

        return (
            Region(x, y, width, cut),
            Region(x, y + cut, width, height - cut),
        )


class Spacing(NamedTuple):
    &#34;&#34;&#34;The spacing around a renderable.&#34;&#34;&#34;

    top: int = 0
    right: int = 0
    bottom: int = 0
    left: int = 0

    def __bool__(self) -&gt; bool:
        return self != (0, 0, 0, 0)

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Total space in width.&#34;&#34;&#34;
        return self.left + self.right

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;Total space in height.&#34;&#34;&#34;
        return self.top + self.bottom

    @property
    def top_left(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Top left space.&#34;&#34;&#34;
        return (self.left, self.top)

    @property
    def bottom_right(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Bottom right space.&#34;&#34;&#34;
        return (self.right, self.bottom)

    @property
    def totals(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Returns a tuple of (&lt;HORIZONTAL SPACE&gt;, &lt;VERTICAL SPACE&gt;).&#34;&#34;&#34;
        top, right, bottom, left = self
        return (left + right, top + bottom)

    @property
    def css(self) -&gt; str:
        &#34;&#34;&#34;Gets a string containing the spacing in CSS format.&#34;&#34;&#34;
        top, right, bottom, left = self
        if top == right == bottom == left:
            return f&#34;{top}&#34;
        if (top, right) == (bottom, left):
            return f&#34;{top} {right}&#34;
        else:
            return f&#34;{top} {right} {bottom} {left}&#34;

    @classmethod
    def unpack(cls, pad: SpacingDimensions) -&gt; Spacing:
        &#34;&#34;&#34;Unpack padding specified in CSS style.&#34;&#34;&#34;
        if isinstance(pad, int):
            return cls(pad, pad, pad, pad)
        pad_len = len(pad)
        if pad_len == 1:
            _pad = pad[0]
            return cls(_pad, _pad, _pad, _pad)
        if pad_len == 2:
            pad_top, pad_right = cast(Tuple[int, int], pad)
            return cls(pad_top, pad_right, pad_top, pad_right)
        if pad_len == 4:
            top, right, bottom, left = cast(Tuple[int, int, int, int], pad)
            return cls(top, right, bottom, left)
        raise ValueError(
            f&#34;1, 2 or 4 integers required for spacing properties; {pad_len} given&#34;
        )

    @classmethod
    def vertical(cls, amount: int) -&gt; Spacing:
        &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on vertical edges,
        and no horizontal spacing.

        Args:
            amount (int): The magnitude of spacing to apply to vertical edges

        Returns:
            Spacing: ``Spacing(amount, 0, amount, 0)``
        &#34;&#34;&#34;
        return Spacing(amount, 0, amount, 0)

    @classmethod
    def horizontal(cls, amount: int) -&gt; Spacing:
        &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on horizontal edges,
        and no vertical spacing.

        Args:
            amount (int): The magnitude of spacing to apply to horizontal edges

        Returns:
            Spacing: ``Spacing(0, amount, 0, amount)``
        &#34;&#34;&#34;
        return Spacing(0, amount, 0, amount)

    @classmethod
    def all(cls, amount: int) -&gt; Spacing:
        &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on all edges.

        Args:
            amount (int): The magnitude of spacing to apply to all edges

        Returns:
            Spacing: ``Spacing(amount, amount, amount, amount)``
        &#34;&#34;&#34;
        return Spacing(amount, amount, amount, amount)

    def __add__(self, other: object) -&gt; Spacing:
        if isinstance(other, tuple):
            top1, right1, bottom1, left1 = self
            top2, right2, bottom2, left2 = other
            return Spacing(
                top1 + top2, right1 + right2, bottom1 + bottom2, left1 + left2
            )
        return NotImplemented

    def __sub__(self, other: object) -&gt; Spacing:
        if isinstance(other, tuple):
            top1, right1, bottom1, left1 = self
            top2, right2, bottom2, left2 = other
            return Spacing(
                top1 - top2, right1 - right2, bottom1 - bottom2, left1 - left2
            )
        return NotImplemented


NULL_OFFSET = Offset(0, 0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="textual.geometry.clamp"><code class="name flex">
<span>def <span class="ident">clamp</span></span>(<span>value: T, minimum: T, maximum: T) ‑> ~T</span>
</code></dt>
<dd>
<div class="desc"><p>Clamps a value between two other values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>T</code></dt>
<dd>A value</dd>
<dt><strong><code>minimum</code></strong> :&ensp;<code>T</code></dt>
<dd>Minimum value</dd>
<dt><strong><code>maximum</code></strong> :&ensp;<code>T</code></dt>
<dd>maximum value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>T</code></dt>
<dd>New value that is not less than the minimum or greater than the maximum.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp(value: T, minimum: T, maximum: T) -&gt; T:
    &#34;&#34;&#34;Clamps a value between two other values.

    Args:
        value (T): A value
        minimum (T): Minimum value
        maximum (T): maximum value

    Returns:
        T: New value that is not less than the minimum or greater than the maximum.
    &#34;&#34;&#34;
    if minimum &gt; maximum:
        maximum, minimum = minimum, maximum
    if value &lt; minimum:
        return minimum
    elif value &gt; maximum:
        return maximum
    else:
        return value</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.geometry.Offset"><code class="flex name class">
<span>class <span class="ident">Offset</span></span>
<span>(</span><span>x: int = 0, y: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>A point defined by x and y coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Offset(NamedTuple):
    &#34;&#34;&#34;A point defined by x and y coordinates.&#34;&#34;&#34;

    x: int = 0
    y: int = 0

    @property
    def is_origin(self) -&gt; bool:
        &#34;&#34;&#34;Check if the point is at the origin (0, 0)&#34;&#34;&#34;
        return self == (0, 0)

    def __bool__(self) -&gt; bool:
        return self != (0, 0)

    def __add__(self, other: object) -&gt; Offset:
        if isinstance(other, tuple):
            _x, _y = self
            x, y = other
            return Offset(_x + x, _y + y)
        return NotImplemented

    def __sub__(self, other: object) -&gt; Offset:
        if isinstance(other, tuple):
            _x, _y = self
            x, y = other
            return Offset(_x - x, _y - y)
        return NotImplemented

    def __mul__(self, other: object) -&gt; Offset:
        if isinstance(other, (float, int)):
            x, y = self
            return Offset(int(x * other), int(y * other))
        return NotImplemented

    def blend(self, destination: Offset, factor: float) -&gt; Offset:
        &#34;&#34;&#34;Blend (interpolate) to a new point.

        Args:
            destination (Point): Point where progress is 1.0
            factor (float): A value between 0 and 1.0

        Returns:
            Point: A new point on a line between self and destination
        &#34;&#34;&#34;
        x1, y1 = self
        x2, y2 = destination
        return Offset(int(x1 + (x2 - x1) * factor), int((y1 + (y2 - y1) * factor)))

    def get_distance_to(self, other: Offset) -&gt; float:
        &#34;&#34;&#34;Get the distance to another offset.

        Args:
            other (Offset): An offset

        Returns:
            float: Distance to other offset
        &#34;&#34;&#34;
        x1, y1 = self
        x2, y2 = other
        distance = ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) ** 0.5
        return distance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="textual.geometry.Offset.is_origin"><code class="name">var <span class="ident">is_origin</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if the point is at the origin (0, 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_origin(self) -&gt; bool:
    &#34;&#34;&#34;Check if the point is at the origin (0, 0)&#34;&#34;&#34;
    return self == (0, 0)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Offset.x"><code class="name">var <span class="ident">x</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="textual.geometry.Offset.y"><code class="name">var <span class="ident">y</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.geometry.Offset.blend"><code class="name flex">
<span>def <span class="ident">blend</span></span>(<span>self, destination: <a title="textual.geometry.Offset" href="#textual.geometry.Offset">Offset</a>, factor: float) ‑> <a title="textual.geometry.Offset" href="#textual.geometry.Offset">Offset</a></span>
</code></dt>
<dd>
<div class="desc"><p>Blend (interpolate) to a new point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>destination</code></strong> :&ensp;<code>Point</code></dt>
<dd>Point where progress is 1.0</dd>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>A value between 0 and 1.0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Point</code></dt>
<dd>A new point on a line between self and destination</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blend(self, destination: Offset, factor: float) -&gt; Offset:
    &#34;&#34;&#34;Blend (interpolate) to a new point.

    Args:
        destination (Point): Point where progress is 1.0
        factor (float): A value between 0 and 1.0

    Returns:
        Point: A new point on a line between self and destination
    &#34;&#34;&#34;
    x1, y1 = self
    x2, y2 = destination
    return Offset(int(x1 + (x2 - x1) * factor), int((y1 + (y2 - y1) * factor)))</code></pre>
</details>
</dd>
<dt id="textual.geometry.Offset.get_distance_to"><code class="name flex">
<span>def <span class="ident">get_distance_to</span></span>(<span>self, other: <a title="textual.geometry.Offset" href="#textual.geometry.Offset">Offset</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the distance to another offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="textual.geometry.Offset" href="#textual.geometry.Offset">Offset</a></code></dt>
<dd>An offset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Distance to other offset</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_distance_to(self, other: Offset) -&gt; float:
    &#34;&#34;&#34;Get the distance to another offset.

    Args:
        other (Offset): An offset

    Returns:
        float: Distance to other offset
    &#34;&#34;&#34;
    x1, y1 = self
    x2, y2 = other
    distance = ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) ** 0.5
    return distance</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.geometry.Region"><code class="flex name class">
<span>class <span class="ident">Region</span></span>
<span>(</span><span>x: int = 0, y: int = 0, width: int = 0, height: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a rectangular region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Region(NamedTuple):
    &#34;&#34;&#34;Defines a rectangular region.&#34;&#34;&#34;

    x: int = 0
    y: int = 0
    width: int = 0
    height: int = 0

    @classmethod
    def from_corners(cls, x1: int, y1: int, x2: int, y2: int) -&gt; Region:
        &#34;&#34;&#34;Construct a Region form the top left and bottom right corners.

        Args:
            x1 (int): Top left x
            y1 (int): Top left y
            x2 (int): Bottom right x
            y2 (int): Bottom right y

        Returns:
            Region: A new region.
        &#34;&#34;&#34;
        return cls(x1, y1, x2 - x1, y2 - y1)

    @classmethod
    def from_origin(cls, origin: tuple[int, int], size: tuple[int, int]) -&gt; Region:
        &#34;&#34;&#34;Create a region from origin and size.

        Args:
            origin (Point): Origin (top left point)
            size (tuple[int, int]): Dimensions of region.

        Returns:
            Region: A region instance.
        &#34;&#34;&#34;
        x, y = origin
        width, height = size
        return cls(x, y, width, height)

    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;A Region is considered False when it has no area.&#34;&#34;&#34;
        return bool(self.width and self.height)

    @property
    def x_extents(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Get the starting and ending x coord.

        The end value is non inclusive.

        Returns:
            tuple[int, int]: [description]
        &#34;&#34;&#34;
        return (self.x, self.x + self.width)

    @property
    def y_extents(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Get the starting and ending x coord.

        The end value is non inclusive.

        Returns:
            tuple[int, int]: [description]
        &#34;&#34;&#34;
        return (self.y, self.y + self.height)

    @property
    def x_max(self) -&gt; int:
        &#34;&#34;&#34;Maximum X value (non inclusive)&#34;&#34;&#34;
        return self.x + self.width

    @property
    def y_max(self) -&gt; int:
        &#34;&#34;&#34;Maximum Y value (non inclusive)&#34;&#34;&#34;
        return self.y + self.height

    @property
    def area(self) -&gt; int:
        &#34;&#34;&#34;Get the area within the region.&#34;&#34;&#34;
        return self.width * self.height

    @property
    def origin(self) -&gt; Offset:
        &#34;&#34;&#34;Get the start point of the region.&#34;&#34;&#34;
        return Offset(self.x, self.y)

    @property
    def size(self) -&gt; Size:
        &#34;&#34;&#34;Get the size of the region.&#34;&#34;&#34;
        return Size(self.width, self.height)

    @property
    def corners(self) -&gt; tuple[int, int, int, int]:
        &#34;&#34;&#34;Get the maxima and minima of region.

        Returns:
            tuple[int, int, int, int]: A tuple of (&lt;min x&gt;, &lt;max x&gt;, &lt;min y&gt;, &lt;max y&gt;)
        &#34;&#34;&#34;
        x, y, width, height = self
        return x, y, x + width, y + height

    @property
    def x_range(self) -&gt; range:
        &#34;&#34;&#34;A range object for X coordinates&#34;&#34;&#34;
        return range(self.x, self.x + self.width)

    @property
    def y_range(self) -&gt; range:
        &#34;&#34;&#34;A range object for Y coordinates&#34;&#34;&#34;
        return range(self.y, self.y + self.height)

    @property
    def reset_origin(self) -&gt; Region:
        &#34;&#34;&#34;An region of the same size at the origin.&#34;&#34;&#34;
        _, _, width, height = self
        return Region(0, 0, width, height)

    def __add__(self, other: object) -&gt; Region:
        if isinstance(other, tuple):
            ox, oy = other
            x, y, width, height = self
            return Region(x + ox, y + oy, width, height)
        return NotImplemented

    def __sub__(self, other: object) -&gt; Region:
        if isinstance(other, tuple):
            ox, oy = other
            x, y, width, height = self
            return Region(x - ox, y - oy, width, height)
        return NotImplemented

    def expand(self, size: tuple[int, int]) -&gt; Region:
        &#34;&#34;&#34;Increase the size of the region by adding a border.

        Args:
            size (tuple[int, int]): Additional width and height.

        Returns:
            Region: A new region.
        &#34;&#34;&#34;
        expand_width, expand_height = size
        x, y, width, height = self
        return Region(
            x - expand_width,
            y - expand_height,
            width + expand_width * 2,
            height + expand_height * 2,
        )

    def overlaps(self, other: Region) -&gt; bool:
        &#34;&#34;&#34;Check if another region overlaps this region.

        Args:
            other (Region): A Region.

        Returns:
            bool: True if other region shares any cells with this region.
        &#34;&#34;&#34;
        x, y, x2, y2 = self.corners
        ox, oy, ox2, oy2 = other.corners

        return ((x2 &gt; ox &gt;= x) or (x2 &gt; ox2 &gt; x) or (ox &lt; x and ox2 &gt;= x2)) and (
            (y2 &gt; oy &gt;= y) or (y2 &gt; oy2 &gt; y) or (oy &lt; y and oy2 &gt;= y2)
        )

    def contains(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the region.

        Args:
            x (int): X coordinate (column)
            y (int): Y coordinate (row)

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        self_x, self_y, width, height = self
        return (self_x + width &gt; x &gt;= self_x) and (self_y + height &gt; y &gt;= self_y)

    def contains_point(self, point: tuple[int, int]) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the region.

        Args:
            point (tuple[int, int]): A tuple of x and y coordinates.

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners
        try:
            ox, oy = point
        except Exception:
            raise TypeError(f&#34;a tuple of two integers is required, not {point!r}&#34;)
        return (x2 &gt; ox &gt;= x1) and (y2 &gt; oy &gt;= y1)

    def contains_region(self, other: Region) -&gt; bool:
        &#34;&#34;&#34;Check if a region is entirely contained within this region.

        Args:
            other (Region): A region.

        Returns:
            bool: True if the other region fits perfectly within this region.
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners
        ox, oy, ox2, oy2 = other.corners
        return (x2 &gt;= ox &gt;= x1 and y2 &gt;= oy &gt;= y1) and (
            x2 &gt;= ox2 &gt;= x1 and y2 &gt;= oy2 &gt;= y1
        )

    def translate(self, x: int = 0, y: int = 0) -&gt; Region:
        &#34;&#34;&#34;Move the origin of the Region.

        Args:
            translate_x (int): Value to add to x coordinate.
            translate_y (int): Value to add to y coordinate.

        Returns:
            Region: A new region shifted by x, y
        &#34;&#34;&#34;

        self_x, self_y, width, height = self
        return Region(self_x + x, self_y + y, width, height)

    def __contains__(self, other: Any) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in this region.&#34;&#34;&#34;
        if isinstance(other, Region):
            return self.contains_region(other)
        else:
            try:
                return self.contains_point(other)
            except TypeError:
                return False

    def clip(self, width: int, height: int) -&gt; Region:
        &#34;&#34;&#34;Clip this region to fit within width, height.

        Args:
            width (int): Width of bounds.
            height (int): Height of bounds.

        Returns:
            Region: Clipped region.
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners

        _clamp = clamp
        new_region = Region.from_corners(
            _clamp(x1, 0, width),
            _clamp(y1, 0, height),
            _clamp(x2, 0, width),
            _clamp(y2, 0, height),
        )
        return new_region

    def shrink(self, margin: tuple[int, int, int, int]) -&gt; Region:
        &#34;&#34;&#34;Shrink a region by pushing each edge inwards.

        Args:
            margin (Spacing): Defines how many cells to shrink the Region by at each edge.

        Returns:
            Region: The new, smaller region.
        &#34;&#34;&#34;

        top, right, bottom, left = margin
        x, y, width, height = self
        return Region(
            x=x + left,
            y=y + top,
            width=max(0, width - left - right),
            height=max(0, height - top - bottom),
        )

    def intersection(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Get that covers both regions.

        Args:
            region (Region): A region that overlaps this region.

        Returns:
            Region: A new region that fits within ``region``.
        &#34;&#34;&#34;
        # Unrolled because this method is used a lot
        x1, y1, w1, h1 = self
        cx1, cy1, w2, h2 = region
        x2 = x1 + w1
        y2 = y1 + h1
        cx2 = cx1 + w2
        cy2 = cy1 + h2

        rx1 = cx2 if x1 &gt; cx2 else (cx1 if x1 &lt; cx1 else x1)
        ry1 = cy2 if y1 &gt; cy2 else (cy1 if y1 &lt; cy1 else y1)
        rx2 = cx2 if x2 &gt; cx2 else (cx1 if x2 &lt; cx1 else x2)
        ry2 = cy2 if y2 &gt; cy2 else (cy1 if y2 &lt; cy1 else y2)

        return Region(rx1, ry1, rx2 - rx1, ry2 - ry1)

    def union(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Get a new region that contains both regions.

        Args:
            region (Region): [description]

        Returns:
            Region: [description]
        &#34;&#34;&#34;
        x1, y1, x2, y2 = self.corners
        ox1, oy1, ox2, oy2 = region.corners

        union_region = self.from_corners(
            min(x1, ox1), min(y1, oy1), max(x2, ox2), max(y2, oy2)
        )
        return union_region

    def split(self, cut_x: int, cut_y: int) -&gt; tuple[Region, Region, Region, Region]:
        &#34;&#34;&#34;Split a region in to 4 from given x and y offsets (cuts).

                   cut_x ↓
                ┌────────┐┌───┐
                │        ││   │
                │    0   ││ 1 │
                │        ││   │
        cut_y → └────────┘└───┘
                ┌────────┐┌───┐
                │    2   ││ 3 │
                └────────┘└───┘

        Args:
            cut_x (int): Offset from self.x where the cut should be made. If negative, the cut
                is taken from the right edge.
            cut_y (int): Offset from self.y where the cut should be made. If negative, the cut
                is taken from the lower edge.

        Returns:
            tuple[Region, Region, Region, Region]: Four new regions which add up to the original (self).
        &#34;&#34;&#34;

        x, y, width, height = self
        if cut_x &lt; 0:
            cut_x = width + cut_x
        if cut_y &lt; 0:
            cut_y = height + cut_y

        _Region = Region
        return (
            _Region(x, y, cut_x, cut_y),
            _Region(x + cut_x, y, width - cut_x, cut_y),
            _Region(x, y + cut_y, cut_x, height - cut_y),
            _Region(x + cut_x, y + cut_y, width - cut_x, height - cut_y),
        )

    def split_vertical(self, cut: int) -&gt; tuple[Region, Region]:
        &#34;&#34;&#34;Split a region in to two, from a given x offset.

                 cut ↓
            ┌────────┐┌───┐
            │    0   ││ 1 │
            │        ││   │
            └────────┘└───┘

        Args:
            cut (int): An offset from self.x where the cut should be made. If cut is negative,
                it is taken from the right edge.

        Returns:
            tuple[Region, Region]: Two regions, which add up to the original (self).
        &#34;&#34;&#34;

        x, y, width, height = self
        if cut &lt; 0:
            cut = width + cut

        return (
            Region(x, y, cut, height),
            Region(x + cut, y, width - cut, height),
        )

    def split_horizontal(self, cut: int) -&gt; tuple[Region, Region]:
        &#34;&#34;&#34;Split a region in to two, from a given x offset.

                    ┌─────────┐
                    │    0    │
                    │         │
            cut →   └─────────┘
                    ┌─────────┐
                    │    1    │
                    └─────────┘

        Args:
            cut (int): An offset from self.x where the cut should be made. May be negative,
                for the offset to start from the right edge.

        Returns:
            tuple[Region, Region]: Two regions, which add up to the original (self).
        &#34;&#34;&#34;
        x, y, width, height = self
        if cut &lt; 0:
            cut = height + cut

        return (
            Region(x, y, width, cut),
            Region(x, y + cut, width, height - cut),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="textual.geometry.Region.from_corners"><code class="name flex">
<span>def <span class="ident">from_corners</span></span>(<span>x1: int, y1: int, x2: int, y2: int) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a Region form the top left and bottom right corners.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>int</code></dt>
<dd>Top left x</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>int</code></dt>
<dd>Top left y</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>int</code></dt>
<dd>Bottom right x</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>int</code></dt>
<dd>Bottom right y</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A new region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_corners(cls, x1: int, y1: int, x2: int, y2: int) -&gt; Region:
    &#34;&#34;&#34;Construct a Region form the top left and bottom right corners.

    Args:
        x1 (int): Top left x
        y1 (int): Top left y
        x2 (int): Bottom right x
        y2 (int): Bottom right y

    Returns:
        Region: A new region.
    &#34;&#34;&#34;
    return cls(x1, y1, x2 - x1, y2 - y1)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.from_origin"><code class="name flex">
<span>def <span class="ident">from_origin</span></span>(<span>origin: tuple[int, int], size: tuple[int, int]) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a region from origin and size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>origin</code></strong> :&ensp;<code>Point</code></dt>
<dd>Origin (top left point)</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>Dimensions of region.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A region instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_origin(cls, origin: tuple[int, int], size: tuple[int, int]) -&gt; Region:
    &#34;&#34;&#34;Create a region from origin and size.

    Args:
        origin (Point): Origin (top left point)
        size (tuple[int, int]): Dimensions of region.

    Returns:
        Region: A region instance.
    &#34;&#34;&#34;
    x, y = origin
    width, height = size
    return cls(x, y, width, height)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="textual.geometry.Region.area"><code class="name">var <span class="ident">area</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the area within the region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def area(self) -&gt; int:
    &#34;&#34;&#34;Get the area within the region.&#34;&#34;&#34;
    return self.width * self.height</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.corners"><code class="name">var <span class="ident">corners</span> : tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"><p>Get the maxima and minima of region.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[int, int, int, int]</code></dt>
<dd>A tuple of (<min x>, <max x>, <min y>, <max y>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; tuple[int, int, int, int]:
    &#34;&#34;&#34;Get the maxima and minima of region.

    Returns:
        tuple[int, int, int, int]: A tuple of (&lt;min x&gt;, &lt;max x&gt;, &lt;min y&gt;, &lt;max y&gt;)
    &#34;&#34;&#34;
    x, y, width, height = self
    return x, y, x + width, y + height</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="textual.geometry.Region.origin"><code class="name">var <span class="ident">origin</span> : <a title="textual.geometry.Offset" href="#textual.geometry.Offset">Offset</a></code></dt>
<dd>
<div class="desc"><p>Get the start point of the region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def origin(self) -&gt; Offset:
    &#34;&#34;&#34;Get the start point of the region.&#34;&#34;&#34;
    return Offset(self.x, self.y)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.reset_origin"><code class="name">var <span class="ident">reset_origin</span> : <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>An region of the same size at the origin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reset_origin(self) -&gt; Region:
    &#34;&#34;&#34;An region of the same size at the origin.&#34;&#34;&#34;
    _, _, width, height = self
    return Region(0, 0, width, height)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.size"><code class="name">var <span class="ident">size</span> : <a title="textual.geometry.Size" href="#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"><p>Get the size of the region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Size:
    &#34;&#34;&#34;Get the size of the region.&#34;&#34;&#34;
    return Size(self.width, self.height)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="textual.geometry.Region.x"><code class="name">var <span class="ident">x</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="textual.geometry.Region.x_extents"><code class="name">var <span class="ident">x_extents</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Get the starting and ending x coord.</p>
<p>The end value is non inclusive.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[int, int]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_extents(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;Get the starting and ending x coord.

    The end value is non inclusive.

    Returns:
        tuple[int, int]: [description]
    &#34;&#34;&#34;
    return (self.x, self.x + self.width)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.x_max"><code class="name">var <span class="ident">x_max</span> : int</code></dt>
<dd>
<div class="desc"><p>Maximum X value (non inclusive)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_max(self) -&gt; int:
    &#34;&#34;&#34;Maximum X value (non inclusive)&#34;&#34;&#34;
    return self.x + self.width</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.x_range"><code class="name">var <span class="ident">x_range</span> : range</code></dt>
<dd>
<div class="desc"><p>A range object for X coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_range(self) -&gt; range:
    &#34;&#34;&#34;A range object for X coordinates&#34;&#34;&#34;
    return range(self.x, self.x + self.width)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.y"><code class="name">var <span class="ident">y</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="textual.geometry.Region.y_extents"><code class="name">var <span class="ident">y_extents</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Get the starting and ending x coord.</p>
<p>The end value is non inclusive.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[int, int]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_extents(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;Get the starting and ending x coord.

    The end value is non inclusive.

    Returns:
        tuple[int, int]: [description]
    &#34;&#34;&#34;
    return (self.y, self.y + self.height)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.y_max"><code class="name">var <span class="ident">y_max</span> : int</code></dt>
<dd>
<div class="desc"><p>Maximum Y value (non inclusive)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_max(self) -&gt; int:
    &#34;&#34;&#34;Maximum Y value (non inclusive)&#34;&#34;&#34;
    return self.y + self.height</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.y_range"><code class="name">var <span class="ident">y_range</span> : range</code></dt>
<dd>
<div class="desc"><p>A range object for Y coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_range(self) -&gt; range:
    &#34;&#34;&#34;A range object for Y coordinates&#34;&#34;&#34;
    return range(self.y, self.y + self.height)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.geometry.Region.clip"><code class="name flex">
<span>def <span class="ident">clip</span></span>(<span>self, width: int, height: int) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Clip this region to fit within width, height.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of bounds.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>Height of bounds.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>Clipped region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clip(self, width: int, height: int) -&gt; Region:
    &#34;&#34;&#34;Clip this region to fit within width, height.

    Args:
        width (int): Width of bounds.
        height (int): Height of bounds.

    Returns:
        Region: Clipped region.
    &#34;&#34;&#34;
    x1, y1, x2, y2 = self.corners

    _clamp = clamp
    new_region = Region.from_corners(
        _clamp(x1, 0, width),
        _clamp(y1, 0, height),
        _clamp(x2, 0, width),
        _clamp(y2, 0, height),
    )
    return new_region</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a point is in the region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>X coordinate (column)</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Y coordinate (row)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the point is within the region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, x: int, y: int) -&gt; bool:
    &#34;&#34;&#34;Check if a point is in the region.

    Args:
        x (int): X coordinate (column)
        y (int): Y coordinate (row)

    Returns:
        bool: True if the point is within the region.
    &#34;&#34;&#34;
    self_x, self_y, width, height = self
    return (self_x + width &gt; x &gt;= self_x) and (self_y + height &gt; y &gt;= self_y)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.contains_point"><code class="name flex">
<span>def <span class="ident">contains_point</span></span>(<span>self, point: tuple[int, int]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a point is in the region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>A tuple of x and y coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the point is within the region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_point(self, point: tuple[int, int]) -&gt; bool:
    &#34;&#34;&#34;Check if a point is in the region.

    Args:
        point (tuple[int, int]): A tuple of x and y coordinates.

    Returns:
        bool: True if the point is within the region.
    &#34;&#34;&#34;
    x1, y1, x2, y2 = self.corners
    try:
        ox, oy = point
    except Exception:
        raise TypeError(f&#34;a tuple of two integers is required, not {point!r}&#34;)
    return (x2 &gt; ox &gt;= x1) and (y2 &gt; oy &gt;= y1)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.contains_region"><code class="name flex">
<span>def <span class="ident">contains_region</span></span>(<span>self, other: <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a region is entirely contained within this region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A region.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the other region fits perfectly within this region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_region(self, other: Region) -&gt; bool:
    &#34;&#34;&#34;Check if a region is entirely contained within this region.

    Args:
        other (Region): A region.

    Returns:
        bool: True if the other region fits perfectly within this region.
    &#34;&#34;&#34;
    x1, y1, x2, y2 = self.corners
    ox, oy, ox2, oy2 = other.corners
    return (x2 &gt;= ox &gt;= x1 and y2 &gt;= oy &gt;= y1) and (
        x2 &gt;= ox2 &gt;= x1 and y2 &gt;= oy2 &gt;= y1
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.expand"><code class="name flex">
<span>def <span class="ident">expand</span></span>(<span>self, size: tuple[int, int]) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Increase the size of the region by adding a border.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>Additional width and height.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A new region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand(self, size: tuple[int, int]) -&gt; Region:
    &#34;&#34;&#34;Increase the size of the region by adding a border.

    Args:
        size (tuple[int, int]): Additional width and height.

    Returns:
        Region: A new region.
    &#34;&#34;&#34;
    expand_width, expand_height = size
    x, y, width, height = self
    return Region(
        x - expand_width,
        y - expand_height,
        width + expand_width * 2,
        height + expand_height * 2,
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, region: <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get that covers both regions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A region that overlaps this region.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A new region that fits within <code>region</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, region: Region) -&gt; Region:
    &#34;&#34;&#34;Get that covers both regions.

    Args:
        region (Region): A region that overlaps this region.

    Returns:
        Region: A new region that fits within ``region``.
    &#34;&#34;&#34;
    # Unrolled because this method is used a lot
    x1, y1, w1, h1 = self
    cx1, cy1, w2, h2 = region
    x2 = x1 + w1
    y2 = y1 + h1
    cx2 = cx1 + w2
    cy2 = cy1 + h2

    rx1 = cx2 if x1 &gt; cx2 else (cx1 if x1 &lt; cx1 else x1)
    ry1 = cy2 if y1 &gt; cy2 else (cy1 if y1 &lt; cy1 else y1)
    rx2 = cx2 if x2 &gt; cx2 else (cx1 if x2 &lt; cx1 else x2)
    ry2 = cy2 if y2 &gt; cy2 else (cy1 if y2 &lt; cy1 else y2)

    return Region(rx1, ry1, rx2 - rx1, ry2 - ry1)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.overlaps"><code class="name flex">
<span>def <span class="ident">overlaps</span></span>(<span>self, other: <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if another region overlaps this region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A Region.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if other region shares any cells with this region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlaps(self, other: Region) -&gt; bool:
    &#34;&#34;&#34;Check if another region overlaps this region.

    Args:
        other (Region): A Region.

    Returns:
        bool: True if other region shares any cells with this region.
    &#34;&#34;&#34;
    x, y, x2, y2 = self.corners
    ox, oy, ox2, oy2 = other.corners

    return ((x2 &gt; ox &gt;= x) or (x2 &gt; ox2 &gt; x) or (ox &lt; x and ox2 &gt;= x2)) and (
        (y2 &gt; oy &gt;= y) or (y2 &gt; oy2 &gt; y) or (oy &lt; y and oy2 &gt;= y2)
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.shrink"><code class="name flex">
<span>def <span class="ident">shrink</span></span>(<span>self, margin: tuple[int, int, int, int]) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shrink a region by pushing each edge inwards.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></code></dt>
<dd>Defines how many cells to shrink the Region by at each edge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>The new, smaller region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shrink(self, margin: tuple[int, int, int, int]) -&gt; Region:
    &#34;&#34;&#34;Shrink a region by pushing each edge inwards.

    Args:
        margin (Spacing): Defines how many cells to shrink the Region by at each edge.

    Returns:
        Region: The new, smaller region.
    &#34;&#34;&#34;

    top, right, bottom, left = margin
    x, y, width, height = self
    return Region(
        x=x + left,
        y=y + top,
        width=max(0, width - left - right),
        height=max(0, height - top - bottom),
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, cut_x: int, cut_y: int) ‑> tuple[<a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Split a region in to 4 from given x and y offsets (cuts).</p>
<pre><code>       cut_x ↓
    ┌────────┐┌───┐
    │        ││   │
    │    0   ││ 1 │
    │        ││   │
</code></pre>
<p>cut_y → └────────┘└───┘
┌────────┐┌───┐
│
2
││ 3 │
└────────┘└───┘</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cut_x</code></strong> :&ensp;<code>int</code></dt>
<dd>Offset from self.x where the cut should be made. If negative, the cut
is taken from the right edge.</dd>
<dt><strong><code>cut_y</code></strong> :&ensp;<code>int</code></dt>
<dd>Offset from self.y where the cut should be made. If negative, the cut
is taken from the lower edge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[<a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>]</code></dt>
<dd>Four new regions which add up to the original (self).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, cut_x: int, cut_y: int) -&gt; tuple[Region, Region, Region, Region]:
    &#34;&#34;&#34;Split a region in to 4 from given x and y offsets (cuts).

               cut_x ↓
            ┌────────┐┌───┐
            │        ││   │
            │    0   ││ 1 │
            │        ││   │
    cut_y → └────────┘└───┘
            ┌────────┐┌───┐
            │    2   ││ 3 │
            └────────┘└───┘

    Args:
        cut_x (int): Offset from self.x where the cut should be made. If negative, the cut
            is taken from the right edge.
        cut_y (int): Offset from self.y where the cut should be made. If negative, the cut
            is taken from the lower edge.

    Returns:
        tuple[Region, Region, Region, Region]: Four new regions which add up to the original (self).
    &#34;&#34;&#34;

    x, y, width, height = self
    if cut_x &lt; 0:
        cut_x = width + cut_x
    if cut_y &lt; 0:
        cut_y = height + cut_y

    _Region = Region
    return (
        _Region(x, y, cut_x, cut_y),
        _Region(x + cut_x, y, width - cut_x, cut_y),
        _Region(x, y + cut_y, cut_x, height - cut_y),
        _Region(x + cut_x, y + cut_y, width - cut_x, height - cut_y),
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.split_horizontal"><code class="name flex">
<span>def <span class="ident">split_horizontal</span></span>(<span>self, cut: int) ‑> tuple[<a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Split a region in to two, from a given x offset.</p>
<pre><code>        ┌─────────┐
        │    0    │
        │         │
cut →   └─────────┘
        ┌─────────┐
        │    1    │
        └─────────┘
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cut</code></strong> :&ensp;<code>int</code></dt>
<dd>An offset from self.x where the cut should be made. May be negative,
for the offset to start from the right edge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[<a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>]</code></dt>
<dd>Two regions, which add up to the original (self).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_horizontal(self, cut: int) -&gt; tuple[Region, Region]:
    &#34;&#34;&#34;Split a region in to two, from a given x offset.

                ┌─────────┐
                │    0    │
                │         │
        cut →   └─────────┘
                ┌─────────┐
                │    1    │
                └─────────┘

    Args:
        cut (int): An offset from self.x where the cut should be made. May be negative,
            for the offset to start from the right edge.

    Returns:
        tuple[Region, Region]: Two regions, which add up to the original (self).
    &#34;&#34;&#34;
    x, y, width, height = self
    if cut &lt; 0:
        cut = height + cut

    return (
        Region(x, y, width, cut),
        Region(x, y + cut, width, height - cut),
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.split_vertical"><code class="name flex">
<span>def <span class="ident">split_vertical</span></span>(<span>self, cut: int) ‑> tuple[<a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Split a region in to two, from a given x offset.</p>
<pre><code>     cut ↓
┌────────┐┌───┐
│    0   ││ 1 │
│        ││   │
└────────┘└───┘
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cut</code></strong> :&ensp;<code>int</code></dt>
<dd>An offset from self.x where the cut should be made. If cut is negative,
it is taken from the right edge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[<a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>, <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>]</code></dt>
<dd>Two regions, which add up to the original (self).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_vertical(self, cut: int) -&gt; tuple[Region, Region]:
    &#34;&#34;&#34;Split a region in to two, from a given x offset.

             cut ↓
        ┌────────┐┌───┐
        │    0   ││ 1 │
        │        ││   │
        └────────┘└───┘

    Args:
        cut (int): An offset from self.x where the cut should be made. If cut is negative,
            it is taken from the right edge.

    Returns:
        tuple[Region, Region]: Two regions, which add up to the original (self).
    &#34;&#34;&#34;

    x, y, width, height = self
    if cut &lt; 0:
        cut = width + cut

    return (
        Region(x, y, cut, height),
        Region(x + cut, y, width - cut, height),
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, x: int = 0, y: int = 0) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Move the origin of the Region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>translate_x</code></strong> :&ensp;<code>int</code></dt>
<dd>Value to add to x coordinate.</dd>
<dt><strong><code>translate_y</code></strong> :&ensp;<code>int</code></dt>
<dd>Value to add to y coordinate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>A new region shifted by x, y</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, x: int = 0, y: int = 0) -&gt; Region:
    &#34;&#34;&#34;Move the origin of the Region.

    Args:
        translate_x (int): Value to add to x coordinate.
        translate_y (int): Value to add to y coordinate.

    Returns:
        Region: A new region shifted by x, y
    &#34;&#34;&#34;

    self_x, self_y, width, height = self
    return Region(self_x + x, self_y + y, width, height)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Region.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, region: <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a>) ‑> <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a new region that contains both regions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, region: Region) -&gt; Region:
    &#34;&#34;&#34;Get a new region that contains both regions.

    Args:
        region (Region): [description]

    Returns:
        Region: [description]
    &#34;&#34;&#34;
    x1, y1, x2, y2 = self.corners
    ox1, oy1, ox2, oy2 = region.corners

    union_region = self.from_corners(
        min(x1, ox1), min(y1, oy1), max(x2, ox2), max(y2, oy2)
    )
    return union_region</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.geometry.Size"><code class="flex name class">
<span>class <span class="ident">Size</span></span>
<span>(</span><span>width: int = 0, height: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>An area defined by its width and height.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Size(NamedTuple):
    &#34;&#34;&#34;An area defined by its width and height.&#34;&#34;&#34;

    width: int = 0
    height: int = 0

    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;A Size is Falsy if it has area 0.&#34;&#34;&#34;
        return self.width * self.height != 0

    @property
    def area(self) -&gt; int:
        &#34;&#34;&#34;Get the area of the size.

        Returns:
            int: Area in cells.
        &#34;&#34;&#34;
        return self.width * self.height

    @property
    def region(self) -&gt; Region:
        &#34;&#34;&#34;Get a region of the same size.&#34;&#34;&#34;
        width, height = self
        return Region(0, 0, width, height)

    def __add__(self, other: object) -&gt; Size:
        if isinstance(other, tuple):
            width, height = self
            width2, height2 = other
            return Size(max(0, width + width2), max(0, height + height2))
        return NotImplemented

    def __sub__(self, other: object) -&gt; Size:
        if isinstance(other, tuple):
            width, height = self
            width2, height2 = other
            return Size(max(0, width - width2), max(0, height - height2))
        return NotImplemented

    def contains(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the size.

        Args:
            x (int): X coordinate (column)
            y (int): Y coordinate (row)

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        width, height = self
        return width &gt; x &gt;= 0 and height &gt; y &gt;= 0

    def contains_point(self, point: tuple[int, int]) -&gt; bool:
        &#34;&#34;&#34;Check if a point is in the size.

        Args:
            point (tuple[int, int]): A tuple of x and y coordinates.

        Returns:
            bool: True if the point is within the region.
        &#34;&#34;&#34;
        x, y = point
        width, height = self
        return width &gt; x &gt;= 0 and height &gt; y &gt;= 0

    def __contains__(self, other: Any) -&gt; bool:
        try:
            x, y = other
        except Exception:
            raise TypeError(
                &#34;Dimensions.__contains__ requires an iterable of two integers&#34;
            )
        width, height = self
        return width &gt; x &gt;= 0 and height &gt; y &gt;= 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="textual.geometry.Size.area"><code class="name">var <span class="ident">area</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the area of the size.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Area in cells.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def area(self) -&gt; int:
    &#34;&#34;&#34;Get the area of the size.

    Returns:
        int: Area in cells.
    &#34;&#34;&#34;
    return self.width * self.height</code></pre>
</details>
</dd>
<dt id="textual.geometry.Size.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="textual.geometry.Size.region"><code class="name">var <span class="ident">region</span> : <a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>Get a region of the same size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def region(self) -&gt; Region:
    &#34;&#34;&#34;Get a region of the same size.&#34;&#34;&#34;
    width, height = self
    return Region(0, 0, width, height)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Size.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.geometry.Size.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a point is in the size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>X coordinate (column)</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Y coordinate (row)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the point is within the region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, x: int, y: int) -&gt; bool:
    &#34;&#34;&#34;Check if a point is in the size.

    Args:
        x (int): X coordinate (column)
        y (int): Y coordinate (row)

    Returns:
        bool: True if the point is within the region.
    &#34;&#34;&#34;
    width, height = self
    return width &gt; x &gt;= 0 and height &gt; y &gt;= 0</code></pre>
</details>
</dd>
<dt id="textual.geometry.Size.contains_point"><code class="name flex">
<span>def <span class="ident">contains_point</span></span>(<span>self, point: tuple[int, int]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a point is in the size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>A tuple of x and y coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the point is within the region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_point(self, point: tuple[int, int]) -&gt; bool:
    &#34;&#34;&#34;Check if a point is in the size.

    Args:
        point (tuple[int, int]): A tuple of x and y coordinates.

    Returns:
        bool: True if the point is within the region.
    &#34;&#34;&#34;
    x, y = point
    width, height = self
    return width &gt; x &gt;= 0 and height &gt; y &gt;= 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.geometry.Spacing"><code class="flex name class">
<span>class <span class="ident">Spacing</span></span>
<span>(</span><span>top: int = 0, right: int = 0, bottom: int = 0, left: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>The spacing around a renderable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spacing(NamedTuple):
    &#34;&#34;&#34;The spacing around a renderable.&#34;&#34;&#34;

    top: int = 0
    right: int = 0
    bottom: int = 0
    left: int = 0

    def __bool__(self) -&gt; bool:
        return self != (0, 0, 0, 0)

    @property
    def width(self) -&gt; int:
        &#34;&#34;&#34;Total space in width.&#34;&#34;&#34;
        return self.left + self.right

    @property
    def height(self) -&gt; int:
        &#34;&#34;&#34;Total space in height.&#34;&#34;&#34;
        return self.top + self.bottom

    @property
    def top_left(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Top left space.&#34;&#34;&#34;
        return (self.left, self.top)

    @property
    def bottom_right(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Bottom right space.&#34;&#34;&#34;
        return (self.right, self.bottom)

    @property
    def totals(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Returns a tuple of (&lt;HORIZONTAL SPACE&gt;, &lt;VERTICAL SPACE&gt;).&#34;&#34;&#34;
        top, right, bottom, left = self
        return (left + right, top + bottom)

    @property
    def css(self) -&gt; str:
        &#34;&#34;&#34;Gets a string containing the spacing in CSS format.&#34;&#34;&#34;
        top, right, bottom, left = self
        if top == right == bottom == left:
            return f&#34;{top}&#34;
        if (top, right) == (bottom, left):
            return f&#34;{top} {right}&#34;
        else:
            return f&#34;{top} {right} {bottom} {left}&#34;

    @classmethod
    def unpack(cls, pad: SpacingDimensions) -&gt; Spacing:
        &#34;&#34;&#34;Unpack padding specified in CSS style.&#34;&#34;&#34;
        if isinstance(pad, int):
            return cls(pad, pad, pad, pad)
        pad_len = len(pad)
        if pad_len == 1:
            _pad = pad[0]
            return cls(_pad, _pad, _pad, _pad)
        if pad_len == 2:
            pad_top, pad_right = cast(Tuple[int, int], pad)
            return cls(pad_top, pad_right, pad_top, pad_right)
        if pad_len == 4:
            top, right, bottom, left = cast(Tuple[int, int, int, int], pad)
            return cls(top, right, bottom, left)
        raise ValueError(
            f&#34;1, 2 or 4 integers required for spacing properties; {pad_len} given&#34;
        )

    @classmethod
    def vertical(cls, amount: int) -&gt; Spacing:
        &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on vertical edges,
        and no horizontal spacing.

        Args:
            amount (int): The magnitude of spacing to apply to vertical edges

        Returns:
            Spacing: ``Spacing(amount, 0, amount, 0)``
        &#34;&#34;&#34;
        return Spacing(amount, 0, amount, 0)

    @classmethod
    def horizontal(cls, amount: int) -&gt; Spacing:
        &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on horizontal edges,
        and no vertical spacing.

        Args:
            amount (int): The magnitude of spacing to apply to horizontal edges

        Returns:
            Spacing: ``Spacing(0, amount, 0, amount)``
        &#34;&#34;&#34;
        return Spacing(0, amount, 0, amount)

    @classmethod
    def all(cls, amount: int) -&gt; Spacing:
        &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on all edges.

        Args:
            amount (int): The magnitude of spacing to apply to all edges

        Returns:
            Spacing: ``Spacing(amount, amount, amount, amount)``
        &#34;&#34;&#34;
        return Spacing(amount, amount, amount, amount)

    def __add__(self, other: object) -&gt; Spacing:
        if isinstance(other, tuple):
            top1, right1, bottom1, left1 = self
            top2, right2, bottom2, left2 = other
            return Spacing(
                top1 + top2, right1 + right2, bottom1 + bottom2, left1 + left2
            )
        return NotImplemented

    def __sub__(self, other: object) -&gt; Spacing:
        if isinstance(other, tuple):
            top1, right1, bottom1, left1 = self
            top2, right2, bottom2, left2 = other
            return Spacing(
                top1 - top2, right1 - right2, bottom1 - bottom2, left1 - left2
            )
        return NotImplemented</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="textual.geometry.Spacing.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>amount: int) ‑> <a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a Spacing with a given amount of spacing on all edges.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>The magnitude of spacing to apply to all edges</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></code></dt>
<dd><code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a>(amount, amount, amount, amount)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def all(cls, amount: int) -&gt; Spacing:
    &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on all edges.

    Args:
        amount (int): The magnitude of spacing to apply to all edges

    Returns:
        Spacing: ``Spacing(amount, amount, amount, amount)``
    &#34;&#34;&#34;
    return Spacing(amount, amount, amount, amount)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.horizontal"><code class="name flex">
<span>def <span class="ident">horizontal</span></span>(<span>amount: int) ‑> <a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a Spacing with a given amount of spacing on horizontal edges,
and no vertical spacing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>The magnitude of spacing to apply to horizontal edges</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></code></dt>
<dd><code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a>(0, amount, 0, amount)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def horizontal(cls, amount: int) -&gt; Spacing:
    &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on horizontal edges,
    and no vertical spacing.

    Args:
        amount (int): The magnitude of spacing to apply to horizontal edges

    Returns:
        Spacing: ``Spacing(0, amount, 0, amount)``
    &#34;&#34;&#34;
    return Spacing(0, amount, 0, amount)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>pad: SpacingDimensions) ‑> <a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></span>
</code></dt>
<dd>
<div class="desc"><p>Unpack padding specified in CSS style.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def unpack(cls, pad: SpacingDimensions) -&gt; Spacing:
    &#34;&#34;&#34;Unpack padding specified in CSS style.&#34;&#34;&#34;
    if isinstance(pad, int):
        return cls(pad, pad, pad, pad)
    pad_len = len(pad)
    if pad_len == 1:
        _pad = pad[0]
        return cls(_pad, _pad, _pad, _pad)
    if pad_len == 2:
        pad_top, pad_right = cast(Tuple[int, int], pad)
        return cls(pad_top, pad_right, pad_top, pad_right)
    if pad_len == 4:
        top, right, bottom, left = cast(Tuple[int, int, int, int], pad)
        return cls(top, right, bottom, left)
    raise ValueError(
        f&#34;1, 2 or 4 integers required for spacing properties; {pad_len} given&#34;
    )</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.vertical"><code class="name flex">
<span>def <span class="ident">vertical</span></span>(<span>amount: int) ‑> <a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a Spacing with a given amount of spacing on vertical edges,
and no horizontal spacing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>The magnitude of spacing to apply to vertical edges</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></code></dt>
<dd><code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a>(amount, 0, amount, 0)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def vertical(cls, amount: int) -&gt; Spacing:
    &#34;&#34;&#34;Construct a Spacing with a given amount of spacing on vertical edges,
    and no horizontal spacing.

    Args:
        amount (int): The magnitude of spacing to apply to vertical edges

    Returns:
        Spacing: ``Spacing(amount, 0, amount, 0)``
    &#34;&#34;&#34;
    return Spacing(amount, 0, amount, 0)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="textual.geometry.Spacing.bottom"><code class="name">var <span class="ident">bottom</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="textual.geometry.Spacing.bottom_right"><code class="name">var <span class="ident">bottom_right</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Bottom right space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bottom_right(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;Bottom right space.&#34;&#34;&#34;
    return (self.right, self.bottom)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.css"><code class="name">var <span class="ident">css</span> : str</code></dt>
<dd>
<div class="desc"><p>Gets a string containing the spacing in CSS format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def css(self) -&gt; str:
    &#34;&#34;&#34;Gets a string containing the spacing in CSS format.&#34;&#34;&#34;
    top, right, bottom, left = self
    if top == right == bottom == left:
        return f&#34;{top}&#34;
    if (top, right) == (bottom, left):
        return f&#34;{top} {right}&#34;
    else:
        return f&#34;{top} {right} {bottom} {left}&#34;</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"><p>Total space in height.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self) -&gt; int:
    &#34;&#34;&#34;Total space in height.&#34;&#34;&#34;
    return self.top + self.bottom</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.left"><code class="name">var <span class="ident">left</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="textual.geometry.Spacing.right"><code class="name">var <span class="ident">right</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="textual.geometry.Spacing.top"><code class="name">var <span class="ident">top</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="textual.geometry.Spacing.top_left"><code class="name">var <span class="ident">top_left</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Top left space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def top_left(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;Top left space.&#34;&#34;&#34;
    return (self.left, self.top)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.totals"><code class="name">var <span class="ident">totals</span> : tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of (<HORIZONTAL SPACE>, <VERTICAL SPACE>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def totals(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;Returns a tuple of (&lt;HORIZONTAL SPACE&gt;, &lt;VERTICAL SPACE&gt;).&#34;&#34;&#34;
    top, right, bottom, left = self
    return (left + right, top + bottom)</code></pre>
</details>
</dd>
<dt id="textual.geometry.Spacing.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>Total space in width.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; int:
    &#34;&#34;&#34;Total space in width.&#34;&#34;&#34;
    return self.left + self.right</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual" href="index.html">textual</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="textual.geometry.clamp" href="#textual.geometry.clamp">clamp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.geometry.Offset" href="#textual.geometry.Offset">Offset</a></code></h4>
<ul class="">
<li><code><a title="textual.geometry.Offset.blend" href="#textual.geometry.Offset.blend">blend</a></code></li>
<li><code><a title="textual.geometry.Offset.get_distance_to" href="#textual.geometry.Offset.get_distance_to">get_distance_to</a></code></li>
<li><code><a title="textual.geometry.Offset.is_origin" href="#textual.geometry.Offset.is_origin">is_origin</a></code></li>
<li><code><a title="textual.geometry.Offset.x" href="#textual.geometry.Offset.x">x</a></code></li>
<li><code><a title="textual.geometry.Offset.y" href="#textual.geometry.Offset.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.geometry.Region" href="#textual.geometry.Region">Region</a></code></h4>
<ul class="two-column">
<li><code><a title="textual.geometry.Region.area" href="#textual.geometry.Region.area">area</a></code></li>
<li><code><a title="textual.geometry.Region.clip" href="#textual.geometry.Region.clip">clip</a></code></li>
<li><code><a title="textual.geometry.Region.contains" href="#textual.geometry.Region.contains">contains</a></code></li>
<li><code><a title="textual.geometry.Region.contains_point" href="#textual.geometry.Region.contains_point">contains_point</a></code></li>
<li><code><a title="textual.geometry.Region.contains_region" href="#textual.geometry.Region.contains_region">contains_region</a></code></li>
<li><code><a title="textual.geometry.Region.corners" href="#textual.geometry.Region.corners">corners</a></code></li>
<li><code><a title="textual.geometry.Region.expand" href="#textual.geometry.Region.expand">expand</a></code></li>
<li><code><a title="textual.geometry.Region.from_corners" href="#textual.geometry.Region.from_corners">from_corners</a></code></li>
<li><code><a title="textual.geometry.Region.from_origin" href="#textual.geometry.Region.from_origin">from_origin</a></code></li>
<li><code><a title="textual.geometry.Region.height" href="#textual.geometry.Region.height">height</a></code></li>
<li><code><a title="textual.geometry.Region.intersection" href="#textual.geometry.Region.intersection">intersection</a></code></li>
<li><code><a title="textual.geometry.Region.origin" href="#textual.geometry.Region.origin">origin</a></code></li>
<li><code><a title="textual.geometry.Region.overlaps" href="#textual.geometry.Region.overlaps">overlaps</a></code></li>
<li><code><a title="textual.geometry.Region.reset_origin" href="#textual.geometry.Region.reset_origin">reset_origin</a></code></li>
<li><code><a title="textual.geometry.Region.shrink" href="#textual.geometry.Region.shrink">shrink</a></code></li>
<li><code><a title="textual.geometry.Region.size" href="#textual.geometry.Region.size">size</a></code></li>
<li><code><a title="textual.geometry.Region.split" href="#textual.geometry.Region.split">split</a></code></li>
<li><code><a title="textual.geometry.Region.split_horizontal" href="#textual.geometry.Region.split_horizontal">split_horizontal</a></code></li>
<li><code><a title="textual.geometry.Region.split_vertical" href="#textual.geometry.Region.split_vertical">split_vertical</a></code></li>
<li><code><a title="textual.geometry.Region.translate" href="#textual.geometry.Region.translate">translate</a></code></li>
<li><code><a title="textual.geometry.Region.union" href="#textual.geometry.Region.union">union</a></code></li>
<li><code><a title="textual.geometry.Region.width" href="#textual.geometry.Region.width">width</a></code></li>
<li><code><a title="textual.geometry.Region.x" href="#textual.geometry.Region.x">x</a></code></li>
<li><code><a title="textual.geometry.Region.x_extents" href="#textual.geometry.Region.x_extents">x_extents</a></code></li>
<li><code><a title="textual.geometry.Region.x_max" href="#textual.geometry.Region.x_max">x_max</a></code></li>
<li><code><a title="textual.geometry.Region.x_range" href="#textual.geometry.Region.x_range">x_range</a></code></li>
<li><code><a title="textual.geometry.Region.y" href="#textual.geometry.Region.y">y</a></code></li>
<li><code><a title="textual.geometry.Region.y_extents" href="#textual.geometry.Region.y_extents">y_extents</a></code></li>
<li><code><a title="textual.geometry.Region.y_max" href="#textual.geometry.Region.y_max">y_max</a></code></li>
<li><code><a title="textual.geometry.Region.y_range" href="#textual.geometry.Region.y_range">y_range</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.geometry.Size" href="#textual.geometry.Size">Size</a></code></h4>
<ul class="two-column">
<li><code><a title="textual.geometry.Size.area" href="#textual.geometry.Size.area">area</a></code></li>
<li><code><a title="textual.geometry.Size.contains" href="#textual.geometry.Size.contains">contains</a></code></li>
<li><code><a title="textual.geometry.Size.contains_point" href="#textual.geometry.Size.contains_point">contains_point</a></code></li>
<li><code><a title="textual.geometry.Size.height" href="#textual.geometry.Size.height">height</a></code></li>
<li><code><a title="textual.geometry.Size.region" href="#textual.geometry.Size.region">region</a></code></li>
<li><code><a title="textual.geometry.Size.width" href="#textual.geometry.Size.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.geometry.Spacing" href="#textual.geometry.Spacing">Spacing</a></code></h4>
<ul class="two-column">
<li><code><a title="textual.geometry.Spacing.all" href="#textual.geometry.Spacing.all">all</a></code></li>
<li><code><a title="textual.geometry.Spacing.bottom" href="#textual.geometry.Spacing.bottom">bottom</a></code></li>
<li><code><a title="textual.geometry.Spacing.bottom_right" href="#textual.geometry.Spacing.bottom_right">bottom_right</a></code></li>
<li><code><a title="textual.geometry.Spacing.css" href="#textual.geometry.Spacing.css">css</a></code></li>
<li><code><a title="textual.geometry.Spacing.height" href="#textual.geometry.Spacing.height">height</a></code></li>
<li><code><a title="textual.geometry.Spacing.horizontal" href="#textual.geometry.Spacing.horizontal">horizontal</a></code></li>
<li><code><a title="textual.geometry.Spacing.left" href="#textual.geometry.Spacing.left">left</a></code></li>
<li><code><a title="textual.geometry.Spacing.right" href="#textual.geometry.Spacing.right">right</a></code></li>
<li><code><a title="textual.geometry.Spacing.top" href="#textual.geometry.Spacing.top">top</a></code></li>
<li><code><a title="textual.geometry.Spacing.top_left" href="#textual.geometry.Spacing.top_left">top_left</a></code></li>
<li><code><a title="textual.geometry.Spacing.totals" href="#textual.geometry.Spacing.totals">totals</a></code></li>
<li><code><a title="textual.geometry.Spacing.unpack" href="#textual.geometry.Spacing.unpack">unpack</a></code></li>
<li><code><a title="textual.geometry.Spacing.vertical" href="#textual.geometry.Spacing.vertical">vertical</a></code></li>
<li><code><a title="textual.geometry.Spacing.width" href="#textual.geometry.Spacing.width">width</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>