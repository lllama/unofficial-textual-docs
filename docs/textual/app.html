<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.app API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.app</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import asyncio
import inspect
import io
import os
import platform
import sys
import unicodedata
import warnings
from contextlib import redirect_stderr, redirect_stdout
from datetime import datetime
from pathlib import Path, PurePath
from time import perf_counter
from typing import Any, Generic, Iterable, Type, TYPE_CHECKING, TypeVar, cast, Union
from weakref import WeakSet, WeakValueDictionary

from ._ansi_sequences import SYNC_END, SYNC_START
from ._path import _make_path_object_relative

import nanoid
import rich
import rich.repr
from rich.console import Console, RenderableType
from rich.protocol import is_renderable
from rich.segment import Segment, Segments
from rich.traceback import Traceback

from . import Logger, LogGroup, LogVerbosity, actions, events, log, messages
from ._animator import Animator, DEFAULT_EASING, Animatable, EasingFunction
from ._callback import invoke
from ._context import active_app
from ._event_broker import NoHandler, extract_handler_actions
from ._filter import LineFilter, Monochrome
from .binding import Binding, Bindings
from .css.query import NoMatches
from .css.stylesheet import Stylesheet
from .design import ColorSystem
from .dom import DOMNode
from .driver import Driver
from .drivers.headless_driver import HeadlessDriver
from .features import FeatureFlag, parse_features
from .file_monitor import FileMonitor
from .geometry import Offset, Region, Size
from .keys import REPLACED_KEYS
from .messages import CallbackType
from .reactive import Reactive
from .renderables.blank import Blank
from .screen import Screen
from .widget import AwaitMount, Widget

if TYPE_CHECKING:
    from .devtools.client import DevtoolsClient


PLATFORM = platform.system()
WINDOWS = PLATFORM == &#34;Windows&#34;

# asyncio will warn against resources not being cleared
warnings.simplefilter(&#34;always&#34;, ResourceWarning)

# `asyncio.get_event_loop()` is deprecated since Python 3.10:
_ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED = sys.version_info &gt;= (3, 10, 0)

LayoutDefinition = &#34;dict[str, Any]&#34;

DEFAULT_COLORS = {
    &#34;dark&#34;: ColorSystem(
        primary=&#34;#004578&#34;,
        secondary=&#34;#ffa62b&#34;,
        warning=&#34;#ffa62b&#34;,
        error=&#34;#ba3c5b&#34;,
        success=&#34;#4EBF71&#34;,
        accent=&#34;#0178D4&#34;,
        dark=True,
    ),
    &#34;light&#34;: ColorSystem(
        primary=&#34;#004578&#34;,
        secondary=&#34;#ffa62b&#34;,
        warning=&#34;#ffa62b&#34;,
        error=&#34;#ba3c5b&#34;,
        success=&#34;#4EBF71&#34;,
        accent=&#34;#0178D4&#34;,
        dark=False,
    ),
}

ComposeResult = Iterable[Widget]
RenderResult = RenderableType


class AppError(Exception):
    pass


class ActionError(Exception):
    pass


class ScreenError(Exception):
    pass


class ScreenStackError(ScreenError):
    &#34;&#34;&#34;Raised when attempting to pop the last screen from the stack.&#34;&#34;&#34;


ReturnType = TypeVar(&#34;ReturnType&#34;)


class _NullFile:
    def write(self, text: str) -&gt; None:
        pass

    def flush(self) -&gt; None:
        pass


CSSPathType = Union[str, PurePath, None]


@rich.repr.auto
class App(Generic[ReturnType], DOMNode):
    &#34;&#34;&#34;The base class for Textual Applications.

    Args:
        driver_class (Type[Driver] | None, optional): Driver class or ``None`` to auto-detect. Defaults to None.
        title (str | None, optional): Title of the application. If ``None``, the title is set to the name of the ``App`` subclass. Defaults to ``None``.
        css_path (str | PurePath | None, optional): Path to CSS or ``None`` for no CSS file. Defaults to None.
        watch_css (bool, optional): Watch CSS for changes. Defaults to False.
    &#34;&#34;&#34;

    # Inline CSS for quick scripts (generally css_path should be preferred.)
    CSS = &#34;&#34;

    # Default (lowest priority) CSS
    DEFAULT_CSS = &#34;&#34;&#34;
    App {
        background: $background;
        color: $text;
    }
    &#34;&#34;&#34;

    SCREENS: dict[str, Screen] = {}
    _BASE_PATH: str | None = None
    CSS_PATH: CSSPathType = None
    TITLE: str | None = None
    SUB_TITLE: str | None = None

    title: Reactive[str] = Reactive(&#34;&#34;)
    sub_title: Reactive[str] = Reactive(&#34;&#34;)
    dark: Reactive[bool] = Reactive(True)

    def __init__(
        self,
        driver_class: Type[Driver] | None = None,
        css_path: CSSPathType = None,
        watch_css: bool = False,
    ):
        # N.B. This must be done *before* we call the parent constructor, because MessagePump&#39;s
        # constructor instantiates a `asyncio.PriorityQueue` and in Python versions older than 3.10
        # this will create some first references to an asyncio loop.
        _init_uvloop()

        super().__init__()
        self.features: frozenset[FeatureFlag] = parse_features(os.getenv(&#34;TEXTUAL&#34;, &#34;&#34;))

        self._filter: LineFilter | None = None
        environ = dict(os.environ)
        no_color = environ.pop(&#34;NO_COLOR&#34;, None)
        if no_color is not None:
            self._filter = Monochrome()
        self.console = Console(
            file=(_NullFile() if self.is_headless else sys.__stdout__),
            markup=False,
            highlight=False,
            emoji=False,
            legacy_windows=False,
            _environ=environ,
        )
        self.error_console = Console(markup=False, stderr=True)
        self.driver_class = driver_class or self.get_driver_class()
        self._screen_stack: list[Screen] = []
        self._sync_available = False

        self.mouse_over: Widget | None = None
        self.mouse_captured: Widget | None = None
        self._driver: Driver | None = None
        self._exit_renderables: list[RenderableType] = []

        self._action_targets = {&#34;app&#34;, &#34;screen&#34;}
        self._animator = Animator(self)
        self._animate = self._animator.bind(self)
        self.mouse_position = Offset(0, 0)
        self.title = (
            self.TITLE if self.TITLE is not None else f&#34;{self.__class__.__name__}&#34;
        )
        self.sub_title = self.SUB_TITLE if self.SUB_TITLE is not None else &#34;&#34;

        self._logger = Logger(self._log)

        self._bindings.bind(&#34;ctrl+c&#34;, &#34;quit&#34;, show=False, universal=True)
        self._refresh_required = False

        self.design = DEFAULT_COLORS

        self.stylesheet = Stylesheet(variables=self.get_css_variables())
        self._require_stylesheet_update: set[DOMNode] = set()

        # We want the CSS path to be resolved from the location of the App subclass
        css_path = css_path or self.CSS_PATH
        if css_path is not None:
            if isinstance(css_path, str):
                css_path = Path(css_path)
            css_path = _make_path_object_relative(css_path, self) if css_path else None

        self.css_path = css_path

        self._registry: WeakSet[DOMNode] = WeakSet()

        self._installed_screens: WeakValueDictionary[
            str, Screen
        ] = WeakValueDictionary()
        self._installed_screens.update(**self.SCREENS)

        self.devtools: DevtoolsClient | None = None
        if &#34;devtools&#34; in self.features:
            try:
                from .devtools.client import DevtoolsClient
            except ImportError:
                # Dev dependencies not installed
                pass
            else:
                self.devtools = DevtoolsClient()

        self._return_value: ReturnType | None = None

        self.css_monitor = (
            FileMonitor(self.css_path, self._on_css_change)
            if ((watch_css or self.debug) and self.css_path)
            else None
        )
        self._screenshot: str | None = None

    def animate(
        self,
        attribute: str,
        value: float | Animatable,
        *,
        final_value: object = ...,
        duration: float | None = None,
        speed: float | None = None,
        delay: float = 0.0,
        easing: EasingFunction | str = DEFAULT_EASING,
        on_complete: CallbackType | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Animate an attribute.

        Args:
            attribute (str): Name of the attribute to animate.
            value (float | Animatable): The value to animate to.
            final_value (object, optional): The final value of the animation. Defaults to `value` if not set.
            duration (float | None, optional): The duration of the animate. Defaults to None.
            speed (float | None, optional): The speed of the animation. Defaults to None.
            delay (float, optional): A delay (in seconds) before the animation starts. Defaults to 0.0.
            easing (EasingFunction | str, optional): An easing method. Defaults to &#34;in_out_cubic&#34;.
            on_complete (CallbackType | None, optional): A callable to invoke when the animation is finished. Defaults to None.

        &#34;&#34;&#34;
        self._animate(
            attribute,
            value,
            final_value=final_value,
            duration=duration,
            speed=speed,
            delay=delay,
            easing=easing,
            on_complete=on_complete,
        )

    @property
    def debug(self) -&gt; bool:
        &#34;&#34;&#34;Check if debug mode is enabled.

        Returns:
            bool: True if debug mode is enabled.

        &#34;&#34;&#34;
        return &#34;debug&#34; in self.features

    @property
    def is_headless(self) -&gt; bool:
        &#34;&#34;&#34;Check if the app is running in &#39;headless&#39; mode.

        Returns:
            bool: True if the app is in headless mode.

        &#34;&#34;&#34;
        return &#34;headless&#34; in self.features

    @property
    def screen_stack(self) -&gt; list[Screen]:
        &#34;&#34;&#34;Get a *copy* of the screen stack.

        Returns:
            list[Screen]: List of screens.

        &#34;&#34;&#34;
        return self._screen_stack.copy()

    def exit(self, result: ReturnType | None = None) -&gt; None:
        &#34;&#34;&#34;Exit the app, and return the supplied result.

        Args:
            result (ReturnType | None, optional): Return value. Defaults to None.
        &#34;&#34;&#34;
        self._return_value = result
        self._close_messages_no_wait()

    @property
    def focused(self) -&gt; Widget | None:
        &#34;&#34;&#34;Get the widget that is focused on the currently active screen.&#34;&#34;&#34;
        return self.screen.focused

    @property
    def namespace_bindings(self) -&gt; dict[str, tuple[DOMNode, Binding]]:
        &#34;&#34;&#34;Get current bindings. If no widget is focused, then the app-level bindings
        are returned. If a widget is focused, then any bindings present in the active
        screen and app are merged and returned.&#34;&#34;&#34;

        namespace_binding_map: dict[str, tuple[DOMNode, Binding]] = {}
        for namespace, bindings in reversed(self._binding_chain):
            for key, binding in bindings.keys.items():
                namespace_binding_map[key] = (namespace, binding)

        return namespace_binding_map

    def _set_active(self) -&gt; None:
        &#34;&#34;&#34;Set this app to be the currently active app.&#34;&#34;&#34;
        active_app.set(self)

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def get_css_variables(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Get a mapping of variables used to pre-populate CSS.

        Returns:
            dict[str, str]: A mapping of variable name to value.
        &#34;&#34;&#34;
        variables = self.design[&#34;dark&#34; if self.dark else &#34;light&#34;].generate()
        return variables

    def watch_dark(self, dark: bool) -&gt; None:
        &#34;&#34;&#34;Watches the dark bool.&#34;&#34;&#34;
        self.set_class(dark, &#34;-dark-mode&#34;)
        self.set_class(not dark, &#34;-light-mode&#34;)
        self.refresh_css()

    def get_driver_class(self) -&gt; Type[Driver]:
        &#34;&#34;&#34;Get a driver class for this platform.

        Called by the constructor.

        Returns:
            Driver: A Driver class which manages input and display.
        &#34;&#34;&#34;
        driver_class: Type[Driver]
        if WINDOWS:
            from .drivers.windows_driver import WindowsDriver

            driver_class = WindowsDriver
        else:
            from .drivers.linux_driver import LinuxDriver

            driver_class = LinuxDriver
        return driver_class

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;title&#34;, self.title
        yield &#34;id&#34;, self.id, None
        if self.name:
            yield &#34;name&#34;, self.name
        if self.classes:
            yield &#34;classes&#34;, set(self.classes)
        pseudo_classes = self.pseudo_classes
        if pseudo_classes:
            yield &#34;pseudo_classes&#34;, set(pseudo_classes)

    @property
    def is_transparent(self) -&gt; bool:
        return True

    @property
    def animator(self) -&gt; Animator:
        return self._animator

    @property
    def screen(self) -&gt; Screen:
        &#34;&#34;&#34;Get the current screen.

        Raises:
            ScreenStackError: If there are no screens on the stack.

        Returns:
            Screen: The currently active screen.
        &#34;&#34;&#34;
        try:
            return self._screen_stack[-1]
        except IndexError:
            raise ScreenStackError(&#34;No screens on stack&#34;) from None

    @property
    def size(self) -&gt; Size:
        &#34;&#34;&#34;Get the size of the terminal.

        Returns:
            Size: Size of the terminal
        &#34;&#34;&#34;
        return Size(*self.console.size)

    @property
    def log(self) -&gt; Logger:
        return self._logger

    def _log(
        self,
        group: LogGroup,
        verbosity: LogVerbosity,
        _textual_calling_frame: inspect.FrameInfo,
        *objects: Any,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;Write to logs or devtools.

        Positional args will logged. Keyword args will be prefixed with the key.

        Example:
            ```python
            data = [1,2,3]
            self.log(&#34;Hello, World&#34;, state=data)
            self.log(self.tree)
            self.log(locals())
            ```

        Args:
            verbosity (int, optional): Verbosity level 0-3. Defaults to 1.
        &#34;&#34;&#34;

        devtools = self.devtools
        if devtools is None or not devtools.is_connected:
            return

        if verbosity.value &gt; LogVerbosity.NORMAL.value and not devtools.verbose:
            return

        try:
            from .devtools.client import DevtoolsLog

            if len(objects) == 1 and not kwargs:
                devtools.log(
                    DevtoolsLog(objects, caller=_textual_calling_frame),
                    group,
                    verbosity,
                )
            else:
                output = &#34; &#34;.join(str(arg) for arg in objects)
                if kwargs:
                    key_values = &#34; &#34;.join(
                        f&#34;{key}={value!r}&#34; for key, value in kwargs.items()
                    )
                    output = f&#34;{output} {key_values}&#34; if output else key_values
                devtools.log(
                    DevtoolsLog(output, caller=_textual_calling_frame),
                    group,
                    verbosity,
                )
        except Exception as error:
            self._handle_exception(error)

    def action_toggle_dark(self) -&gt; None:
        &#34;&#34;&#34;Action to toggle dark mode.&#34;&#34;&#34;
        self.dark = not self.dark

    def action_screenshot(self, filename: str | None = None, path: str = &#34;./&#34;) -&gt; None:
        &#34;&#34;&#34;Save an SVG &#34;screenshot&#34;. This action will save an SVG file containing the current contents of the screen.

        Args:
            filename (str | None, optional): Filename of screenshot, or None to auto-generate. Defaults to None.
            path (str, optional): Path to directory. Defaults to &#34;~/&#34;.
        &#34;&#34;&#34;
        self.save_screenshot(filename, path)

    def export_screenshot(self, *, title: str | None = None) -&gt; str:
        &#34;&#34;&#34;Export an SVG screenshot of the current screen.

        Args:
            title (str | None, optional): The title of the exported screenshot or None
                to use app title. Defaults to None.

        &#34;&#34;&#34;

        console = Console(
            width=self.console.width,
            height=self.console.height,
            file=io.StringIO(),
            force_terminal=True,
            color_system=&#34;truecolor&#34;,
            record=True,
            legacy_windows=False,
        )
        screen_render = self.screen._compositor.render(full=True)
        console.print(screen_render)
        return console.export_svg(title=title or self.title)

    def save_screenshot(
        self,
        filename: str | None = None,
        path: str = &#34;./&#34;,
        time_format: str = &#34;%Y-%m-%d %X %f&#34;,
    ) -&gt; str:
        &#34;&#34;&#34;Save an SVG screenshot of the current screen.

        Args:
            filename (str | None, optional): Filename of SVG screenshot, or None to auto-generate
                a filename with the date and time. Defaults to None.
            path (str, optional): Path to directory for output. Defaults to current working directory.
            time_format (str, optional): Time format to use if filename is None. Defaults to &#34;%Y-%m-%d %X %f&#34;.

        Returns:
            str: Filename of screenshot.
        &#34;&#34;&#34;
        if filename is None:
            svg_filename = (
                f&#34;{self.title.lower()} {datetime.now().strftime(time_format)}.svg&#34;
            )
            svg_filename = svg_filename.replace(&#34;/&#34;, &#34;_&#34;).replace(&#34;\\&#34;, &#34;_&#34;)
        else:
            svg_filename = filename
        svg_path = os.path.expanduser(os.path.join(path, svg_filename))
        screenshot_svg = self.export_screenshot()
        with open(svg_path, &#34;w&#34;) as svg_file:
            svg_file.write(screenshot_svg)
        return svg_path

    def bind(
        self,
        keys: str,
        action: str,
        *,
        description: str = &#34;&#34;,
        show: bool = True,
        key_display: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Bind a key to an action.

        Args:
            keys (str): A comma separated list of keys, i.e.
            action (str): Action to bind to.
            description (str, optional): Short description of action. Defaults to &#34;&#34;.
            show (bool, optional): Show key in UI. Defaults to True.
            key_display (str, optional): Replacement text for key, or None to use default. Defaults to None.
        &#34;&#34;&#34;
        self._bindings.bind(
            keys, action, description, show=show, key_display=key_display
        )

    def run(
        self,
        *,
        quit_after: float | None = None,
        headless: bool = False,
        press: Iterable[str] | None = None,
        screenshot: bool = False,
        screenshot_title: str | None = None,
    ) -&gt; ReturnType | None:
        &#34;&#34;&#34;The main entry point for apps.

        Args:
            quit_after (float | None, optional): Quit after a given number of seconds, or None
                to run forever. Defaults to None.
            headless (bool, optional): Run in &#34;headless&#34; mode (don&#39;t write to stdout).
            press (str, optional): An iterable of keys to simulate being pressed.
            screenshot (bool, optional): Take a screenshot after pressing keys (svg data stored in self._screenshot). Defaults to False.
            screenshot_title (str | None, optional): Title of screenshot, or None to use App title. Defaults to None.

        Returns:
            ReturnType | None: The return value specified in `App.exit` or None if exit wasn&#39;t called.
        &#34;&#34;&#34;

        if headless:
            self.features = cast(
                &#34;frozenset[FeatureFlag]&#34;, self.features.union({&#34;headless&#34;})
            )

        async def run_app() -&gt; None:
            if quit_after is not None:
                self.set_timer(quit_after, self.shutdown)
            if press is not None:
                app = self

                async def press_keys() -&gt; None:
                    &#34;&#34;&#34;A task to send key events.&#34;&#34;&#34;
                    assert press
                    driver = app._driver
                    assert driver is not None
                    await asyncio.sleep(0.01)
                    for key in press:
                        if key == &#34;_&#34;:
                            print(&#34;(pause 50ms)&#34;)
                            await asyncio.sleep(0.05)
                        elif key.startswith(&#34;wait:&#34;):
                            _, wait_ms = key.split(&#34;:&#34;)
                            print(f&#34;(pause {wait_ms}ms)&#34;)
                            await asyncio.sleep(float(wait_ms) / 1000)
                        else:
                            if len(key) == 1 and not key.isalnum():
                                key = (
                                    unicodedata.name(key)
                                    .lower()
                                    .replace(&#34;-&#34;, &#34;_&#34;)
                                    .replace(&#34; &#34;, &#34;_&#34;)
                                )
                            original_key = REPLACED_KEYS.get(key, key)
                            try:
                                char = unicodedata.lookup(
                                    original_key.upper().replace(&#34;_&#34;, &#34; &#34;)
                                )
                            except KeyError:
                                char = key if len(key) == 1 else None
                            print(f&#34;press {key!r} (char={char!r})&#34;)
                            key_event = events.Key(self, key, char)
                            driver.send_event(key_event)
                            await asyncio.sleep(0.01)

                    await app._animator.wait_for_idle()

                    if screenshot:
                        self._screenshot = self.export_screenshot(
                            title=screenshot_title
                        )
                    await self.shutdown()

                async def press_keys_task():
                    &#34;&#34;&#34;Press some keys in the background.&#34;&#34;&#34;
                    asyncio.create_task(press_keys())

                await self._process_messages(ready_callback=press_keys_task)
            else:
                await self._process_messages()

        if _ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED:
            # N.B. This doesn&#39;t work with Python&lt;3.10, as we end up with 2 event loops:
            asyncio.run(run_app())
        else:
            # However, this works with Python&lt;3.10:
            event_loop = asyncio.get_event_loop()
            event_loop.run_until_complete(run_app())

        return self._return_value

    async def _on_css_change(self) -&gt; None:
        &#34;&#34;&#34;Called when the CSS changes (if watch_css is True).&#34;&#34;&#34;
        if self.css_path is not None:
            try:
                time = perf_counter()
                stylesheet = self.stylesheet.copy()
                stylesheet.read(self.css_path)
                stylesheet.parse()
                elapsed = (perf_counter() - time) * 1000
                self.log.system(
                    f&#34;&lt;stylesheet&gt; loaded {self.css_path!r} in {elapsed:.0f} ms&#34;
                )
            except Exception as error:
                # TODO: Catch specific exceptions
                self.log.error(error)
                self.bell()
            else:
                self.stylesheet = stylesheet
                self.reset_styles()
                self.stylesheet.update(self)
                self.screen.refresh(layout=True)

    def render(self) -&gt; RenderableType:
        return Blank(self.styles.background)

    def get_child(self, id: str) -&gt; DOMNode:
        &#34;&#34;&#34;Shorthand for self.screen.get_child(id: str)
        Returns the first child (immediate descendent) of this DOMNode
        with the given ID.

        Args:
            id (str): The ID of the node to search for.

        Returns:
            DOMNode: The first child of this node with the specified ID.

        Raises:
            NoMatches: if no children could be found for this ID
        &#34;&#34;&#34;
        return self.screen.get_child(id)

    def update_styles(self, node: DOMNode | None = None) -&gt; None:
        &#34;&#34;&#34;Request update of styles.

        Should be called whenever CSS classes / pseudo classes change.

        &#34;&#34;&#34;
        self._require_stylesheet_update.add(self.screen if node is None else node)
        self.check_idle()

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; AwaitMount:
        &#34;&#34;&#34;Mount widgets. Widgets specified as positional args, or keywords args. If supplied
        as keyword args they will be assigned an id of the key.

        Returns:
            AwaitMount: An awaitable object that waits for widgets to be mounted.

        &#34;&#34;&#34;
        mounted_widgets = self._register(self.screen, *anon_widgets, **widgets)
        return AwaitMount(mounted_widgets)

    def mount_all(self, widgets: Iterable[Widget]) -&gt; AwaitMount:
        &#34;&#34;&#34;Mount widgets from an iterable.

        Args:
            widgets (Iterable[Widget]): An iterable of widgets.
        &#34;&#34;&#34;
        mounted_widgets = list(widgets)
        for widget in mounted_widgets:
            self._register(self.screen, widget)
        return AwaitMount(mounted_widgets)

    def is_screen_installed(self, screen: Screen | str) -&gt; bool:
        &#34;&#34;&#34;Check if a given screen has been installed.

        Args:
            screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

        Returns:
            bool: True if the screen is currently installed,
        &#34;&#34;&#34;
        if isinstance(screen, str):
            return screen in self._installed_screens
        else:
            return screen in self._installed_screens.values()

    def get_screen(self, screen: Screen | str) -&gt; Screen:
        &#34;&#34;&#34;Get an installed screen.

        If the screen isn&#39;t running, it will be registered before it is run.

        Args:
            screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

        Raises:
            KeyError: If the named screen doesn&#39;t exist.

        Returns:
            Screen: A screen instance.
        &#34;&#34;&#34;
        if isinstance(screen, str):
            try:
                next_screen = self._installed_screens[screen]
            except KeyError:
                raise KeyError(f&#34;No screen called {screen!r} installed&#34;) from None
        else:
            next_screen = screen
        if not next_screen.is_running:
            self._register(self, next_screen)
        return next_screen

    def _replace_screen(self, screen: Screen) -&gt; Screen:
        &#34;&#34;&#34;Handle the replaced screen.

        Args:
            screen (Screen): A screen object.

        Returns:
            Screen: The screen that was replaced.

        &#34;&#34;&#34;
        screen.post_message_no_wait(events.ScreenSuspend(self))
        self.log.system(f&#34;{screen} SUSPENDED&#34;)
        if not self.is_screen_installed(screen) and screen not in self._screen_stack:
            screen.remove()
            self.log.system(f&#34;{screen} REMOVED&#34;)
        return screen

    def push_screen(self, screen: Screen | str) -&gt; None:
        &#34;&#34;&#34;Push a new screen on the screen stack.

        Args:
            screen (Screen | str): A Screen instance or the name of an installed screen.

        &#34;&#34;&#34;
        next_screen = self.get_screen(screen)
        self._screen_stack.append(next_screen)
        self.screen.post_message_no_wait(events.ScreenResume(self))
        self.log.system(f&#34;{self.screen} is current (PUSHED)&#34;)

    def switch_screen(self, screen: Screen | str) -&gt; None:
        &#34;&#34;&#34;Switch to another screen by replacing the top of the screen stack with a new screen.

        Args:
            screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

        &#34;&#34;&#34;
        if self.screen is not screen:
            self._replace_screen(self._screen_stack.pop())
            next_screen = self.get_screen(screen)
            self._screen_stack.append(next_screen)
            self.screen.post_message_no_wait(events.ScreenResume(self))
            self.log.system(f&#34;{self.screen} is current (SWITCHED)&#34;)

    def install_screen(self, screen: Screen, name: str | None = None) -&gt; str:
        &#34;&#34;&#34;Install a screen.

        Args:
            screen (Screen): Screen to install.
            name (str | None, optional): Unique name of screen or None to auto-generate.
                Defaults to None.

        Raises:
            ScreenError: If the screen can&#39;t be installed.

        Returns:
            str: The name of the screen
        &#34;&#34;&#34;
        if name is None:
            name = nanoid.generate()
        if name in self._installed_screens:
            raise ScreenError(f&#34;Can&#39;t install screen; {name!r} is already installed&#34;)
        if screen in self._installed_screens.values():
            raise ScreenError(
                &#34;Can&#39;t install screen; {screen!r} has already been installed&#34;
            )
        self._installed_screens[name] = screen
        self.get_screen(name)  # Ensures screen is running
        self.log.system(f&#34;{screen} INSTALLED name={name!r}&#34;)
        return name

    def uninstall_screen(self, screen: Screen | str) -&gt; str | None:
        &#34;&#34;&#34;Uninstall a screen. If the screen was not previously installed then this
        method is a null-op.

        Args:
            screen (Screen | str): The screen to uninstall or the name of a installed screen.

        Returns:
            str | None: The name of the screen that was uninstalled, or None if no screen was uninstalled.
        &#34;&#34;&#34;
        if isinstance(screen, str):
            if screen not in self._installed_screens:
                return None
            uninstall_screen = self._installed_screens[screen]
            if uninstall_screen in self._screen_stack:
                raise ScreenStackError(&#34;Can&#39;t uninstall screen in screen stack&#34;)
            del self._installed_screens[screen]
            self.log.system(f&#34;{uninstall_screen} UNINSTALLED name={screen!r}&#34;)
            return screen
        else:
            if screen in self._screen_stack:
                raise ScreenStackError(&#34;Can&#39;t uninstall screen in screen stack&#34;)
            for name, installed_screen in self._installed_screens.items():
                if installed_screen is screen:
                    self._installed_screens.pop(name)
                    self.log.system(f&#34;{screen} UNINSTALLED name={name!r}&#34;)
                    return name
        return None

    def pop_screen(self) -&gt; Screen:
        &#34;&#34;&#34;Pop the current screen from the stack, and switch to the previous screen.

        Returns:
            Screen: The screen that was replaced.
        &#34;&#34;&#34;
        screen_stack = self._screen_stack
        if len(screen_stack) &lt;= 1:
            raise ScreenStackError(
                &#34;Can&#39;t pop screen; there must be at least one screen on the stack&#34;
            )
        previous_screen = self._replace_screen(screen_stack.pop())
        self.screen._screen_resized(self.size)
        self.screen.post_message_no_wait(events.ScreenResume(self))
        self.log.system(f&#34;{self.screen} is active&#34;)
        return previous_screen

    def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -&gt; None:
        &#34;&#34;&#34;Focus (or unfocus) a widget. A focused widget will receive key events first.

        Args:
            widget (Widget): Widget to focus.
            scroll_visible (bool, optional): Scroll widget in to view.
        &#34;&#34;&#34;
        self.screen.set_focus(widget, scroll_visible)

    async def _set_mouse_over(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Called when the mouse is over another widget.

        Args:
            widget (Widget | None): Widget under mouse, or None for no widgets.
        &#34;&#34;&#34;
        if widget is None:
            if self.mouse_over is not None:
                try:
                    await self.mouse_over.post_message(events.Leave(self))
                finally:
                    self.mouse_over = None
        else:
            if self.mouse_over is not widget:
                try:
                    if self.mouse_over is not None:
                        await self.mouse_over._forward_event(events.Leave(self))
                    if widget is not None:
                        await widget._forward_event(events.Enter(self))
                finally:
                    self.mouse_over = widget

    def capture_mouse(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Send all mouse events to the given widget, disable mouse capture.

        Args:
            widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.
        &#34;&#34;&#34;
        if widget == self.mouse_captured:
            return
        if self.mouse_captured is not None:
            self.mouse_captured.post_message_no_wait(
                events.MouseRelease(self, self.mouse_position)
            )
        self.mouse_captured = widget
        if widget is not None:
            widget.post_message_no_wait(events.MouseCapture(self, self.mouse_position))

    def panic(self, *renderables: RenderableType) -&gt; None:
        &#34;&#34;&#34;Exits the app then displays a message.

        Args:
            *renderables (RenderableType, optional): Rich renderables to display on exit.
        &#34;&#34;&#34;

        assert all(
            is_renderable(renderable) for renderable in renderables
        ), &#34;Can only call panic with strings or Rich renderables&#34;

        def render(renderable: RenderableType) -&gt; list[Segment]:
            &#34;&#34;&#34;Render a panic renderables.&#34;&#34;&#34;
            segments = list(self.console.render(renderable, self.console.options))
            return segments

        pre_rendered = [Segments(render(renderable)) for renderable in renderables]
        self._exit_renderables.extend(pre_rendered)
        self._close_messages_no_wait()

    def _handle_exception(self, error: Exception) -&gt; None:
        &#34;&#34;&#34;Called with an unhandled exception.

        Args:
            error (Exception): An exception instance.
        &#34;&#34;&#34;

        if hasattr(error, &#34;__rich__&#34;):
            # Exception has a rich method, so we can defer to that for the rendering
            self.panic(error)
        else:
            # Use default exception rendering
            self.fatal_error()

    def fatal_error(self) -&gt; None:
        &#34;&#34;&#34;Exits the app after an unhandled exception.&#34;&#34;&#34;
        self.bell()
        traceback = Traceback(
            show_locals=True, width=None, locals_max_length=5, suppress=[rich]
        )
        self._exit_renderables.append(
            Segments(self.console.render(traceback, self.console.options))
        )
        self._close_messages_no_wait()

    def _print_error_renderables(self) -&gt; None:
        for renderable in self._exit_renderables:
            self.error_console.print(renderable)
        self._exit_renderables.clear()

    async def _process_messages(
        self, ready_callback: CallbackType | None = None
    ) -&gt; None:
        self._set_active()

        if self.devtools is not None:
            from .devtools.client import DevtoolsConnectionError

            try:
                await self.devtools.connect()
                self.log.system(f&#34;Connected to devtools ( {self.devtools.url} )&#34;)
            except DevtoolsConnectionError:
                self.log.system(f&#34;Couldn&#39;t connect to devtools ( {self.devtools.url} )&#34;)

        self.log.system(&#34;---&#34;)

        self.log.system(driver=self.driver_class)
        self.log.system(loop=asyncio.get_running_loop())
        self.log.system(features=self.features)

        try:
            if self.css_path is not None:
                self.stylesheet.read(self.css_path)
            for path, css, tie_breaker in self.get_default_css():
                self.stylesheet.add_source(
                    css, path=path, is_default_css=True, tie_breaker=tie_breaker
                )
            if self.CSS:
                try:
                    app_css_path = (
                        f&#34;{inspect.getfile(self.__class__)}:{self.__class__.__name__}&#34;
                    )
                except TypeError:
                    app_css_path = f&#34;{self.__class__.__name__}&#34;
                self.stylesheet.add_source(
                    self.CSS, path=app_css_path, is_default_css=False
                )
        except Exception as error:
            self._handle_exception(error)
            self._print_error_renderables()
            return

        if self.css_monitor:
            self.set_interval(0.25, self.css_monitor, name=&#34;css monitor&#34;)
            self.log.system(&#34;[b green]STARTED[/]&#34;, self.css_monitor)

        async def run_process_messages():

            try:
                await self._dispatch_message(events.Compose(sender=self))
                await self._dispatch_message(events.Mount(sender=self))
            finally:
                self._mounted_event.set()

            Reactive._initialize_object(self)

            self.stylesheet.update(self)
            self.refresh()

            await self.animator.start()
            await self._ready()
            if ready_callback is not None:
                await ready_callback()

            self._running = True

            try:
                await self._process_messages_loop()
            except asyncio.CancelledError:
                pass
            finally:
                self._running = False
                for timer in list(self._timers):
                    await timer.stop()

            await self.animator.stop()
            await self._close_all()

        self._running = True
        try:
            load_event = events.Load(sender=self)
            await self._dispatch_message(load_event)

            driver: Driver
            driver_class = cast(
                &#34;type[Driver]&#34;,
                HeadlessDriver if self.is_headless else self.driver_class,
            )
            driver = self._driver = driver_class(self.console, self)

            driver.start_application_mode()
            try:
                if self.is_headless:
                    await run_process_messages()
                else:
                    if self.devtools is not None:
                        devtools = self.devtools
                        assert devtools is not None
                        from .devtools.redirect_output import StdoutRedirector

                        redirector = StdoutRedirector(devtools)
                        with redirect_stderr(redirector):
                            with redirect_stdout(redirector):  # type: ignore
                                await run_process_messages()
                    else:
                        null_file = _NullFile()
                        with redirect_stderr(null_file):
                            with redirect_stdout(null_file):
                                await run_process_messages()

            finally:
                driver.stop_application_mode()
        except Exception as error:
            self._handle_exception(error)
        finally:
            self._running = False
            self._print_error_renderables()
            if self.devtools is not None and self.devtools.is_connected:
                await self._disconnect_devtools()

    async def _pre_process(self) -&gt; None:
        pass

    async def _ready(self) -&gt; None:
        &#34;&#34;&#34;Called immediately prior to processing messages.

        May be used as a hook for any operations that should run first.

        &#34;&#34;&#34;
        try:
            screenshot_timer = float(os.environ.get(&#34;TEXTUAL_SCREENSHOT&#34;, &#34;0&#34;))
        except ValueError:
            return

        screenshot_title = os.environ.get(&#34;TEXTUAL_SCREENSHOT_TITLE&#34;)

        if not screenshot_timer:
            return

        async def on_screenshot():
            &#34;&#34;&#34;Used by docs plugin.&#34;&#34;&#34;
            svg = self.export_screenshot(title=screenshot_title)
            self._screenshot = svg  # type: ignore
            await self.shutdown()

        self.set_timer(screenshot_timer, on_screenshot, name=&#34;screenshot timer&#34;)

    async def _on_compose(self) -&gt; None:
        widgets = list(self.compose())
        await self.mount_all(widgets)

    def _on_idle(self) -&gt; None:
        &#34;&#34;&#34;Perform actions when there are no messages in the queue.&#34;&#34;&#34;
        if self._require_stylesheet_update:
            nodes: set[DOMNode] = {
                child
                for node in self._require_stylesheet_update
                for child in node.walk_children()
            }
            self._require_stylesheet_update.clear()
            self.stylesheet.update_nodes(nodes, animate=True)

    def _register_child(self, parent: DOMNode, child: Widget) -&gt; bool:
        if child not in self._registry:
            parent.children._append(child)
            self._registry.add(child)
            child._attach(parent)
            child._post_register(self)
            child._start_messages()
            return True
        return False

    def _register(
        self, parent: DOMNode, *anon_widgets: Widget, **widgets: Widget
    ) -&gt; list[Widget]:
        &#34;&#34;&#34;Register widget(s) so they may receive events.

        Args:
            parent (Widget): Parent Widget.

        Returns:
            list[Widget]: List of modified widgets.

        &#34;&#34;&#34;
        if not anon_widgets and not widgets:
            return []
        name_widgets: list[tuple[str | None, Widget]]
        name_widgets = [*((None, widget) for widget in anon_widgets), *widgets.items()]
        apply_stylesheet = self.stylesheet.apply

        for widget_id, widget in name_widgets:
            if not isinstance(widget, Widget):
                raise AppError(f&#34;Can&#39;t register {widget!r}; expected a Widget instance&#34;)
            if widget not in self._registry:
                if widget_id is not None:
                    widget.id = widget_id
                self._register_child(parent, widget)
                if widget.children:
                    self._register(widget, *widget.children)
                apply_stylesheet(widget)

        registered_widgets = [widget for _, widget in name_widgets]
        return registered_widgets

    def _unregister(self, widget: Widget) -&gt; None:
        &#34;&#34;&#34;Unregister a widget.

        Args:
            widget (Widget): A Widget to unregister
        &#34;&#34;&#34;
        widget.reset_focus()
        if isinstance(widget._parent, Widget):
            widget._parent.children._remove(widget)
            widget._detach()
        self._registry.discard(widget)

    async def _disconnect_devtools(self):
        if self.devtools is not None:
            await self.devtools.disconnect()

    def _start_widget(self, parent: Widget, widget: Widget) -&gt; None:
        &#34;&#34;&#34;Start a widget (run it&#39;s task) so that it can receive messages.

        Args:
            parent (Widget): The parent of the Widget.
            widget (Widget): The Widget to start.
        &#34;&#34;&#34;
        widget._attach(parent)
        widget._start_messages()

    def is_mounted(self, widget: Widget) -&gt; bool:
        &#34;&#34;&#34;Check if a widget is mounted.

        Args:
            widget (Widget): A widget.

        Returns:
            bool: True of the widget is mounted.
        &#34;&#34;&#34;
        return widget in self._registry

    async def _close_all(self) -&gt; None:
        while self._registry:
            child = self._registry.pop()
            await child._close_messages()

    async def shutdown(self):
        await self._disconnect_devtools()
        driver = self._driver
        if driver is not None:
            driver.disable_input()
        await self._close_messages()

    def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
        if self._screen_stack:
            self.screen.refresh(repaint=repaint, layout=layout)
        self.check_idle()

    def refresh_css(self, animate: bool = True) -&gt; None:
        &#34;&#34;&#34;Refresh CSS.

        Args:
            animate (bool, optional): Also execute CSS animations. Defaults to True.
        &#34;&#34;&#34;
        stylesheet = self.app.stylesheet
        stylesheet.set_variables(self.get_css_variables())
        stylesheet.reparse()
        stylesheet.update(self.app, animate=animate)
        self.screen._refresh_layout(self.size, full=True)

    def _display(self, screen: Screen, renderable: RenderableType | None) -&gt; None:
        &#34;&#34;&#34;Display a renderable within a sync.

        Args:
            screen (Screen): Screen instance
            renderable (RenderableType): A Rich renderable.
        &#34;&#34;&#34;
        if screen is not self.screen or renderable is None:
            return
        if self._running and not self._closed and not self.is_headless:
            console = self.console
            self._begin_update()
            try:
                try:
                    console.print(renderable)
                except Exception as error:
                    self._handle_exception(error)
            finally:
                self._end_update()
            console.file.flush()

    def get_widget_at(self, x: int, y: int) -&gt; tuple[Widget, Region]:
        &#34;&#34;&#34;Get the widget under the given coordinates.

        Args:
            x (int): X Coord.
            y (int): Y Coord.

        Returns:
            tuple[Widget, Region]: The widget and the widget&#39;s screen region.
        &#34;&#34;&#34;
        return self.screen.get_widget_at(x, y)

    def bell(self) -&gt; None:
        &#34;&#34;&#34;Play the console &#39;bell&#39;.&#34;&#34;&#34;
        if not self.is_headless:
            self.console.bell()

    @property
    def _binding_chain(self) -&gt; list[tuple[DOMNode, Bindings]]:
        &#34;&#34;&#34;Get a chain of nodes and bindings to consider. If no widget is focused, returns the bindings from both the screen and the app level bindings. Otherwise, combines all the bindings from the currently focused node up the DOM to the root App.

        Returns:
            list[tuple[DOMNode, Bindings]]: List of DOM nodes and their bindings.
        &#34;&#34;&#34;
        focused = self.focused
        namespace_bindings: list[tuple[DOMNode, Bindings]]
        if focused is None:
            namespace_bindings = [
                (self.screen, self.screen._bindings),
                (self, self._bindings),
            ]
        else:
            namespace_bindings = [(node, node._bindings) for node in focused.ancestors]
        return namespace_bindings

    async def check_bindings(self, key: str, universal: bool = False) -&gt; bool:
        &#34;&#34;&#34;Handle a key press.

        Args:
            key (str): A key
            universal (bool): Check universal keys if True, otherwise non-universal keys.

        Returns:
            bool: True if the key was handled by a binding, otherwise False
        &#34;&#34;&#34;

        for namespace, bindings in self._binding_chain:
            binding = bindings.keys.get(key)
            if binding is not None and binding.universal == universal:
                await self.action(binding.action, default_namespace=namespace)
                return True
        return False

    async def on_event(self, event: events.Event) -&gt; None:
        # Handle input events that haven&#39;t been forwarded
        # If the event has been forwarded it may have bubbled up back to the App
        if isinstance(event, events.Compose):
            screen = Screen(id=&#34;_default&#34;)
            self._register(self, screen)
            self._screen_stack.append(screen)
            await super().on_event(event)

        elif isinstance(event, events.InputEvent) and not event.is_forwarded:
            if isinstance(event, events.MouseEvent):
                # Record current mouse position on App
                self.mouse_position = Offset(event.x, event.y)
                await self.screen._forward_event(event)
            elif isinstance(event, events.Key):
                if not await self.check_bindings(event.key, universal=True):
                    forward_target = self.focused or self.screen
                    await forward_target._forward_event(event)
            else:
                await self.screen._forward_event(event)

        elif isinstance(event, events.Paste):
            if self.focused is not None:
                await self.focused._forward_event(event)
        else:
            await super().on_event(event)

    async def action(
        self,
        action: str | tuple[str, tuple[str, ...]],
        default_namespace: object | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Perform an action.

        Args:
            action (str): Action encoded in a string.
            default_namespace (object | None): Namespace to use if not provided in the action,
                or None to use app. Defaults to None.

        Returns:
            bool: True if the event has handled.
        &#34;&#34;&#34;
        print(&#34;ACTION&#34;, action, default_namespace)
        if isinstance(action, str):
            target, params = actions.parse(action)
        else:
            target, params = action
        implicit_destination = True
        if &#34;.&#34; in target:
            destination, action_name = target.split(&#34;.&#34;, 1)
            if destination not in self._action_targets:
                raise ActionError(f&#34;Action namespace {destination} is not known&#34;)
            action_target = getattr(self, destination)
            implicit_destination = True
        else:
            action_target = default_namespace or self
            action_name = target

        handled = await self._dispatch_action(action_target, action_name, params)
        if not handled and implicit_destination and not isinstance(action_target, App):
            handled = await self.app._dispatch_action(self.app, action_name, params)
        return handled

    async def _dispatch_action(
        self, namespace: object, action_name: str, params: Any
    ) -&gt; bool:
        log(
            &#34;&lt;action&gt;&#34;,
            namespace=namespace,
            action_name=action_name,
            params=params,
        )
        _rich_traceback_guard = True

        public_method_name = f&#34;action_{action_name}&#34;
        private_method_name = f&#34;_{public_method_name}&#34;

        private_method = getattr(namespace, private_method_name, None)
        public_method = getattr(namespace, public_method_name, None)

        if private_method is None and public_method is None:
            log(
                f&#34;&lt;action&gt; {action_name!r} has no target. Couldn&#39;t find methods {public_method_name!r} or {private_method_name!r}&#34;
            )

        if callable(private_method):
            await invoke(private_method, *params)
            return True
        elif callable(public_method):
            await invoke(public_method, *params)
            return True

        return False

    async def _broker_event(
        self, event_name: str, event: events.Event, default_namespace: object | None
    ) -&gt; bool:
        &#34;&#34;&#34;Allow the app an opportunity to dispatch events to action system.

        Args:
            event_name (str): _description_
            event (events.Event): An event object.
            default_namespace (object | None): TODO: _description_

        Returns:
            bool: True if an action was processed.
        &#34;&#34;&#34;
        try:
            style = getattr(event, &#34;style&#34;)
        except AttributeError:
            return False
        try:
            _modifiers, action = extract_handler_actions(event_name, style.meta)
        except NoHandler:
            return False
        else:
            event.stop()
        if isinstance(action, (str, tuple)):
            await self.action(action, default_namespace=default_namespace)
        elif callable(action):
            await action()
        else:
            return False
        return True

    async def _on_update(self, message: messages.Update) -&gt; None:
        message.stop()

    async def _on_layout(self, message: messages.Layout) -&gt; None:
        message.stop()

    async def _on_key(self, event: events.Key) -&gt; None:
        if event.key == &#34;tab&#34;:
            self.screen.focus_next()
        elif event.key == &#34;shift+tab&#34;:
            self.screen.focus_previous()
        else:
            if not (await self.check_bindings(event.key)):
                await self.dispatch_key(event)

    async def _on_shutdown_request(self, event: events.ShutdownRequest) -&gt; None:
        log(&#34;shutdown request&#34;)
        await self._close_messages()

    async def _on_resize(self, event: events.Resize) -&gt; None:
        event.stop()
        await self.screen.post_message(event)

    async def _on_remove(self, event: events.Remove) -&gt; None:
        widget = event.widget
        parent = widget.parent

        remove_widgets = widget.walk_children(
            Widget, with_self=True, method=&#34;depth&#34;, reverse=True
        )

        if self.screen.focused in remove_widgets:
            self.screen._reset_focus(
                self.screen.focused,
                [to_remove for to_remove in remove_widgets if to_remove.can_focus],
            )

        for child in remove_widgets:
            await child._close_messages()
            self._unregister(child)
        if parent is not None:
            parent.refresh(layout=True)

    async def action_check_bindings(self, key: str) -&gt; None:
        await self.check_bindings(key)

    async def action_quit(self) -&gt; None:
        &#34;&#34;&#34;Quit the app as soon as possible.&#34;&#34;&#34;
        await self.shutdown()

    async def action_bang(self) -&gt; None:
        1 / 0

    async def action_bell(self) -&gt; None:
        &#34;&#34;&#34;Play the terminal &#39;bell&#39;.&#34;&#34;&#34;
        self.bell()

    async def action_focus(self, widget_id: str) -&gt; None:
        &#34;&#34;&#34;Focus the given widget.

        Args:
            widget_id (str): ID of widget to focus.
        &#34;&#34;&#34;
        try:
            node = self.query(f&#34;#{widget_id}&#34;).first()
        except NoMatches:
            pass
        else:
            if isinstance(node, Widget):
                self.set_focus(node)

    async def action_switch_screen(self, screen: str) -&gt; None:
        &#34;&#34;&#34;Switches to another screen.

        Args:
            screen (str): Name of the screen.
        &#34;&#34;&#34;
        self.switch_screen(screen)

    async def action_push_screen(self, screen: str) -&gt; None:
        &#34;&#34;&#34;Pushes a screen on to the screen stack and makes it active.

        Args:
            screen (str): Name of the screen.
        &#34;&#34;&#34;
        self.push_screen(screen)

    async def action_pop_screen(self) -&gt; None:
        &#34;&#34;&#34;Removes the topmost screen and makes the new topmost screen active.&#34;&#34;&#34;
        self.pop_screen()

    async def action_back(self) -&gt; None:
        try:
            self.pop_screen()
        except ScreenStackError:
            pass

    async def action_add_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).add_class(class_name)

    async def action_remove_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).remove_class(class_name)

    async def action_toggle_class(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).toggle_class(class_name)

    def _on_terminal_supports_synchronized_output(
        self, message: messages.TerminalSupportsSynchronizedOutput
    ) -&gt; None:
        log.system(&#34;[b green]SynchronizedOutput mode is supported&#34;)
        self._sync_available = True

    def _begin_update(self) -&gt; None:
        if self._sync_available:
            self.console.file.write(SYNC_START)

    def _end_update(self) -&gt; None:
        if self._sync_available:
            self.console.file.write(SYNC_END)


_uvloop_init_done: bool = False


def _init_uvloop() -&gt; None:
    &#34;&#34;&#34;
    Import and install the `uvloop` asyncio policy, if available.
    This is done only once, even if the function is called multiple times.
    &#34;&#34;&#34;
    global _uvloop_init_done

    if _uvloop_init_done:
        return

    try:
        import uvloop
    except ImportError:
        pass
    else:
        uvloop.install()

    _uvloop_init_done = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.app.ActionError"><code class="flex name class">
<span>class <span class="ident">ActionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActionError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textual.app.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
<span>(</span><span>driver_class:Type[Driver]|None=None, css_path:CSSPathType=None, watch_css:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for Textual Applications.</p>
<h2 id="args">Args</h2>
<dl>
<dt>driver_class (Type[Driver] | None, optional): Driver class or <code>None</code> to auto-detect. Defaults to None.</dt>
<dt>title (str | None, optional): Title of the application. If <code>None</code>, the title is set to the name of the <code><a title="textual.app.App" href="#textual.app.App">App</a></code> subclass. Defaults to <code>None</code>.</dt>
<dt>css_path (str | PurePath | None, optional): Path to CSS or <code>None</code> for no CSS file. Defaults to None.</dt>
<dt><strong><code>watch_css</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Watch CSS for changes. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class App(Generic[ReturnType], DOMNode):
    &#34;&#34;&#34;The base class for Textual Applications.

    Args:
        driver_class (Type[Driver] | None, optional): Driver class or ``None`` to auto-detect. Defaults to None.
        title (str | None, optional): Title of the application. If ``None``, the title is set to the name of the ``App`` subclass. Defaults to ``None``.
        css_path (str | PurePath | None, optional): Path to CSS or ``None`` for no CSS file. Defaults to None.
        watch_css (bool, optional): Watch CSS for changes. Defaults to False.
    &#34;&#34;&#34;

    # Inline CSS for quick scripts (generally css_path should be preferred.)
    CSS = &#34;&#34;

    # Default (lowest priority) CSS
    DEFAULT_CSS = &#34;&#34;&#34;
    App {
        background: $background;
        color: $text;
    }
    &#34;&#34;&#34;

    SCREENS: dict[str, Screen] = {}
    _BASE_PATH: str | None = None
    CSS_PATH: CSSPathType = None
    TITLE: str | None = None
    SUB_TITLE: str | None = None

    title: Reactive[str] = Reactive(&#34;&#34;)
    sub_title: Reactive[str] = Reactive(&#34;&#34;)
    dark: Reactive[bool] = Reactive(True)

    def __init__(
        self,
        driver_class: Type[Driver] | None = None,
        css_path: CSSPathType = None,
        watch_css: bool = False,
    ):
        # N.B. This must be done *before* we call the parent constructor, because MessagePump&#39;s
        # constructor instantiates a `asyncio.PriorityQueue` and in Python versions older than 3.10
        # this will create some first references to an asyncio loop.
        _init_uvloop()

        super().__init__()
        self.features: frozenset[FeatureFlag] = parse_features(os.getenv(&#34;TEXTUAL&#34;, &#34;&#34;))

        self._filter: LineFilter | None = None
        environ = dict(os.environ)
        no_color = environ.pop(&#34;NO_COLOR&#34;, None)
        if no_color is not None:
            self._filter = Monochrome()
        self.console = Console(
            file=(_NullFile() if self.is_headless else sys.__stdout__),
            markup=False,
            highlight=False,
            emoji=False,
            legacy_windows=False,
            _environ=environ,
        )
        self.error_console = Console(markup=False, stderr=True)
        self.driver_class = driver_class or self.get_driver_class()
        self._screen_stack: list[Screen] = []
        self._sync_available = False

        self.mouse_over: Widget | None = None
        self.mouse_captured: Widget | None = None
        self._driver: Driver | None = None
        self._exit_renderables: list[RenderableType] = []

        self._action_targets = {&#34;app&#34;, &#34;screen&#34;}
        self._animator = Animator(self)
        self._animate = self._animator.bind(self)
        self.mouse_position = Offset(0, 0)
        self.title = (
            self.TITLE if self.TITLE is not None else f&#34;{self.__class__.__name__}&#34;
        )
        self.sub_title = self.SUB_TITLE if self.SUB_TITLE is not None else &#34;&#34;

        self._logger = Logger(self._log)

        self._bindings.bind(&#34;ctrl+c&#34;, &#34;quit&#34;, show=False, universal=True)
        self._refresh_required = False

        self.design = DEFAULT_COLORS

        self.stylesheet = Stylesheet(variables=self.get_css_variables())
        self._require_stylesheet_update: set[DOMNode] = set()

        # We want the CSS path to be resolved from the location of the App subclass
        css_path = css_path or self.CSS_PATH
        if css_path is not None:
            if isinstance(css_path, str):
                css_path = Path(css_path)
            css_path = _make_path_object_relative(css_path, self) if css_path else None

        self.css_path = css_path

        self._registry: WeakSet[DOMNode] = WeakSet()

        self._installed_screens: WeakValueDictionary[
            str, Screen
        ] = WeakValueDictionary()
        self._installed_screens.update(**self.SCREENS)

        self.devtools: DevtoolsClient | None = None
        if &#34;devtools&#34; in self.features:
            try:
                from .devtools.client import DevtoolsClient
            except ImportError:
                # Dev dependencies not installed
                pass
            else:
                self.devtools = DevtoolsClient()

        self._return_value: ReturnType | None = None

        self.css_monitor = (
            FileMonitor(self.css_path, self._on_css_change)
            if ((watch_css or self.debug) and self.css_path)
            else None
        )
        self._screenshot: str | None = None

    def animate(
        self,
        attribute: str,
        value: float | Animatable,
        *,
        final_value: object = ...,
        duration: float | None = None,
        speed: float | None = None,
        delay: float = 0.0,
        easing: EasingFunction | str = DEFAULT_EASING,
        on_complete: CallbackType | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Animate an attribute.

        Args:
            attribute (str): Name of the attribute to animate.
            value (float | Animatable): The value to animate to.
            final_value (object, optional): The final value of the animation. Defaults to `value` if not set.
            duration (float | None, optional): The duration of the animate. Defaults to None.
            speed (float | None, optional): The speed of the animation. Defaults to None.
            delay (float, optional): A delay (in seconds) before the animation starts. Defaults to 0.0.
            easing (EasingFunction | str, optional): An easing method. Defaults to &#34;in_out_cubic&#34;.
            on_complete (CallbackType | None, optional): A callable to invoke when the animation is finished. Defaults to None.

        &#34;&#34;&#34;
        self._animate(
            attribute,
            value,
            final_value=final_value,
            duration=duration,
            speed=speed,
            delay=delay,
            easing=easing,
            on_complete=on_complete,
        )

    @property
    def debug(self) -&gt; bool:
        &#34;&#34;&#34;Check if debug mode is enabled.

        Returns:
            bool: True if debug mode is enabled.

        &#34;&#34;&#34;
        return &#34;debug&#34; in self.features

    @property
    def is_headless(self) -&gt; bool:
        &#34;&#34;&#34;Check if the app is running in &#39;headless&#39; mode.

        Returns:
            bool: True if the app is in headless mode.

        &#34;&#34;&#34;
        return &#34;headless&#34; in self.features

    @property
    def screen_stack(self) -&gt; list[Screen]:
        &#34;&#34;&#34;Get a *copy* of the screen stack.

        Returns:
            list[Screen]: List of screens.

        &#34;&#34;&#34;
        return self._screen_stack.copy()

    def exit(self, result: ReturnType | None = None) -&gt; None:
        &#34;&#34;&#34;Exit the app, and return the supplied result.

        Args:
            result (ReturnType | None, optional): Return value. Defaults to None.
        &#34;&#34;&#34;
        self._return_value = result
        self._close_messages_no_wait()

    @property
    def focused(self) -&gt; Widget | None:
        &#34;&#34;&#34;Get the widget that is focused on the currently active screen.&#34;&#34;&#34;
        return self.screen.focused

    @property
    def namespace_bindings(self) -&gt; dict[str, tuple[DOMNode, Binding]]:
        &#34;&#34;&#34;Get current bindings. If no widget is focused, then the app-level bindings
        are returned. If a widget is focused, then any bindings present in the active
        screen and app are merged and returned.&#34;&#34;&#34;

        namespace_binding_map: dict[str, tuple[DOMNode, Binding]] = {}
        for namespace, bindings in reversed(self._binding_chain):
            for key, binding in bindings.keys.items():
                namespace_binding_map[key] = (namespace, binding)

        return namespace_binding_map

    def _set_active(self) -&gt; None:
        &#34;&#34;&#34;Set this app to be the currently active app.&#34;&#34;&#34;
        active_app.set(self)

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def get_css_variables(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Get a mapping of variables used to pre-populate CSS.

        Returns:
            dict[str, str]: A mapping of variable name to value.
        &#34;&#34;&#34;
        variables = self.design[&#34;dark&#34; if self.dark else &#34;light&#34;].generate()
        return variables

    def watch_dark(self, dark: bool) -&gt; None:
        &#34;&#34;&#34;Watches the dark bool.&#34;&#34;&#34;
        self.set_class(dark, &#34;-dark-mode&#34;)
        self.set_class(not dark, &#34;-light-mode&#34;)
        self.refresh_css()

    def get_driver_class(self) -&gt; Type[Driver]:
        &#34;&#34;&#34;Get a driver class for this platform.

        Called by the constructor.

        Returns:
            Driver: A Driver class which manages input and display.
        &#34;&#34;&#34;
        driver_class: Type[Driver]
        if WINDOWS:
            from .drivers.windows_driver import WindowsDriver

            driver_class = WindowsDriver
        else:
            from .drivers.linux_driver import LinuxDriver

            driver_class = LinuxDriver
        return driver_class

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;title&#34;, self.title
        yield &#34;id&#34;, self.id, None
        if self.name:
            yield &#34;name&#34;, self.name
        if self.classes:
            yield &#34;classes&#34;, set(self.classes)
        pseudo_classes = self.pseudo_classes
        if pseudo_classes:
            yield &#34;pseudo_classes&#34;, set(pseudo_classes)

    @property
    def is_transparent(self) -&gt; bool:
        return True

    @property
    def animator(self) -&gt; Animator:
        return self._animator

    @property
    def screen(self) -&gt; Screen:
        &#34;&#34;&#34;Get the current screen.

        Raises:
            ScreenStackError: If there are no screens on the stack.

        Returns:
            Screen: The currently active screen.
        &#34;&#34;&#34;
        try:
            return self._screen_stack[-1]
        except IndexError:
            raise ScreenStackError(&#34;No screens on stack&#34;) from None

    @property
    def size(self) -&gt; Size:
        &#34;&#34;&#34;Get the size of the terminal.

        Returns:
            Size: Size of the terminal
        &#34;&#34;&#34;
        return Size(*self.console.size)

    @property
    def log(self) -&gt; Logger:
        return self._logger

    def _log(
        self,
        group: LogGroup,
        verbosity: LogVerbosity,
        _textual_calling_frame: inspect.FrameInfo,
        *objects: Any,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;Write to logs or devtools.

        Positional args will logged. Keyword args will be prefixed with the key.

        Example:
            ```python
            data = [1,2,3]
            self.log(&#34;Hello, World&#34;, state=data)
            self.log(self.tree)
            self.log(locals())
            ```

        Args:
            verbosity (int, optional): Verbosity level 0-3. Defaults to 1.
        &#34;&#34;&#34;

        devtools = self.devtools
        if devtools is None or not devtools.is_connected:
            return

        if verbosity.value &gt; LogVerbosity.NORMAL.value and not devtools.verbose:
            return

        try:
            from .devtools.client import DevtoolsLog

            if len(objects) == 1 and not kwargs:
                devtools.log(
                    DevtoolsLog(objects, caller=_textual_calling_frame),
                    group,
                    verbosity,
                )
            else:
                output = &#34; &#34;.join(str(arg) for arg in objects)
                if kwargs:
                    key_values = &#34; &#34;.join(
                        f&#34;{key}={value!r}&#34; for key, value in kwargs.items()
                    )
                    output = f&#34;{output} {key_values}&#34; if output else key_values
                devtools.log(
                    DevtoolsLog(output, caller=_textual_calling_frame),
                    group,
                    verbosity,
                )
        except Exception as error:
            self._handle_exception(error)

    def action_toggle_dark(self) -&gt; None:
        &#34;&#34;&#34;Action to toggle dark mode.&#34;&#34;&#34;
        self.dark = not self.dark

    def action_screenshot(self, filename: str | None = None, path: str = &#34;./&#34;) -&gt; None:
        &#34;&#34;&#34;Save an SVG &#34;screenshot&#34;. This action will save an SVG file containing the current contents of the screen.

        Args:
            filename (str | None, optional): Filename of screenshot, or None to auto-generate. Defaults to None.
            path (str, optional): Path to directory. Defaults to &#34;~/&#34;.
        &#34;&#34;&#34;
        self.save_screenshot(filename, path)

    def export_screenshot(self, *, title: str | None = None) -&gt; str:
        &#34;&#34;&#34;Export an SVG screenshot of the current screen.

        Args:
            title (str | None, optional): The title of the exported screenshot or None
                to use app title. Defaults to None.

        &#34;&#34;&#34;

        console = Console(
            width=self.console.width,
            height=self.console.height,
            file=io.StringIO(),
            force_terminal=True,
            color_system=&#34;truecolor&#34;,
            record=True,
            legacy_windows=False,
        )
        screen_render = self.screen._compositor.render(full=True)
        console.print(screen_render)
        return console.export_svg(title=title or self.title)

    def save_screenshot(
        self,
        filename: str | None = None,
        path: str = &#34;./&#34;,
        time_format: str = &#34;%Y-%m-%d %X %f&#34;,
    ) -&gt; str:
        &#34;&#34;&#34;Save an SVG screenshot of the current screen.

        Args:
            filename (str | None, optional): Filename of SVG screenshot, or None to auto-generate
                a filename with the date and time. Defaults to None.
            path (str, optional): Path to directory for output. Defaults to current working directory.
            time_format (str, optional): Time format to use if filename is None. Defaults to &#34;%Y-%m-%d %X %f&#34;.

        Returns:
            str: Filename of screenshot.
        &#34;&#34;&#34;
        if filename is None:
            svg_filename = (
                f&#34;{self.title.lower()} {datetime.now().strftime(time_format)}.svg&#34;
            )
            svg_filename = svg_filename.replace(&#34;/&#34;, &#34;_&#34;).replace(&#34;\\&#34;, &#34;_&#34;)
        else:
            svg_filename = filename
        svg_path = os.path.expanduser(os.path.join(path, svg_filename))
        screenshot_svg = self.export_screenshot()
        with open(svg_path, &#34;w&#34;) as svg_file:
            svg_file.write(screenshot_svg)
        return svg_path

    def bind(
        self,
        keys: str,
        action: str,
        *,
        description: str = &#34;&#34;,
        show: bool = True,
        key_display: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Bind a key to an action.

        Args:
            keys (str): A comma separated list of keys, i.e.
            action (str): Action to bind to.
            description (str, optional): Short description of action. Defaults to &#34;&#34;.
            show (bool, optional): Show key in UI. Defaults to True.
            key_display (str, optional): Replacement text for key, or None to use default. Defaults to None.
        &#34;&#34;&#34;
        self._bindings.bind(
            keys, action, description, show=show, key_display=key_display
        )

    def run(
        self,
        *,
        quit_after: float | None = None,
        headless: bool = False,
        press: Iterable[str] | None = None,
        screenshot: bool = False,
        screenshot_title: str | None = None,
    ) -&gt; ReturnType | None:
        &#34;&#34;&#34;The main entry point for apps.

        Args:
            quit_after (float | None, optional): Quit after a given number of seconds, or None
                to run forever. Defaults to None.
            headless (bool, optional): Run in &#34;headless&#34; mode (don&#39;t write to stdout).
            press (str, optional): An iterable of keys to simulate being pressed.
            screenshot (bool, optional): Take a screenshot after pressing keys (svg data stored in self._screenshot). Defaults to False.
            screenshot_title (str | None, optional): Title of screenshot, or None to use App title. Defaults to None.

        Returns:
            ReturnType | None: The return value specified in `App.exit` or None if exit wasn&#39;t called.
        &#34;&#34;&#34;

        if headless:
            self.features = cast(
                &#34;frozenset[FeatureFlag]&#34;, self.features.union({&#34;headless&#34;})
            )

        async def run_app() -&gt; None:
            if quit_after is not None:
                self.set_timer(quit_after, self.shutdown)
            if press is not None:
                app = self

                async def press_keys() -&gt; None:
                    &#34;&#34;&#34;A task to send key events.&#34;&#34;&#34;
                    assert press
                    driver = app._driver
                    assert driver is not None
                    await asyncio.sleep(0.01)
                    for key in press:
                        if key == &#34;_&#34;:
                            print(&#34;(pause 50ms)&#34;)
                            await asyncio.sleep(0.05)
                        elif key.startswith(&#34;wait:&#34;):
                            _, wait_ms = key.split(&#34;:&#34;)
                            print(f&#34;(pause {wait_ms}ms)&#34;)
                            await asyncio.sleep(float(wait_ms) / 1000)
                        else:
                            if len(key) == 1 and not key.isalnum():
                                key = (
                                    unicodedata.name(key)
                                    .lower()
                                    .replace(&#34;-&#34;, &#34;_&#34;)
                                    .replace(&#34; &#34;, &#34;_&#34;)
                                )
                            original_key = REPLACED_KEYS.get(key, key)
                            try:
                                char = unicodedata.lookup(
                                    original_key.upper().replace(&#34;_&#34;, &#34; &#34;)
                                )
                            except KeyError:
                                char = key if len(key) == 1 else None
                            print(f&#34;press {key!r} (char={char!r})&#34;)
                            key_event = events.Key(self, key, char)
                            driver.send_event(key_event)
                            await asyncio.sleep(0.01)

                    await app._animator.wait_for_idle()

                    if screenshot:
                        self._screenshot = self.export_screenshot(
                            title=screenshot_title
                        )
                    await self.shutdown()

                async def press_keys_task():
                    &#34;&#34;&#34;Press some keys in the background.&#34;&#34;&#34;
                    asyncio.create_task(press_keys())

                await self._process_messages(ready_callback=press_keys_task)
            else:
                await self._process_messages()

        if _ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED:
            # N.B. This doesn&#39;t work with Python&lt;3.10, as we end up with 2 event loops:
            asyncio.run(run_app())
        else:
            # However, this works with Python&lt;3.10:
            event_loop = asyncio.get_event_loop()
            event_loop.run_until_complete(run_app())

        return self._return_value

    async def _on_css_change(self) -&gt; None:
        &#34;&#34;&#34;Called when the CSS changes (if watch_css is True).&#34;&#34;&#34;
        if self.css_path is not None:
            try:
                time = perf_counter()
                stylesheet = self.stylesheet.copy()
                stylesheet.read(self.css_path)
                stylesheet.parse()
                elapsed = (perf_counter() - time) * 1000
                self.log.system(
                    f&#34;&lt;stylesheet&gt; loaded {self.css_path!r} in {elapsed:.0f} ms&#34;
                )
            except Exception as error:
                # TODO: Catch specific exceptions
                self.log.error(error)
                self.bell()
            else:
                self.stylesheet = stylesheet
                self.reset_styles()
                self.stylesheet.update(self)
                self.screen.refresh(layout=True)

    def render(self) -&gt; RenderableType:
        return Blank(self.styles.background)

    def get_child(self, id: str) -&gt; DOMNode:
        &#34;&#34;&#34;Shorthand for self.screen.get_child(id: str)
        Returns the first child (immediate descendent) of this DOMNode
        with the given ID.

        Args:
            id (str): The ID of the node to search for.

        Returns:
            DOMNode: The first child of this node with the specified ID.

        Raises:
            NoMatches: if no children could be found for this ID
        &#34;&#34;&#34;
        return self.screen.get_child(id)

    def update_styles(self, node: DOMNode | None = None) -&gt; None:
        &#34;&#34;&#34;Request update of styles.

        Should be called whenever CSS classes / pseudo classes change.

        &#34;&#34;&#34;
        self._require_stylesheet_update.add(self.screen if node is None else node)
        self.check_idle()

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; AwaitMount:
        &#34;&#34;&#34;Mount widgets. Widgets specified as positional args, or keywords args. If supplied
        as keyword args they will be assigned an id of the key.

        Returns:
            AwaitMount: An awaitable object that waits for widgets to be mounted.

        &#34;&#34;&#34;
        mounted_widgets = self._register(self.screen, *anon_widgets, **widgets)
        return AwaitMount(mounted_widgets)

    def mount_all(self, widgets: Iterable[Widget]) -&gt; AwaitMount:
        &#34;&#34;&#34;Mount widgets from an iterable.

        Args:
            widgets (Iterable[Widget]): An iterable of widgets.
        &#34;&#34;&#34;
        mounted_widgets = list(widgets)
        for widget in mounted_widgets:
            self._register(self.screen, widget)
        return AwaitMount(mounted_widgets)

    def is_screen_installed(self, screen: Screen | str) -&gt; bool:
        &#34;&#34;&#34;Check if a given screen has been installed.

        Args:
            screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

        Returns:
            bool: True if the screen is currently installed,
        &#34;&#34;&#34;
        if isinstance(screen, str):
            return screen in self._installed_screens
        else:
            return screen in self._installed_screens.values()

    def get_screen(self, screen: Screen | str) -&gt; Screen:
        &#34;&#34;&#34;Get an installed screen.

        If the screen isn&#39;t running, it will be registered before it is run.

        Args:
            screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

        Raises:
            KeyError: If the named screen doesn&#39;t exist.

        Returns:
            Screen: A screen instance.
        &#34;&#34;&#34;
        if isinstance(screen, str):
            try:
                next_screen = self._installed_screens[screen]
            except KeyError:
                raise KeyError(f&#34;No screen called {screen!r} installed&#34;) from None
        else:
            next_screen = screen
        if not next_screen.is_running:
            self._register(self, next_screen)
        return next_screen

    def _replace_screen(self, screen: Screen) -&gt; Screen:
        &#34;&#34;&#34;Handle the replaced screen.

        Args:
            screen (Screen): A screen object.

        Returns:
            Screen: The screen that was replaced.

        &#34;&#34;&#34;
        screen.post_message_no_wait(events.ScreenSuspend(self))
        self.log.system(f&#34;{screen} SUSPENDED&#34;)
        if not self.is_screen_installed(screen) and screen not in self._screen_stack:
            screen.remove()
            self.log.system(f&#34;{screen} REMOVED&#34;)
        return screen

    def push_screen(self, screen: Screen | str) -&gt; None:
        &#34;&#34;&#34;Push a new screen on the screen stack.

        Args:
            screen (Screen | str): A Screen instance or the name of an installed screen.

        &#34;&#34;&#34;
        next_screen = self.get_screen(screen)
        self._screen_stack.append(next_screen)
        self.screen.post_message_no_wait(events.ScreenResume(self))
        self.log.system(f&#34;{self.screen} is current (PUSHED)&#34;)

    def switch_screen(self, screen: Screen | str) -&gt; None:
        &#34;&#34;&#34;Switch to another screen by replacing the top of the screen stack with a new screen.

        Args:
            screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

        &#34;&#34;&#34;
        if self.screen is not screen:
            self._replace_screen(self._screen_stack.pop())
            next_screen = self.get_screen(screen)
            self._screen_stack.append(next_screen)
            self.screen.post_message_no_wait(events.ScreenResume(self))
            self.log.system(f&#34;{self.screen} is current (SWITCHED)&#34;)

    def install_screen(self, screen: Screen, name: str | None = None) -&gt; str:
        &#34;&#34;&#34;Install a screen.

        Args:
            screen (Screen): Screen to install.
            name (str | None, optional): Unique name of screen or None to auto-generate.
                Defaults to None.

        Raises:
            ScreenError: If the screen can&#39;t be installed.

        Returns:
            str: The name of the screen
        &#34;&#34;&#34;
        if name is None:
            name = nanoid.generate()
        if name in self._installed_screens:
            raise ScreenError(f&#34;Can&#39;t install screen; {name!r} is already installed&#34;)
        if screen in self._installed_screens.values():
            raise ScreenError(
                &#34;Can&#39;t install screen; {screen!r} has already been installed&#34;
            )
        self._installed_screens[name] = screen
        self.get_screen(name)  # Ensures screen is running
        self.log.system(f&#34;{screen} INSTALLED name={name!r}&#34;)
        return name

    def uninstall_screen(self, screen: Screen | str) -&gt; str | None:
        &#34;&#34;&#34;Uninstall a screen. If the screen was not previously installed then this
        method is a null-op.

        Args:
            screen (Screen | str): The screen to uninstall or the name of a installed screen.

        Returns:
            str | None: The name of the screen that was uninstalled, or None if no screen was uninstalled.
        &#34;&#34;&#34;
        if isinstance(screen, str):
            if screen not in self._installed_screens:
                return None
            uninstall_screen = self._installed_screens[screen]
            if uninstall_screen in self._screen_stack:
                raise ScreenStackError(&#34;Can&#39;t uninstall screen in screen stack&#34;)
            del self._installed_screens[screen]
            self.log.system(f&#34;{uninstall_screen} UNINSTALLED name={screen!r}&#34;)
            return screen
        else:
            if screen in self._screen_stack:
                raise ScreenStackError(&#34;Can&#39;t uninstall screen in screen stack&#34;)
            for name, installed_screen in self._installed_screens.items():
                if installed_screen is screen:
                    self._installed_screens.pop(name)
                    self.log.system(f&#34;{screen} UNINSTALLED name={name!r}&#34;)
                    return name
        return None

    def pop_screen(self) -&gt; Screen:
        &#34;&#34;&#34;Pop the current screen from the stack, and switch to the previous screen.

        Returns:
            Screen: The screen that was replaced.
        &#34;&#34;&#34;
        screen_stack = self._screen_stack
        if len(screen_stack) &lt;= 1:
            raise ScreenStackError(
                &#34;Can&#39;t pop screen; there must be at least one screen on the stack&#34;
            )
        previous_screen = self._replace_screen(screen_stack.pop())
        self.screen._screen_resized(self.size)
        self.screen.post_message_no_wait(events.ScreenResume(self))
        self.log.system(f&#34;{self.screen} is active&#34;)
        return previous_screen

    def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -&gt; None:
        &#34;&#34;&#34;Focus (or unfocus) a widget. A focused widget will receive key events first.

        Args:
            widget (Widget): Widget to focus.
            scroll_visible (bool, optional): Scroll widget in to view.
        &#34;&#34;&#34;
        self.screen.set_focus(widget, scroll_visible)

    async def _set_mouse_over(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Called when the mouse is over another widget.

        Args:
            widget (Widget | None): Widget under mouse, or None for no widgets.
        &#34;&#34;&#34;
        if widget is None:
            if self.mouse_over is not None:
                try:
                    await self.mouse_over.post_message(events.Leave(self))
                finally:
                    self.mouse_over = None
        else:
            if self.mouse_over is not widget:
                try:
                    if self.mouse_over is not None:
                        await self.mouse_over._forward_event(events.Leave(self))
                    if widget is not None:
                        await widget._forward_event(events.Enter(self))
                finally:
                    self.mouse_over = widget

    def capture_mouse(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Send all mouse events to the given widget, disable mouse capture.

        Args:
            widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.
        &#34;&#34;&#34;
        if widget == self.mouse_captured:
            return
        if self.mouse_captured is not None:
            self.mouse_captured.post_message_no_wait(
                events.MouseRelease(self, self.mouse_position)
            )
        self.mouse_captured = widget
        if widget is not None:
            widget.post_message_no_wait(events.MouseCapture(self, self.mouse_position))

    def panic(self, *renderables: RenderableType) -&gt; None:
        &#34;&#34;&#34;Exits the app then displays a message.

        Args:
            *renderables (RenderableType, optional): Rich renderables to display on exit.
        &#34;&#34;&#34;

        assert all(
            is_renderable(renderable) for renderable in renderables
        ), &#34;Can only call panic with strings or Rich renderables&#34;

        def render(renderable: RenderableType) -&gt; list[Segment]:
            &#34;&#34;&#34;Render a panic renderables.&#34;&#34;&#34;
            segments = list(self.console.render(renderable, self.console.options))
            return segments

        pre_rendered = [Segments(render(renderable)) for renderable in renderables]
        self._exit_renderables.extend(pre_rendered)
        self._close_messages_no_wait()

    def _handle_exception(self, error: Exception) -&gt; None:
        &#34;&#34;&#34;Called with an unhandled exception.

        Args:
            error (Exception): An exception instance.
        &#34;&#34;&#34;

        if hasattr(error, &#34;__rich__&#34;):
            # Exception has a rich method, so we can defer to that for the rendering
            self.panic(error)
        else:
            # Use default exception rendering
            self.fatal_error()

    def fatal_error(self) -&gt; None:
        &#34;&#34;&#34;Exits the app after an unhandled exception.&#34;&#34;&#34;
        self.bell()
        traceback = Traceback(
            show_locals=True, width=None, locals_max_length=5, suppress=[rich]
        )
        self._exit_renderables.append(
            Segments(self.console.render(traceback, self.console.options))
        )
        self._close_messages_no_wait()

    def _print_error_renderables(self) -&gt; None:
        for renderable in self._exit_renderables:
            self.error_console.print(renderable)
        self._exit_renderables.clear()

    async def _process_messages(
        self, ready_callback: CallbackType | None = None
    ) -&gt; None:
        self._set_active()

        if self.devtools is not None:
            from .devtools.client import DevtoolsConnectionError

            try:
                await self.devtools.connect()
                self.log.system(f&#34;Connected to devtools ( {self.devtools.url} )&#34;)
            except DevtoolsConnectionError:
                self.log.system(f&#34;Couldn&#39;t connect to devtools ( {self.devtools.url} )&#34;)

        self.log.system(&#34;---&#34;)

        self.log.system(driver=self.driver_class)
        self.log.system(loop=asyncio.get_running_loop())
        self.log.system(features=self.features)

        try:
            if self.css_path is not None:
                self.stylesheet.read(self.css_path)
            for path, css, tie_breaker in self.get_default_css():
                self.stylesheet.add_source(
                    css, path=path, is_default_css=True, tie_breaker=tie_breaker
                )
            if self.CSS:
                try:
                    app_css_path = (
                        f&#34;{inspect.getfile(self.__class__)}:{self.__class__.__name__}&#34;
                    )
                except TypeError:
                    app_css_path = f&#34;{self.__class__.__name__}&#34;
                self.stylesheet.add_source(
                    self.CSS, path=app_css_path, is_default_css=False
                )
        except Exception as error:
            self._handle_exception(error)
            self._print_error_renderables()
            return

        if self.css_monitor:
            self.set_interval(0.25, self.css_monitor, name=&#34;css monitor&#34;)
            self.log.system(&#34;[b green]STARTED[/]&#34;, self.css_monitor)

        async def run_process_messages():

            try:
                await self._dispatch_message(events.Compose(sender=self))
                await self._dispatch_message(events.Mount(sender=self))
            finally:
                self._mounted_event.set()

            Reactive._initialize_object(self)

            self.stylesheet.update(self)
            self.refresh()

            await self.animator.start()
            await self._ready()
            if ready_callback is not None:
                await ready_callback()

            self._running = True

            try:
                await self._process_messages_loop()
            except asyncio.CancelledError:
                pass
            finally:
                self._running = False
                for timer in list(self._timers):
                    await timer.stop()

            await self.animator.stop()
            await self._close_all()

        self._running = True
        try:
            load_event = events.Load(sender=self)
            await self._dispatch_message(load_event)

            driver: Driver
            driver_class = cast(
                &#34;type[Driver]&#34;,
                HeadlessDriver if self.is_headless else self.driver_class,
            )
            driver = self._driver = driver_class(self.console, self)

            driver.start_application_mode()
            try:
                if self.is_headless:
                    await run_process_messages()
                else:
                    if self.devtools is not None:
                        devtools = self.devtools
                        assert devtools is not None
                        from .devtools.redirect_output import StdoutRedirector

                        redirector = StdoutRedirector(devtools)
                        with redirect_stderr(redirector):
                            with redirect_stdout(redirector):  # type: ignore
                                await run_process_messages()
                    else:
                        null_file = _NullFile()
                        with redirect_stderr(null_file):
                            with redirect_stdout(null_file):
                                await run_process_messages()

            finally:
                driver.stop_application_mode()
        except Exception as error:
            self._handle_exception(error)
        finally:
            self._running = False
            self._print_error_renderables()
            if self.devtools is not None and self.devtools.is_connected:
                await self._disconnect_devtools()

    async def _pre_process(self) -&gt; None:
        pass

    async def _ready(self) -&gt; None:
        &#34;&#34;&#34;Called immediately prior to processing messages.

        May be used as a hook for any operations that should run first.

        &#34;&#34;&#34;
        try:
            screenshot_timer = float(os.environ.get(&#34;TEXTUAL_SCREENSHOT&#34;, &#34;0&#34;))
        except ValueError:
            return

        screenshot_title = os.environ.get(&#34;TEXTUAL_SCREENSHOT_TITLE&#34;)

        if not screenshot_timer:
            return

        async def on_screenshot():
            &#34;&#34;&#34;Used by docs plugin.&#34;&#34;&#34;
            svg = self.export_screenshot(title=screenshot_title)
            self._screenshot = svg  # type: ignore
            await self.shutdown()

        self.set_timer(screenshot_timer, on_screenshot, name=&#34;screenshot timer&#34;)

    async def _on_compose(self) -&gt; None:
        widgets = list(self.compose())
        await self.mount_all(widgets)

    def _on_idle(self) -&gt; None:
        &#34;&#34;&#34;Perform actions when there are no messages in the queue.&#34;&#34;&#34;
        if self._require_stylesheet_update:
            nodes: set[DOMNode] = {
                child
                for node in self._require_stylesheet_update
                for child in node.walk_children()
            }
            self._require_stylesheet_update.clear()
            self.stylesheet.update_nodes(nodes, animate=True)

    def _register_child(self, parent: DOMNode, child: Widget) -&gt; bool:
        if child not in self._registry:
            parent.children._append(child)
            self._registry.add(child)
            child._attach(parent)
            child._post_register(self)
            child._start_messages()
            return True
        return False

    def _register(
        self, parent: DOMNode, *anon_widgets: Widget, **widgets: Widget
    ) -&gt; list[Widget]:
        &#34;&#34;&#34;Register widget(s) so they may receive events.

        Args:
            parent (Widget): Parent Widget.

        Returns:
            list[Widget]: List of modified widgets.

        &#34;&#34;&#34;
        if not anon_widgets and not widgets:
            return []
        name_widgets: list[tuple[str | None, Widget]]
        name_widgets = [*((None, widget) for widget in anon_widgets), *widgets.items()]
        apply_stylesheet = self.stylesheet.apply

        for widget_id, widget in name_widgets:
            if not isinstance(widget, Widget):
                raise AppError(f&#34;Can&#39;t register {widget!r}; expected a Widget instance&#34;)
            if widget not in self._registry:
                if widget_id is not None:
                    widget.id = widget_id
                self._register_child(parent, widget)
                if widget.children:
                    self._register(widget, *widget.children)
                apply_stylesheet(widget)

        registered_widgets = [widget for _, widget in name_widgets]
        return registered_widgets

    def _unregister(self, widget: Widget) -&gt; None:
        &#34;&#34;&#34;Unregister a widget.

        Args:
            widget (Widget): A Widget to unregister
        &#34;&#34;&#34;
        widget.reset_focus()
        if isinstance(widget._parent, Widget):
            widget._parent.children._remove(widget)
            widget._detach()
        self._registry.discard(widget)

    async def _disconnect_devtools(self):
        if self.devtools is not None:
            await self.devtools.disconnect()

    def _start_widget(self, parent: Widget, widget: Widget) -&gt; None:
        &#34;&#34;&#34;Start a widget (run it&#39;s task) so that it can receive messages.

        Args:
            parent (Widget): The parent of the Widget.
            widget (Widget): The Widget to start.
        &#34;&#34;&#34;
        widget._attach(parent)
        widget._start_messages()

    def is_mounted(self, widget: Widget) -&gt; bool:
        &#34;&#34;&#34;Check if a widget is mounted.

        Args:
            widget (Widget): A widget.

        Returns:
            bool: True of the widget is mounted.
        &#34;&#34;&#34;
        return widget in self._registry

    async def _close_all(self) -&gt; None:
        while self._registry:
            child = self._registry.pop()
            await child._close_messages()

    async def shutdown(self):
        await self._disconnect_devtools()
        driver = self._driver
        if driver is not None:
            driver.disable_input()
        await self._close_messages()

    def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
        if self._screen_stack:
            self.screen.refresh(repaint=repaint, layout=layout)
        self.check_idle()

    def refresh_css(self, animate: bool = True) -&gt; None:
        &#34;&#34;&#34;Refresh CSS.

        Args:
            animate (bool, optional): Also execute CSS animations. Defaults to True.
        &#34;&#34;&#34;
        stylesheet = self.app.stylesheet
        stylesheet.set_variables(self.get_css_variables())
        stylesheet.reparse()
        stylesheet.update(self.app, animate=animate)
        self.screen._refresh_layout(self.size, full=True)

    def _display(self, screen: Screen, renderable: RenderableType | None) -&gt; None:
        &#34;&#34;&#34;Display a renderable within a sync.

        Args:
            screen (Screen): Screen instance
            renderable (RenderableType): A Rich renderable.
        &#34;&#34;&#34;
        if screen is not self.screen or renderable is None:
            return
        if self._running and not self._closed and not self.is_headless:
            console = self.console
            self._begin_update()
            try:
                try:
                    console.print(renderable)
                except Exception as error:
                    self._handle_exception(error)
            finally:
                self._end_update()
            console.file.flush()

    def get_widget_at(self, x: int, y: int) -&gt; tuple[Widget, Region]:
        &#34;&#34;&#34;Get the widget under the given coordinates.

        Args:
            x (int): X Coord.
            y (int): Y Coord.

        Returns:
            tuple[Widget, Region]: The widget and the widget&#39;s screen region.
        &#34;&#34;&#34;
        return self.screen.get_widget_at(x, y)

    def bell(self) -&gt; None:
        &#34;&#34;&#34;Play the console &#39;bell&#39;.&#34;&#34;&#34;
        if not self.is_headless:
            self.console.bell()

    @property
    def _binding_chain(self) -&gt; list[tuple[DOMNode, Bindings]]:
        &#34;&#34;&#34;Get a chain of nodes and bindings to consider. If no widget is focused, returns the bindings from both the screen and the app level bindings. Otherwise, combines all the bindings from the currently focused node up the DOM to the root App.

        Returns:
            list[tuple[DOMNode, Bindings]]: List of DOM nodes and their bindings.
        &#34;&#34;&#34;
        focused = self.focused
        namespace_bindings: list[tuple[DOMNode, Bindings]]
        if focused is None:
            namespace_bindings = [
                (self.screen, self.screen._bindings),
                (self, self._bindings),
            ]
        else:
            namespace_bindings = [(node, node._bindings) for node in focused.ancestors]
        return namespace_bindings

    async def check_bindings(self, key: str, universal: bool = False) -&gt; bool:
        &#34;&#34;&#34;Handle a key press.

        Args:
            key (str): A key
            universal (bool): Check universal keys if True, otherwise non-universal keys.

        Returns:
            bool: True if the key was handled by a binding, otherwise False
        &#34;&#34;&#34;

        for namespace, bindings in self._binding_chain:
            binding = bindings.keys.get(key)
            if binding is not None and binding.universal == universal:
                await self.action(binding.action, default_namespace=namespace)
                return True
        return False

    async def on_event(self, event: events.Event) -&gt; None:
        # Handle input events that haven&#39;t been forwarded
        # If the event has been forwarded it may have bubbled up back to the App
        if isinstance(event, events.Compose):
            screen = Screen(id=&#34;_default&#34;)
            self._register(self, screen)
            self._screen_stack.append(screen)
            await super().on_event(event)

        elif isinstance(event, events.InputEvent) and not event.is_forwarded:
            if isinstance(event, events.MouseEvent):
                # Record current mouse position on App
                self.mouse_position = Offset(event.x, event.y)
                await self.screen._forward_event(event)
            elif isinstance(event, events.Key):
                if not await self.check_bindings(event.key, universal=True):
                    forward_target = self.focused or self.screen
                    await forward_target._forward_event(event)
            else:
                await self.screen._forward_event(event)

        elif isinstance(event, events.Paste):
            if self.focused is not None:
                await self.focused._forward_event(event)
        else:
            await super().on_event(event)

    async def action(
        self,
        action: str | tuple[str, tuple[str, ...]],
        default_namespace: object | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Perform an action.

        Args:
            action (str): Action encoded in a string.
            default_namespace (object | None): Namespace to use if not provided in the action,
                or None to use app. Defaults to None.

        Returns:
            bool: True if the event has handled.
        &#34;&#34;&#34;
        print(&#34;ACTION&#34;, action, default_namespace)
        if isinstance(action, str):
            target, params = actions.parse(action)
        else:
            target, params = action
        implicit_destination = True
        if &#34;.&#34; in target:
            destination, action_name = target.split(&#34;.&#34;, 1)
            if destination not in self._action_targets:
                raise ActionError(f&#34;Action namespace {destination} is not known&#34;)
            action_target = getattr(self, destination)
            implicit_destination = True
        else:
            action_target = default_namespace or self
            action_name = target

        handled = await self._dispatch_action(action_target, action_name, params)
        if not handled and implicit_destination and not isinstance(action_target, App):
            handled = await self.app._dispatch_action(self.app, action_name, params)
        return handled

    async def _dispatch_action(
        self, namespace: object, action_name: str, params: Any
    ) -&gt; bool:
        log(
            &#34;&lt;action&gt;&#34;,
            namespace=namespace,
            action_name=action_name,
            params=params,
        )
        _rich_traceback_guard = True

        public_method_name = f&#34;action_{action_name}&#34;
        private_method_name = f&#34;_{public_method_name}&#34;

        private_method = getattr(namespace, private_method_name, None)
        public_method = getattr(namespace, public_method_name, None)

        if private_method is None and public_method is None:
            log(
                f&#34;&lt;action&gt; {action_name!r} has no target. Couldn&#39;t find methods {public_method_name!r} or {private_method_name!r}&#34;
            )

        if callable(private_method):
            await invoke(private_method, *params)
            return True
        elif callable(public_method):
            await invoke(public_method, *params)
            return True

        return False

    async def _broker_event(
        self, event_name: str, event: events.Event, default_namespace: object | None
    ) -&gt; bool:
        &#34;&#34;&#34;Allow the app an opportunity to dispatch events to action system.

        Args:
            event_name (str): _description_
            event (events.Event): An event object.
            default_namespace (object | None): TODO: _description_

        Returns:
            bool: True if an action was processed.
        &#34;&#34;&#34;
        try:
            style = getattr(event, &#34;style&#34;)
        except AttributeError:
            return False
        try:
            _modifiers, action = extract_handler_actions(event_name, style.meta)
        except NoHandler:
            return False
        else:
            event.stop()
        if isinstance(action, (str, tuple)):
            await self.action(action, default_namespace=default_namespace)
        elif callable(action):
            await action()
        else:
            return False
        return True

    async def _on_update(self, message: messages.Update) -&gt; None:
        message.stop()

    async def _on_layout(self, message: messages.Layout) -&gt; None:
        message.stop()

    async def _on_key(self, event: events.Key) -&gt; None:
        if event.key == &#34;tab&#34;:
            self.screen.focus_next()
        elif event.key == &#34;shift+tab&#34;:
            self.screen.focus_previous()
        else:
            if not (await self.check_bindings(event.key)):
                await self.dispatch_key(event)

    async def _on_shutdown_request(self, event: events.ShutdownRequest) -&gt; None:
        log(&#34;shutdown request&#34;)
        await self._close_messages()

    async def _on_resize(self, event: events.Resize) -&gt; None:
        event.stop()
        await self.screen.post_message(event)

    async def _on_remove(self, event: events.Remove) -&gt; None:
        widget = event.widget
        parent = widget.parent

        remove_widgets = widget.walk_children(
            Widget, with_self=True, method=&#34;depth&#34;, reverse=True
        )

        if self.screen.focused in remove_widgets:
            self.screen._reset_focus(
                self.screen.focused,
                [to_remove for to_remove in remove_widgets if to_remove.can_focus],
            )

        for child in remove_widgets:
            await child._close_messages()
            self._unregister(child)
        if parent is not None:
            parent.refresh(layout=True)

    async def action_check_bindings(self, key: str) -&gt; None:
        await self.check_bindings(key)

    async def action_quit(self) -&gt; None:
        &#34;&#34;&#34;Quit the app as soon as possible.&#34;&#34;&#34;
        await self.shutdown()

    async def action_bang(self) -&gt; None:
        1 / 0

    async def action_bell(self) -&gt; None:
        &#34;&#34;&#34;Play the terminal &#39;bell&#39;.&#34;&#34;&#34;
        self.bell()

    async def action_focus(self, widget_id: str) -&gt; None:
        &#34;&#34;&#34;Focus the given widget.

        Args:
            widget_id (str): ID of widget to focus.
        &#34;&#34;&#34;
        try:
            node = self.query(f&#34;#{widget_id}&#34;).first()
        except NoMatches:
            pass
        else:
            if isinstance(node, Widget):
                self.set_focus(node)

    async def action_switch_screen(self, screen: str) -&gt; None:
        &#34;&#34;&#34;Switches to another screen.

        Args:
            screen (str): Name of the screen.
        &#34;&#34;&#34;
        self.switch_screen(screen)

    async def action_push_screen(self, screen: str) -&gt; None:
        &#34;&#34;&#34;Pushes a screen on to the screen stack and makes it active.

        Args:
            screen (str): Name of the screen.
        &#34;&#34;&#34;
        self.push_screen(screen)

    async def action_pop_screen(self) -&gt; None:
        &#34;&#34;&#34;Removes the topmost screen and makes the new topmost screen active.&#34;&#34;&#34;
        self.pop_screen()

    async def action_back(self) -&gt; None:
        try:
            self.pop_screen()
        except ScreenStackError:
            pass

    async def action_add_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).add_class(class_name)

    async def action_remove_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).remove_class(class_name)

    async def action_toggle_class(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).toggle_class(class_name)

    def _on_terminal_supports_synchronized_output(
        self, message: messages.TerminalSupportsSynchronizedOutput
    ) -&gt; None:
        log.system(&#34;[b green]SynchronizedOutput mode is supported&#34;)
        self._sync_available = True

    def _begin_update(self) -&gt; None:
        if self._sync_available:
            self.console.file.write(SYNC_START)

    def _end_update(self) -&gt; None:
        if self._sync_available:
            self.console.file.write(SYNC_END)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
<li><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></li>
<li><a title="textual.message_pump.MessagePump" href="message_pump.html#textual.message_pump.MessagePump">MessagePump</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textual.cli.previews.borders.BorderApp" href="cli/previews/borders.html#textual.cli.previews.borders.BorderApp">BorderApp</a></li>
<li><a title="textual.cli.previews.colors.ColorsApp" href="cli/previews/colors.html#textual.cli.previews.colors.ColorsApp">ColorsApp</a></li>
<li><a title="textual.cli.previews.easing.EasingApp" href="cli/previews/easing.html#textual.cli.previews.easing.EasingApp">EasingApp</a></li>
<li><a title="textual.demo.DemoApp" href="demo.html#textual.demo.DemoApp">DemoApp</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="textual.app.App.CSS"><code class="name">var <span class="ident">CSS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.app.App.CSS_PATH"><code class="name">var <span class="ident">CSS_PATH</span> :CSSPathType</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.app.App.DEFAULT_CSS"><code class="name">var <span class="ident">DEFAULT_CSS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.app.App.SCREENS"><code class="name">var <span class="ident">SCREENS</span> :dict[str,Screen]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.app.App.SUB_TITLE"><code class="name">var <span class="ident">SUB_TITLE</span> :str|None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.app.App.TITLE"><code class="name">var <span class="ident">TITLE</span> :str|None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="textual.app.App.animator"><code class="name">var <span class="ident">animator</span> :textual._animator.Animator</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def animator(self) -&gt; Animator:
    return self._animator</code></pre>
</details>
</dd>
<dt id="textual.app.App.dark"><code class="name">var <span class="ident">dark</span> :ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p>
<h2 id="args">Args</h2>
<dl>
<dt>default (ReactiveType | Callable[[], ReactiveType]): A default value or callable that returns a default.</dt>
<dt><strong><code>layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Perform a layout on change. Defaults to False.</dd>
<dt><strong><code>repaint</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Perform a repaint on change. Defaults to True.</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Call watchers on initialize (post mount). Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    value: _NotSet | ReactiveType = getattr(obj, self.internal_name, _NOT_SET)
    if isinstance(value, _NotSet):
        # No value present, we need to set the default
        init_name = f&#34;_default_{self.name}&#34;
        default = getattr(obj, init_name)
        default_value = default() if callable(default) else default
        # Set and return the value
        setattr(obj, self.internal_name, default_value)
        if self._init:
            self._check_watchers(obj, self.name, default_value, first_set=True)
        return default_value
    return value</code></pre>
</details>
</dd>
<dt id="textual.app.App.debug"><code class="name">var <span class="ident">debug</span> :bool</code></dt>
<dd>
<div class="desc"><p>Check if debug mode is enabled.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if debug mode is enabled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def debug(self) -&gt; bool:
    &#34;&#34;&#34;Check if debug mode is enabled.

    Returns:
        bool: True if debug mode is enabled.

    &#34;&#34;&#34;
    return &#34;debug&#34; in self.features</code></pre>
</details>
</dd>
<dt id="textual.app.App.focused"><code class="name">var <span class="ident">focused</span> :Widget|None</code></dt>
<dd>
<div class="desc"><p>Get the widget that is focused on the currently active screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def focused(self) -&gt; Widget | None:
    &#34;&#34;&#34;Get the widget that is focused on the currently active screen.&#34;&#34;&#34;
    return self.screen.focused</code></pre>
</details>
</dd>
<dt id="textual.app.App.is_headless"><code class="name">var <span class="ident">is_headless</span> :bool</code></dt>
<dd>
<div class="desc"><p>Check if the app is running in 'headless' mode.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the app is in headless mode.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_headless(self) -&gt; bool:
    &#34;&#34;&#34;Check if the app is running in &#39;headless&#39; mode.

    Returns:
        bool: True if the app is in headless mode.

    &#34;&#34;&#34;
    return &#34;headless&#34; in self.features</code></pre>
</details>
</dd>
<dt id="textual.app.App.is_transparent"><code class="name">var <span class="ident">is_transparent</span> :bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_transparent(self) -&gt; bool:
    return True</code></pre>
</details>
</dd>
<dt id="textual.app.App.namespace_bindings"><code class="name">var <span class="ident">namespace_bindings</span> :dict[str,tuple[DOMNode,Binding]]</code></dt>
<dd>
<div class="desc"><p>Get current bindings. If no widget is focused, then the app-level bindings
are returned. If a widget is focused, then any bindings present in the active
screen and app are merged and returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def namespace_bindings(self) -&gt; dict[str, tuple[DOMNode, Binding]]:
    &#34;&#34;&#34;Get current bindings. If no widget is focused, then the app-level bindings
    are returned. If a widget is focused, then any bindings present in the active
    screen and app are merged and returned.&#34;&#34;&#34;

    namespace_binding_map: dict[str, tuple[DOMNode, Binding]] = {}
    for namespace, bindings in reversed(self._binding_chain):
        for key, binding in bindings.keys.items():
            namespace_binding_map[key] = (namespace, binding)

    return namespace_binding_map</code></pre>
</details>
</dd>
<dt id="textual.app.App.screen"><code class="name">var <span class="ident">screen</span> :<a title="textual.screen.Screen" href="screen.html#textual.screen.Screen">Screen</a></code></dt>
<dd>
<div class="desc"><p>Get the current screen.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="textual.app.ScreenStackError" href="#textual.app.ScreenStackError">ScreenStackError</a></code></dt>
<dd>If there are no screens on the stack.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Screen</code></dt>
<dd>The currently active screen.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def screen(self) -&gt; Screen:
    &#34;&#34;&#34;Get the current screen.

    Raises:
        ScreenStackError: If there are no screens on the stack.

    Returns:
        Screen: The currently active screen.
    &#34;&#34;&#34;
    try:
        return self._screen_stack[-1]
    except IndexError:
        raise ScreenStackError(&#34;No screens on stack&#34;) from None</code></pre>
</details>
</dd>
<dt id="textual.app.App.screen_stack"><code class="name">var <span class="ident">screen_stack</span> :list[Screen]</code></dt>
<dd>
<div class="desc"><p>Get a <em>copy</em> of the screen stack.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[Screen]</code></dt>
<dd>List of screens.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def screen_stack(self) -&gt; list[Screen]:
    &#34;&#34;&#34;Get a *copy* of the screen stack.

    Returns:
        list[Screen]: List of screens.

    &#34;&#34;&#34;
    return self._screen_stack.copy()</code></pre>
</details>
</dd>
<dt id="textual.app.App.size"><code class="name">var <span class="ident">size</span> :<a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"><p>Get the size of the terminal.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Size</code></dt>
<dd>Size of the terminal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Size:
    &#34;&#34;&#34;Get the size of the terminal.

    Returns:
        Size: Size of the terminal
    &#34;&#34;&#34;
    return Size(*self.console.size)</code></pre>
</details>
</dd>
<dt id="textual.app.App.sub_title"><code class="name">var <span class="ident">sub_title</span> :ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p>
<h2 id="args">Args</h2>
<dl>
<dt>default (ReactiveType | Callable[[], ReactiveType]): A default value or callable that returns a default.</dt>
<dt><strong><code>layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Perform a layout on change. Defaults to False.</dd>
<dt><strong><code>repaint</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Perform a repaint on change. Defaults to True.</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Call watchers on initialize (post mount). Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    value: _NotSet | ReactiveType = getattr(obj, self.internal_name, _NOT_SET)
    if isinstance(value, _NotSet):
        # No value present, we need to set the default
        init_name = f&#34;_default_{self.name}&#34;
        default = getattr(obj, init_name)
        default_value = default() if callable(default) else default
        # Set and return the value
        setattr(obj, self.internal_name, default_value)
        if self._init:
            self._check_watchers(obj, self.name, default_value, first_set=True)
        return default_value
    return value</code></pre>
</details>
</dd>
<dt id="textual.app.App.title"><code class="name">var <span class="ident">title</span> :ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p>
<h2 id="args">Args</h2>
<dl>
<dt>default (ReactiveType | Callable[[], ReactiveType]): A default value or callable that returns a default.</dt>
<dt><strong><code>layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Perform a layout on change. Defaults to False.</dd>
<dt><strong><code>repaint</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Perform a repaint on change. Defaults to True.</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Call watchers on initialize (post mount). Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    value: _NotSet | ReactiveType = getattr(obj, self.internal_name, _NOT_SET)
    if isinstance(value, _NotSet):
        # No value present, we need to set the default
        init_name = f&#34;_default_{self.name}&#34;
        default = getattr(obj, init_name)
        default_value = default() if callable(default) else default
        # Set and return the value
        setattr(obj, self.internal_name, default_value)
        if self._init:
            self._check_watchers(obj, self.name, default_value, first_set=True)
        return default_value
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.app.App.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, action:str|tuple[str,tuple[str,...]], default_namespace:object|None=None) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Perform an action.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Action encoded in a string.</dd>
</dl>
<p>default_namespace (object | None): Namespace to use if not provided in the action,
or None to use app. Defaults to None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the event has handled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(
    self,
    action: str | tuple[str, tuple[str, ...]],
    default_namespace: object | None = None,
) -&gt; bool:
    &#34;&#34;&#34;Perform an action.

    Args:
        action (str): Action encoded in a string.
        default_namespace (object | None): Namespace to use if not provided in the action,
            or None to use app. Defaults to None.

    Returns:
        bool: True if the event has handled.
    &#34;&#34;&#34;
    print(&#34;ACTION&#34;, action, default_namespace)
    if isinstance(action, str):
        target, params = actions.parse(action)
    else:
        target, params = action
    implicit_destination = True
    if &#34;.&#34; in target:
        destination, action_name = target.split(&#34;.&#34;, 1)
        if destination not in self._action_targets:
            raise ActionError(f&#34;Action namespace {destination} is not known&#34;)
        action_target = getattr(self, destination)
        implicit_destination = True
    else:
        action_target = default_namespace or self
        action_name = target

    handled = await self._dispatch_action(action_target, action_name, params)
    if not handled and implicit_destination and not isinstance(action_target, App):
        handled = await self.app._dispatch_action(self.app, action_name, params)
    return handled</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_add_class_"><code class="name flex">
<span>async def <span class="ident">action_add_class_</span></span>(<span>self, selector:str, class_name:str) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_add_class_(self, selector: str, class_name: str) -&gt; None:
    self.screen.query(selector).add_class(class_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_back"><code class="name flex">
<span>async def <span class="ident">action_back</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_back(self) -&gt; None:
    try:
        self.pop_screen()
    except ScreenStackError:
        pass</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_bang"><code class="name flex">
<span>async def <span class="ident">action_bang</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_bang(self) -&gt; None:
    1 / 0</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_bell"><code class="name flex">
<span>async def <span class="ident">action_bell</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Play the terminal 'bell'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_bell(self) -&gt; None:
    &#34;&#34;&#34;Play the terminal &#39;bell&#39;.&#34;&#34;&#34;
    self.bell()</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_check_bindings"><code class="name flex">
<span>async def <span class="ident">action_check_bindings</span></span>(<span>self, key:str) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_check_bindings(self, key: str) -&gt; None:
    await self.check_bindings(key)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_focus"><code class="name flex">
<span>async def <span class="ident">action_focus</span></span>(<span>self, widget_id:str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Focus the given widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of widget to focus.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_focus(self, widget_id: str) -&gt; None:
    &#34;&#34;&#34;Focus the given widget.

    Args:
        widget_id (str): ID of widget to focus.
    &#34;&#34;&#34;
    try:
        node = self.query(f&#34;#{widget_id}&#34;).first()
    except NoMatches:
        pass
    else:
        if isinstance(node, Widget):
            self.set_focus(node)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_pop_screen"><code class="name flex">
<span>async def <span class="ident">action_pop_screen</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the topmost screen and makes the new topmost screen active.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_pop_screen(self) -&gt; None:
    &#34;&#34;&#34;Removes the topmost screen and makes the new topmost screen active.&#34;&#34;&#34;
    self.pop_screen()</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_push_screen"><code class="name flex">
<span>async def <span class="ident">action_push_screen</span></span>(<span>self, screen:str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Pushes a screen on to the screen stack and makes it active.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>screen</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the screen.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_push_screen(self, screen: str) -&gt; None:
    &#34;&#34;&#34;Pushes a screen on to the screen stack and makes it active.

    Args:
        screen (str): Name of the screen.
    &#34;&#34;&#34;
    self.push_screen(screen)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_quit"><code class="name flex">
<span>async def <span class="ident">action_quit</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Quit the app as soon as possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_quit(self) -&gt; None:
    &#34;&#34;&#34;Quit the app as soon as possible.&#34;&#34;&#34;
    await self.shutdown()</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_remove_class_"><code class="name flex">
<span>async def <span class="ident">action_remove_class_</span></span>(<span>self, selector:str, class_name:str) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_remove_class_(self, selector: str, class_name: str) -&gt; None:
    self.screen.query(selector).remove_class(class_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_screenshot"><code class="name flex">
<span>def <span class="ident">action_screenshot</span></span>(<span>self, filename:str|None=None, path:str='./') >None</span>
</code></dt>
<dd>
<div class="desc"><p>Save an SVG "screenshot". This action will save an SVG file containing the current contents of the screen.</p>
<h2 id="args">Args</h2>
<dl>
<dt>filename (str | None, optional): Filename of screenshot, or None to auto-generate. Defaults to None.</dt>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to directory. Defaults to "~/".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def action_screenshot(self, filename: str | None = None, path: str = &#34;./&#34;) -&gt; None:
    &#34;&#34;&#34;Save an SVG &#34;screenshot&#34;. This action will save an SVG file containing the current contents of the screen.

    Args:
        filename (str | None, optional): Filename of screenshot, or None to auto-generate. Defaults to None.
        path (str, optional): Path to directory. Defaults to &#34;~/&#34;.
    &#34;&#34;&#34;
    self.save_screenshot(filename, path)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_switch_screen"><code class="name flex">
<span>async def <span class="ident">action_switch_screen</span></span>(<span>self, screen:str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Switches to another screen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>screen</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the screen.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_switch_screen(self, screen: str) -&gt; None:
    &#34;&#34;&#34;Switches to another screen.

    Args:
        screen (str): Name of the screen.
    &#34;&#34;&#34;
    self.switch_screen(screen)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_toggle_class"><code class="name flex">
<span>async def <span class="ident">action_toggle_class</span></span>(<span>self, selector:str, class_name:str) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_toggle_class(self, selector: str, class_name: str) -&gt; None:
    self.screen.query(selector).toggle_class(class_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_toggle_dark"><code class="name flex">
<span>def <span class="ident">action_toggle_dark</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Action to toggle dark mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def action_toggle_dark(self) -&gt; None:
    &#34;&#34;&#34;Action to toggle dark mode.&#34;&#34;&#34;
    self.dark = not self.dark</code></pre>
</details>
</dd>
<dt id="textual.app.App.animate"><code class="name flex">
<span>def <span class="ident">animate</span></span>(<span>self, attribute:str, value:float|Animatable, *, final_value:object=Ellipsis, duration:float|None=None, speed:float|None=None, delay:float=0.0, easing:EasingFunction|str='in_out_cubic', on_complete:CallbackType|None=None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Animate an attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the attribute to animate.</dd>
<dt>value (float | Animatable): The value to animate to.</dt>
<dt><strong><code>final_value</code></strong> :&ensp;<code>object</code>, optional</dt>
<dd>The final value of the animation. Defaults to <code>value</code> if not set.</dd>
<dt>duration (float | None, optional): The duration of the animate. Defaults to None.</dt>
<dt>speed (float | None, optional): The speed of the animation. Defaults to None.</dt>
<dt><strong><code>delay</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>A delay (in seconds) before the animation starts. Defaults to 0.0.</dd>
</dl>
<p>easing (EasingFunction | str, optional): An easing method. Defaults to "in_out_cubic".
on_complete (CallbackType | None, optional): A callable to invoke when the animation is finished. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate(
    self,
    attribute: str,
    value: float | Animatable,
    *,
    final_value: object = ...,
    duration: float | None = None,
    speed: float | None = None,
    delay: float = 0.0,
    easing: EasingFunction | str = DEFAULT_EASING,
    on_complete: CallbackType | None = None,
) -&gt; None:
    &#34;&#34;&#34;Animate an attribute.

    Args:
        attribute (str): Name of the attribute to animate.
        value (float | Animatable): The value to animate to.
        final_value (object, optional): The final value of the animation. Defaults to `value` if not set.
        duration (float | None, optional): The duration of the animate. Defaults to None.
        speed (float | None, optional): The speed of the animation. Defaults to None.
        delay (float, optional): A delay (in seconds) before the animation starts. Defaults to 0.0.
        easing (EasingFunction | str, optional): An easing method. Defaults to &#34;in_out_cubic&#34;.
        on_complete (CallbackType | None, optional): A callable to invoke when the animation is finished. Defaults to None.

    &#34;&#34;&#34;
    self._animate(
        attribute,
        value,
        final_value=final_value,
        duration=duration,
        speed=speed,
        delay=delay,
        easing=easing,
        on_complete=on_complete,
    )</code></pre>
</details>
</dd>
<dt id="textual.app.App.bell"><code class="name flex">
<span>def <span class="ident">bell</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Play the console 'bell'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bell(self) -&gt; None:
    &#34;&#34;&#34;Play the console &#39;bell&#39;.&#34;&#34;&#34;
    if not self.is_headless:
        self.console.bell()</code></pre>
</details>
</dd>
<dt id="textual.app.App.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, keys:str, action:str, *, description:str='', show:bool=True, key_display:str|None=None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Bind a key to an action.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keys</code></strong> :&ensp;<code>str</code></dt>
<dd>A comma separated list of keys, i.e.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Action to bind to.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Short description of action. Defaults to "".</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Show key in UI. Defaults to True.</dd>
<dt><strong><code>key_display</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Replacement text for key, or None to use default. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind(
    self,
    keys: str,
    action: str,
    *,
    description: str = &#34;&#34;,
    show: bool = True,
    key_display: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Bind a key to an action.

    Args:
        keys (str): A comma separated list of keys, i.e.
        action (str): Action to bind to.
        description (str, optional): Short description of action. Defaults to &#34;&#34;.
        show (bool, optional): Show key in UI. Defaults to True.
        key_display (str, optional): Replacement text for key, or None to use default. Defaults to None.
    &#34;&#34;&#34;
    self._bindings.bind(
        keys, action, description, show=show, key_display=key_display
    )</code></pre>
</details>
</dd>
<dt id="textual.app.App.capture_mouse"><code class="name flex">
<span>def <span class="ident">capture_mouse</span></span>(<span>self, widget:Widget|None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Send all mouse events to the given widget, disable mouse capture.</p>
<h2 id="args">Args</h2>
<p>widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_mouse(self, widget: Widget | None) -&gt; None:
    &#34;&#34;&#34;Send all mouse events to the given widget, disable mouse capture.

    Args:
        widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.
    &#34;&#34;&#34;
    if widget == self.mouse_captured:
        return
    if self.mouse_captured is not None:
        self.mouse_captured.post_message_no_wait(
            events.MouseRelease(self, self.mouse_position)
        )
    self.mouse_captured = widget
    if widget is not None:
        widget.post_message_no_wait(events.MouseCapture(self, self.mouse_position))</code></pre>
</details>
</dd>
<dt id="textual.app.App.check_bindings"><code class="name flex">
<span>async def <span class="ident">check_bindings</span></span>(<span>self, key:str, universal:bool=False) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Handle a key press.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>A key</dd>
<dt><strong><code>universal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Check universal keys if True, otherwise non-universal keys.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the key was handled by a binding, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_bindings(self, key: str, universal: bool = False) -&gt; bool:
    &#34;&#34;&#34;Handle a key press.

    Args:
        key (str): A key
        universal (bool): Check universal keys if True, otherwise non-universal keys.

    Returns:
        bool: True if the key was handled by a binding, otherwise False
    &#34;&#34;&#34;

    for namespace, bindings in self._binding_chain:
        binding = bindings.keys.get(key)
        if binding is not None and binding.universal == universal:
            await self.action(binding.action, default_namespace=namespace)
            return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.app.App.compose"><code class="name flex">
<span>def <span class="ident">compose</span></span>(<span>self) >Iterable[<a title="textual.widget.Widget" href="widget.html#textual.widget.Widget">Widget</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Yield child widgets for a container.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose(self) -&gt; ComposeResult:
    &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
    return
    yield</code></pre>
</details>
</dd>
<dt id="textual.app.App.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self, result:ReturnType|None=None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Exit the app, and return the supplied result.</p>
<h2 id="args">Args</h2>
<p>result (ReturnType | None, optional): Return value. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit(self, result: ReturnType | None = None) -&gt; None:
    &#34;&#34;&#34;Exit the app, and return the supplied result.

    Args:
        result (ReturnType | None, optional): Return value. Defaults to None.
    &#34;&#34;&#34;
    self._return_value = result
    self._close_messages_no_wait()</code></pre>
</details>
</dd>
<dt id="textual.app.App.export_screenshot"><code class="name flex">
<span>def <span class="ident">export_screenshot</span></span>(<span>self, *, title:str|None=None) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Export an SVG screenshot of the current screen.</p>
<h2 id="args">Args</h2>
<p>title (str | None, optional): The title of the exported screenshot or None
to use app title. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_screenshot(self, *, title: str | None = None) -&gt; str:
    &#34;&#34;&#34;Export an SVG screenshot of the current screen.

    Args:
        title (str | None, optional): The title of the exported screenshot or None
            to use app title. Defaults to None.

    &#34;&#34;&#34;

    console = Console(
        width=self.console.width,
        height=self.console.height,
        file=io.StringIO(),
        force_terminal=True,
        color_system=&#34;truecolor&#34;,
        record=True,
        legacy_windows=False,
    )
    screen_render = self.screen._compositor.render(full=True)
    console.print(screen_render)
    return console.export_svg(title=title or self.title)</code></pre>
</details>
</dd>
<dt id="textual.app.App.fatal_error"><code class="name flex">
<span>def <span class="ident">fatal_error</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Exits the app after an unhandled exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fatal_error(self) -&gt; None:
    &#34;&#34;&#34;Exits the app after an unhandled exception.&#34;&#34;&#34;
    self.bell()
    traceback = Traceback(
        show_locals=True, width=None, locals_max_length=5, suppress=[rich]
    )
    self._exit_renderables.append(
        Segments(self.console.render(traceback, self.console.options))
    )
    self._close_messages_no_wait()</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_child"><code class="name flex">
<span>def <span class="ident">get_child</span></span>(<span>self, id:str) ><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shorthand for self.screen.get_child(id: str)
Returns the first child (immediate descendent) of this DOMNode
with the given ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the node to search for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DOMNode</code></dt>
<dd>The first child of this node with the specified ID.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NoMatches</code></dt>
<dd>if no children could be found for this ID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_child(self, id: str) -&gt; DOMNode:
    &#34;&#34;&#34;Shorthand for self.screen.get_child(id: str)
    Returns the first child (immediate descendent) of this DOMNode
    with the given ID.

    Args:
        id (str): The ID of the node to search for.

    Returns:
        DOMNode: The first child of this node with the specified ID.

    Raises:
        NoMatches: if no children could be found for this ID
    &#34;&#34;&#34;
    return self.screen.get_child(id)</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_css_variables"><code class="name flex">
<span>def <span class="ident">get_css_variables</span></span>(<span>self) >dict[str,str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a mapping of variables used to pre-populate CSS.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A mapping of variable name to value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_css_variables(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Get a mapping of variables used to pre-populate CSS.

    Returns:
        dict[str, str]: A mapping of variable name to value.
    &#34;&#34;&#34;
    variables = self.design[&#34;dark&#34; if self.dark else &#34;light&#34;].generate()
    return variables</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_driver_class"><code class="name flex">
<span>def <span class="ident">get_driver_class</span></span>(<span>self) >Type[<a title="textual.driver.Driver" href="driver.html#textual.driver.Driver">Driver</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a driver class for this platform.</p>
<p>Called by the constructor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Driver</code></dt>
<dd>A Driver class which manages input and display.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_driver_class(self) -&gt; Type[Driver]:
    &#34;&#34;&#34;Get a driver class for this platform.

    Called by the constructor.

    Returns:
        Driver: A Driver class which manages input and display.
    &#34;&#34;&#34;
    driver_class: Type[Driver]
    if WINDOWS:
        from .drivers.windows_driver import WindowsDriver

        driver_class = WindowsDriver
    else:
        from .drivers.linux_driver import LinuxDriver

        driver_class = LinuxDriver
    return driver_class</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_screen"><code class="name flex">
<span>def <span class="ident">get_screen</span></span>(<span>self, screen:Screen|str) >Screen</span>
</code></dt>
<dd>
<div class="desc"><p>Get an installed screen.</p>
<p>If the screen isn't running, it will be registered before it is run.</p>
<h2 id="args">Args</h2>
<p>screen (Screen | str): Either a Screen object or screen name (the <code>name</code> argument when installed).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>If the named screen doesn't exist.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Screen</code></dt>
<dd>A screen instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen(self, screen: Screen | str) -&gt; Screen:
    &#34;&#34;&#34;Get an installed screen.

    If the screen isn&#39;t running, it will be registered before it is run.

    Args:
        screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

    Raises:
        KeyError: If the named screen doesn&#39;t exist.

    Returns:
        Screen: A screen instance.
    &#34;&#34;&#34;
    if isinstance(screen, str):
        try:
            next_screen = self._installed_screens[screen]
        except KeyError:
            raise KeyError(f&#34;No screen called {screen!r} installed&#34;) from None
    else:
        next_screen = screen
    if not next_screen.is_running:
        self._register(self, next_screen)
    return next_screen</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_widget_at"><code class="name flex">
<span>def <span class="ident">get_widget_at</span></span>(<span>self, x:int, y:int) >tuple[Widget,Region]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the widget under the given coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>X Coord.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Y Coord.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[Widget, Region]</code></dt>
<dd>The widget and the widget's screen region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_widget_at(self, x: int, y: int) -&gt; tuple[Widget, Region]:
    &#34;&#34;&#34;Get the widget under the given coordinates.

    Args:
        x (int): X Coord.
        y (int): Y Coord.

    Returns:
        tuple[Widget, Region]: The widget and the widget&#39;s screen region.
    &#34;&#34;&#34;
    return self.screen.get_widget_at(x, y)</code></pre>
</details>
</dd>
<dt id="textual.app.App.install_screen"><code class="name flex">
<span>def <span class="ident">install_screen</span></span>(<span>self, screen:Screen, name:str|None=None) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Install a screen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>screen</code></strong> :&ensp;<code>Screen</code></dt>
<dd>Screen to install.</dd>
</dl>
<p>name (str | None, optional): Unique name of screen or None to auto-generate.
Defaults to None.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="textual.app.ScreenError" href="#textual.app.ScreenError">ScreenError</a></code></dt>
<dd>If the screen can't be installed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The name of the screen</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install_screen(self, screen: Screen, name: str | None = None) -&gt; str:
    &#34;&#34;&#34;Install a screen.

    Args:
        screen (Screen): Screen to install.
        name (str | None, optional): Unique name of screen or None to auto-generate.
            Defaults to None.

    Raises:
        ScreenError: If the screen can&#39;t be installed.

    Returns:
        str: The name of the screen
    &#34;&#34;&#34;
    if name is None:
        name = nanoid.generate()
    if name in self._installed_screens:
        raise ScreenError(f&#34;Can&#39;t install screen; {name!r} is already installed&#34;)
    if screen in self._installed_screens.values():
        raise ScreenError(
            &#34;Can&#39;t install screen; {screen!r} has already been installed&#34;
        )
    self._installed_screens[name] = screen
    self.get_screen(name)  # Ensures screen is running
    self.log.system(f&#34;{screen} INSTALLED name={name!r}&#34;)
    return name</code></pre>
</details>
</dd>
<dt id="textual.app.App.is_mounted"><code class="name flex">
<span>def <span class="ident">is_mounted</span></span>(<span>self, widget:Widget) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a widget is mounted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget</code></strong> :&ensp;<code>Widget</code></dt>
<dd>A widget.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True of the widget is mounted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_mounted(self, widget: Widget) -&gt; bool:
    &#34;&#34;&#34;Check if a widget is mounted.

    Args:
        widget (Widget): A widget.

    Returns:
        bool: True of the widget is mounted.
    &#34;&#34;&#34;
    return widget in self._registry</code></pre>
</details>
</dd>
<dt id="textual.app.App.is_screen_installed"><code class="name flex">
<span>def <span class="ident">is_screen_installed</span></span>(<span>self, screen:Screen|str) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a given screen has been installed.</p>
<h2 id="args">Args</h2>
<p>screen (Screen | str): Either a Screen object or screen name (the <code>name</code> argument when installed).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the screen is currently installed,</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_screen_installed(self, screen: Screen | str) -&gt; bool:
    &#34;&#34;&#34;Check if a given screen has been installed.

    Args:
        screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

    Returns:
        bool: True if the screen is currently installed,
    &#34;&#34;&#34;
    if isinstance(screen, str):
        return screen in self._installed_screens
    else:
        return screen in self._installed_screens.values()</code></pre>
</details>
</dd>
<dt id="textual.app.App.mount"><code class="name flex">
<span>def <span class="ident">mount</span></span>(<span>self, *anon_widgets:Widget, **widgets:Widget) ><a title="textual.widget.AwaitMount" href="widget.html#textual.widget.AwaitMount">AwaitMount</a></span>
</code></dt>
<dd>
<div class="desc"><p>Mount widgets. Widgets specified as positional args, or keywords args. If supplied
as keyword args they will be assigned an id of the key.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AwaitMount</code></dt>
<dd>An awaitable object that waits for widgets to be mounted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; AwaitMount:
    &#34;&#34;&#34;Mount widgets. Widgets specified as positional args, or keywords args. If supplied
    as keyword args they will be assigned an id of the key.

    Returns:
        AwaitMount: An awaitable object that waits for widgets to be mounted.

    &#34;&#34;&#34;
    mounted_widgets = self._register(self.screen, *anon_widgets, **widgets)
    return AwaitMount(mounted_widgets)</code></pre>
</details>
</dd>
<dt id="textual.app.App.mount_all"><code class="name flex">
<span>def <span class="ident">mount_all</span></span>(<span>self, widgets:Iterable[Widget]) ><a title="textual.widget.AwaitMount" href="widget.html#textual.widget.AwaitMount">AwaitMount</a></span>
</code></dt>
<dd>
<div class="desc"><p>Mount widgets from an iterable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widgets</code></strong> :&ensp;<code>Iterable[Widget]</code></dt>
<dd>An iterable of widgets.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount_all(self, widgets: Iterable[Widget]) -&gt; AwaitMount:
    &#34;&#34;&#34;Mount widgets from an iterable.

    Args:
        widgets (Iterable[Widget]): An iterable of widgets.
    &#34;&#34;&#34;
    mounted_widgets = list(widgets)
    for widget in mounted_widgets:
        self._register(self.screen, widget)
    return AwaitMount(mounted_widgets)</code></pre>
</details>
</dd>
<dt id="textual.app.App.panic"><code class="name flex">
<span>def <span class="ident">panic</span></span>(<span>self, *renderables:RenderableType) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Exits the app then displays a message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*renderables</code></strong> :&ensp;<code>RenderableType</code>, optional</dt>
<dd>Rich renderables to display on exit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panic(self, *renderables: RenderableType) -&gt; None:
    &#34;&#34;&#34;Exits the app then displays a message.

    Args:
        *renderables (RenderableType, optional): Rich renderables to display on exit.
    &#34;&#34;&#34;

    assert all(
        is_renderable(renderable) for renderable in renderables
    ), &#34;Can only call panic with strings or Rich renderables&#34;

    def render(renderable: RenderableType) -&gt; list[Segment]:
        &#34;&#34;&#34;Render a panic renderables.&#34;&#34;&#34;
        segments = list(self.console.render(renderable, self.console.options))
        return segments

    pre_rendered = [Segments(render(renderable)) for renderable in renderables]
    self._exit_renderables.extend(pre_rendered)
    self._close_messages_no_wait()</code></pre>
</details>
</dd>
<dt id="textual.app.App.pop_screen"><code class="name flex">
<span>def <span class="ident">pop_screen</span></span>(<span>self) ><a title="textual.screen.Screen" href="screen.html#textual.screen.Screen">Screen</a></span>
</code></dt>
<dd>
<div class="desc"><p>Pop the current screen from the stack, and switch to the previous screen.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Screen</code></dt>
<dd>The screen that was replaced.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_screen(self) -&gt; Screen:
    &#34;&#34;&#34;Pop the current screen from the stack, and switch to the previous screen.

    Returns:
        Screen: The screen that was replaced.
    &#34;&#34;&#34;
    screen_stack = self._screen_stack
    if len(screen_stack) &lt;= 1:
        raise ScreenStackError(
            &#34;Can&#39;t pop screen; there must be at least one screen on the stack&#34;
        )
    previous_screen = self._replace_screen(screen_stack.pop())
    self.screen._screen_resized(self.size)
    self.screen.post_message_no_wait(events.ScreenResume(self))
    self.log.system(f&#34;{self.screen} is active&#34;)
    return previous_screen</code></pre>
</details>
</dd>
<dt id="textual.app.App.push_screen"><code class="name flex">
<span>def <span class="ident">push_screen</span></span>(<span>self, screen:Screen|str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Push a new screen on the screen stack.</p>
<h2 id="args">Args</h2>
<p>screen (Screen | str): A Screen instance or the name of an installed screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_screen(self, screen: Screen | str) -&gt; None:
    &#34;&#34;&#34;Push a new screen on the screen stack.

    Args:
        screen (Screen | str): A Screen instance or the name of an installed screen.

    &#34;&#34;&#34;
    next_screen = self.get_screen(screen)
    self._screen_stack.append(next_screen)
    self.screen.post_message_no_wait(events.ScreenResume(self))
    self.log.system(f&#34;{self.screen} is current (PUSHED)&#34;)</code></pre>
</details>
</dd>
<dt id="textual.app.App.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, *, repaint:bool=True, layout:bool=False) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
    if self._screen_stack:
        self.screen.refresh(repaint=repaint, layout=layout)
    self.check_idle()</code></pre>
</details>
</dd>
<dt id="textual.app.App.refresh_css"><code class="name flex">
<span>def <span class="ident">refresh_css</span></span>(<span>self, animate:bool=True) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh CSS.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Also execute CSS animations. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_css(self, animate: bool = True) -&gt; None:
    &#34;&#34;&#34;Refresh CSS.

    Args:
        animate (bool, optional): Also execute CSS animations. Defaults to True.
    &#34;&#34;&#34;
    stylesheet = self.app.stylesheet
    stylesheet.set_variables(self.get_css_variables())
    stylesheet.reparse()
    stylesheet.update(self.app, animate=animate)
    self.screen._refresh_layout(self.size, full=True)</code></pre>
</details>
</dd>
<dt id="textual.app.App.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self) >Union[rich.console.ConsoleRenderable,rich.console.RichCast,str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self) -&gt; RenderableType:
    return Blank(self.styles.background)</code></pre>
</details>
</dd>
<dt id="textual.app.App.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, *, quit_after:float|None=None, headless:bool=False, press:Iterable[str]|None=None, screenshot:bool=False, screenshot_title:str|None=None) >ReturnType|None</span>
</code></dt>
<dd>
<div class="desc"><p>The main entry point for apps.</p>
<h2 id="args">Args</h2>
<dl>
<dt>quit_after (float | None, optional): Quit after a given number of seconds, or None</dt>
<dt>to run forever. Defaults to None.</dt>
<dt><strong><code>headless</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Run in "headless" mode (don't write to stdout).</dd>
<dt><strong><code>press</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>An iterable of keys to simulate being pressed.</dd>
<dt><strong><code>screenshot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Take a screenshot after pressing keys (svg data stored in self._screenshot). Defaults to False.</dd>
</dl>
<p>screenshot_title (str | None, optional): Title of screenshot, or None to use App title. Defaults to None.</p>
<h2 id="returns">Returns</h2>
<p>ReturnType | None: The return value specified in <code><a title="textual.app.App.exit" href="#textual.app.App.exit">App.exit()</a></code> or None if exit wasn't called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
    self,
    *,
    quit_after: float | None = None,
    headless: bool = False,
    press: Iterable[str] | None = None,
    screenshot: bool = False,
    screenshot_title: str | None = None,
) -&gt; ReturnType | None:
    &#34;&#34;&#34;The main entry point for apps.

    Args:
        quit_after (float | None, optional): Quit after a given number of seconds, or None
            to run forever. Defaults to None.
        headless (bool, optional): Run in &#34;headless&#34; mode (don&#39;t write to stdout).
        press (str, optional): An iterable of keys to simulate being pressed.
        screenshot (bool, optional): Take a screenshot after pressing keys (svg data stored in self._screenshot). Defaults to False.
        screenshot_title (str | None, optional): Title of screenshot, or None to use App title. Defaults to None.

    Returns:
        ReturnType | None: The return value specified in `App.exit` or None if exit wasn&#39;t called.
    &#34;&#34;&#34;

    if headless:
        self.features = cast(
            &#34;frozenset[FeatureFlag]&#34;, self.features.union({&#34;headless&#34;})
        )

    async def run_app() -&gt; None:
        if quit_after is not None:
            self.set_timer(quit_after, self.shutdown)
        if press is not None:
            app = self

            async def press_keys() -&gt; None:
                &#34;&#34;&#34;A task to send key events.&#34;&#34;&#34;
                assert press
                driver = app._driver
                assert driver is not None
                await asyncio.sleep(0.01)
                for key in press:
                    if key == &#34;_&#34;:
                        print(&#34;(pause 50ms)&#34;)
                        await asyncio.sleep(0.05)
                    elif key.startswith(&#34;wait:&#34;):
                        _, wait_ms = key.split(&#34;:&#34;)
                        print(f&#34;(pause {wait_ms}ms)&#34;)
                        await asyncio.sleep(float(wait_ms) / 1000)
                    else:
                        if len(key) == 1 and not key.isalnum():
                            key = (
                                unicodedata.name(key)
                                .lower()
                                .replace(&#34;-&#34;, &#34;_&#34;)
                                .replace(&#34; &#34;, &#34;_&#34;)
                            )
                        original_key = REPLACED_KEYS.get(key, key)
                        try:
                            char = unicodedata.lookup(
                                original_key.upper().replace(&#34;_&#34;, &#34; &#34;)
                            )
                        except KeyError:
                            char = key if len(key) == 1 else None
                        print(f&#34;press {key!r} (char={char!r})&#34;)
                        key_event = events.Key(self, key, char)
                        driver.send_event(key_event)
                        await asyncio.sleep(0.01)

                await app._animator.wait_for_idle()

                if screenshot:
                    self._screenshot = self.export_screenshot(
                        title=screenshot_title
                    )
                await self.shutdown()

            async def press_keys_task():
                &#34;&#34;&#34;Press some keys in the background.&#34;&#34;&#34;
                asyncio.create_task(press_keys())

            await self._process_messages(ready_callback=press_keys_task)
        else:
            await self._process_messages()

    if _ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED:
        # N.B. This doesn&#39;t work with Python&lt;3.10, as we end up with 2 event loops:
        asyncio.run(run_app())
    else:
        # However, this works with Python&lt;3.10:
        event_loop = asyncio.get_event_loop()
        event_loop.run_until_complete(run_app())

    return self._return_value</code></pre>
</details>
</dd>
<dt id="textual.app.App.save_screenshot"><code class="name flex">
<span>def <span class="ident">save_screenshot</span></span>(<span>self, filename:str|None=None, path:str='./', time_format:str='%Y-%m-%d %X %f') >str</span>
</code></dt>
<dd>
<div class="desc"><p>Save an SVG screenshot of the current screen.</p>
<h2 id="args">Args</h2>
<dl>
<dt>filename (str | None, optional): Filename of SVG screenshot, or None to auto-generate</dt>
<dt>a filename with the date and time. Defaults to None.</dt>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to directory for output. Defaults to current working directory.</dd>
<dt><strong><code>time_format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Time format to use if filename is None. Defaults to "%Y-%m-%d %X %f".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Filename of screenshot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_screenshot(
    self,
    filename: str | None = None,
    path: str = &#34;./&#34;,
    time_format: str = &#34;%Y-%m-%d %X %f&#34;,
) -&gt; str:
    &#34;&#34;&#34;Save an SVG screenshot of the current screen.

    Args:
        filename (str | None, optional): Filename of SVG screenshot, or None to auto-generate
            a filename with the date and time. Defaults to None.
        path (str, optional): Path to directory for output. Defaults to current working directory.
        time_format (str, optional): Time format to use if filename is None. Defaults to &#34;%Y-%m-%d %X %f&#34;.

    Returns:
        str: Filename of screenshot.
    &#34;&#34;&#34;
    if filename is None:
        svg_filename = (
            f&#34;{self.title.lower()} {datetime.now().strftime(time_format)}.svg&#34;
        )
        svg_filename = svg_filename.replace(&#34;/&#34;, &#34;_&#34;).replace(&#34;\\&#34;, &#34;_&#34;)
    else:
        svg_filename = filename
    svg_path = os.path.expanduser(os.path.join(path, svg_filename))
    screenshot_svg = self.export_screenshot()
    with open(svg_path, &#34;w&#34;) as svg_file:
        svg_file.write(screenshot_svg)
    return svg_path</code></pre>
</details>
</dd>
<dt id="textual.app.App.set_focus"><code class="name flex">
<span>def <span class="ident">set_focus</span></span>(<span>self, widget:Widget|None, scroll_visible:bool=True) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Focus (or unfocus) a widget. A focused widget will receive key events first.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget</code></strong> :&ensp;<code>Widget</code></dt>
<dd>Widget to focus.</dd>
<dt><strong><code>scroll_visible</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Scroll widget in to view.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -&gt; None:
    &#34;&#34;&#34;Focus (or unfocus) a widget. A focused widget will receive key events first.

    Args:
        widget (Widget): Widget to focus.
        scroll_visible (bool, optional): Scroll widget in to view.
    &#34;&#34;&#34;
    self.screen.set_focus(widget, scroll_visible)</code></pre>
</details>
</dd>
<dt id="textual.app.App.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self):
    await self._disconnect_devtools()
    driver = self._driver
    if driver is not None:
        driver.disable_input()
    await self._close_messages()</code></pre>
</details>
</dd>
<dt id="textual.app.App.switch_screen"><code class="name flex">
<span>def <span class="ident">switch_screen</span></span>(<span>self, screen:Screen|str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Switch to another screen by replacing the top of the screen stack with a new screen.</p>
<h2 id="args">Args</h2>
<p>screen (Screen | str): Either a Screen object or screen name (the <code>name</code> argument when installed).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch_screen(self, screen: Screen | str) -&gt; None:
    &#34;&#34;&#34;Switch to another screen by replacing the top of the screen stack with a new screen.

    Args:
        screen (Screen | str): Either a Screen object or screen name (the `name` argument when installed).

    &#34;&#34;&#34;
    if self.screen is not screen:
        self._replace_screen(self._screen_stack.pop())
        next_screen = self.get_screen(screen)
        self._screen_stack.append(next_screen)
        self.screen.post_message_no_wait(events.ScreenResume(self))
        self.log.system(f&#34;{self.screen} is current (SWITCHED)&#34;)</code></pre>
</details>
</dd>
<dt id="textual.app.App.uninstall_screen"><code class="name flex">
<span>def <span class="ident">uninstall_screen</span></span>(<span>self, screen:Screen|str) >str|None</span>
</code></dt>
<dd>
<div class="desc"><p>Uninstall a screen. If the screen was not previously installed then this
method is a null-op.</p>
<h2 id="args">Args</h2>
<p>screen (Screen | str): The screen to uninstall or the name of a installed screen.</p>
<h2 id="returns">Returns</h2>
<p>str | None: The name of the screen that was uninstalled, or None if no screen was uninstalled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninstall_screen(self, screen: Screen | str) -&gt; str | None:
    &#34;&#34;&#34;Uninstall a screen. If the screen was not previously installed then this
    method is a null-op.

    Args:
        screen (Screen | str): The screen to uninstall or the name of a installed screen.

    Returns:
        str | None: The name of the screen that was uninstalled, or None if no screen was uninstalled.
    &#34;&#34;&#34;
    if isinstance(screen, str):
        if screen not in self._installed_screens:
            return None
        uninstall_screen = self._installed_screens[screen]
        if uninstall_screen in self._screen_stack:
            raise ScreenStackError(&#34;Can&#39;t uninstall screen in screen stack&#34;)
        del self._installed_screens[screen]
        self.log.system(f&#34;{uninstall_screen} UNINSTALLED name={screen!r}&#34;)
        return screen
    else:
        if screen in self._screen_stack:
            raise ScreenStackError(&#34;Can&#39;t uninstall screen in screen stack&#34;)
        for name, installed_screen in self._installed_screens.items():
            if installed_screen is screen:
                self._installed_screens.pop(name)
                self.log.system(f&#34;{screen} UNINSTALLED name={name!r}&#34;)
                return name
    return None</code></pre>
</details>
</dd>
<dt id="textual.app.App.update_styles"><code class="name flex">
<span>def <span class="ident">update_styles</span></span>(<span>self, node:DOMNode|None=None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Request update of styles.</p>
<p>Should be called whenever CSS classes / pseudo classes change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_styles(self, node: DOMNode | None = None) -&gt; None:
    &#34;&#34;&#34;Request update of styles.

    Should be called whenever CSS classes / pseudo classes change.

    &#34;&#34;&#34;
    self._require_stylesheet_update.add(self.screen if node is None else node)
    self.check_idle()</code></pre>
</details>
</dd>
<dt id="textual.app.App.watch_dark"><code class="name flex">
<span>def <span class="ident">watch_dark</span></span>(<span>self, dark:bool) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Watches the dark bool.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_dark(self, dark: bool) -&gt; None:
    &#34;&#34;&#34;Watches the dark bool.&#34;&#34;&#34;
    self.set_class(dark, &#34;-dark-mode&#34;)
    self.set_class(not dark, &#34;-light-mode&#34;)
    self.refresh_css()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></b></code>:
<ul class="hlist">
<li><code><a title="textual.dom.DOMNode.add_class" href="dom.html#textual.dom.DOMNode.add_class">add_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.ancestors" href="dom.html#textual.dom.DOMNode.ancestors">ancestors</a></code></li>
<li><code><a title="textual.dom.DOMNode.app" href="message_pump.html#textual.message_pump.MessagePump.app">app</a></code></li>
<li><code><a title="textual.dom.DOMNode.background_colors" href="dom.html#textual.dom.DOMNode.background_colors">background_colors</a></code></li>
<li><code><a title="textual.dom.DOMNode.call_later" href="message_pump.html#textual.message_pump.MessagePump.call_later">call_later</a></code></li>
<li><code><a title="textual.dom.DOMNode.check_idle" href="message_pump.html#textual.message_pump.MessagePump.check_idle">check_idle</a></code></li>
<li><code><a title="textual.dom.DOMNode.classes" href="dom.html#textual.dom.DOMNode.classes">classes</a></code></li>
<li><code><a title="textual.dom.DOMNode.colors" href="dom.html#textual.dom.DOMNode.colors">colors</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier" href="dom.html#textual.dom.DOMNode.css_identifier">css_identifier</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier_styled" href="dom.html#textual.dom.DOMNode.css_identifier_styled">css_identifier_styled</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_path_nodes" href="dom.html#textual.dom.DOMNode.css_path_nodes">css_path_nodes</a></code></li>
<li><code><a title="textual.dom.DOMNode.disable_messages" href="message_pump.html#textual.message_pump.MessagePump.disable_messages">disable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.dispatch_key" href="message_pump.html#textual.message_pump.MessagePump.dispatch_key">dispatch_key</a></code></li>
<li><code><a title="textual.dom.DOMNode.display" href="dom.html#textual.dom.DOMNode.display">display</a></code></li>
<li><code><a title="textual.dom.DOMNode.displayed_children" href="dom.html#textual.dom.DOMNode.displayed_children">displayed_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.emit" href="message_pump.html#textual.message_pump.MessagePump.emit">emit</a></code></li>
<li><code><a title="textual.dom.DOMNode.emit_no_wait" href="message_pump.html#textual.message_pump.MessagePump.emit_no_wait">emit_no_wait</a></code></li>
<li><code><a title="textual.dom.DOMNode.enable_messages" href="message_pump.html#textual.message_pump.MessagePump.enable_messages">enable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_component_styles" href="dom.html#textual.dom.DOMNode.get_component_styles">get_component_styles</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_default_css" href="dom.html#textual.dom.DOMNode.get_default_css">get_default_css</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_pseudo_classes" href="dom.html#textual.dom.DOMNode.get_pseudo_classes">get_pseudo_classes</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_class" href="dom.html#textual.dom.DOMNode.has_class">has_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_pseudo_class" href="dom.html#textual.dom.DOMNode.has_pseudo_class">has_pseudo_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.id" href="dom.html#textual.dom.DOMNode.id">id</a></code></li>
<li><code><a title="textual.dom.DOMNode.log" href="message_pump.html#textual.message_pump.MessagePump.log">log</a></code></li>
<li><code><a title="textual.dom.DOMNode.on_event" href="message_pump.html#textual.message_pump.MessagePump.on_event">on_event</a></code></li>
<li><code><a title="textual.dom.DOMNode.parent" href="dom.html#textual.dom.DOMNode.parent">parent</a></code></li>
<li><code><a title="textual.dom.DOMNode.post_message" href="message_pump.html#textual.message_pump.MessagePump.post_message">post_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.post_message_no_wait" href="message_pump.html#textual.message_pump.MessagePump.post_message_no_wait">post_message_no_wait</a></code></li>
<li><code><a title="textual.dom.DOMNode.pseudo_classes" href="dom.html#textual.dom.DOMNode.pseudo_classes">pseudo_classes</a></code></li>
<li><code><a title="textual.dom.DOMNode.query" href="dom.html#textual.dom.DOMNode.query">query</a></code></li>
<li><code><a title="textual.dom.DOMNode.query_one" href="dom.html#textual.dom.DOMNode.query_one">query_one</a></code></li>
<li><code><a title="textual.dom.DOMNode.remove_class" href="dom.html#textual.dom.DOMNode.remove_class">remove_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.reset_styles" href="dom.html#textual.dom.DOMNode.reset_styles">reset_styles</a></code></li>
<li><code><a title="textual.dom.DOMNode.rich_style" href="dom.html#textual.dom.DOMNode.rich_style">rich_style</a></code></li>
<li><code><a title="textual.dom.DOMNode.set_class" href="dom.html#textual.dom.DOMNode.set_class">set_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.set_interval" href="message_pump.html#textual.message_pump.MessagePump.set_interval">set_interval</a></code></li>
<li><code><a title="textual.dom.DOMNode.set_styles" href="dom.html#textual.dom.DOMNode.set_styles">set_styles</a></code></li>
<li><code><a title="textual.dom.DOMNode.set_timer" href="message_pump.html#textual.message_pump.MessagePump.set_timer">set_timer</a></code></li>
<li><code><a title="textual.dom.DOMNode.text_style" href="dom.html#textual.dom.DOMNode.text_style">text_style</a></code></li>
<li><code><a title="textual.dom.DOMNode.toggle_class" href="dom.html#textual.dom.DOMNode.toggle_class">toggle_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.tree" href="dom.html#textual.dom.DOMNode.tree">tree</a></code></li>
<li><code><a title="textual.dom.DOMNode.visible" href="dom.html#textual.dom.DOMNode.visible">visible</a></code></li>
<li><code><a title="textual.dom.DOMNode.walk_children" href="dom.html#textual.dom.DOMNode.walk_children">walk_children</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="textual.app.AppError"><code class="flex name class">
<span>class <span class="ident">AppError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textual.app.ScreenError"><code class="flex name class">
<span>class <span class="ident">ScreenError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScreenError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textual.app.ScreenStackError" href="#textual.app.ScreenStackError">ScreenStackError</a></li>
</ul>
</dd>
<dt id="textual.app.ScreenStackError"><code class="flex name class">
<span>class <span class="ident">ScreenStackError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when attempting to pop the last screen from the stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScreenStackError(ScreenError):
    &#34;&#34;&#34;Raised when attempting to pop the last screen from the stack.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textual.app.ScreenError" href="#textual.app.ScreenError">ScreenError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual" href="index.html">textual</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.app.ActionError" href="#textual.app.ActionError">ActionError</a></code></h4>
</li>
<li>
<h4><code><a title="textual.app.App" href="#textual.app.App">App</a></code></h4>
<ul class="">
<li><code><a title="textual.app.App.CSS" href="#textual.app.App.CSS">CSS</a></code></li>
<li><code><a title="textual.app.App.CSS_PATH" href="#textual.app.App.CSS_PATH">CSS_PATH</a></code></li>
<li><code><a title="textual.app.App.DEFAULT_CSS" href="#textual.app.App.DEFAULT_CSS">DEFAULT_CSS</a></code></li>
<li><code><a title="textual.app.App.SCREENS" href="#textual.app.App.SCREENS">SCREENS</a></code></li>
<li><code><a title="textual.app.App.SUB_TITLE" href="#textual.app.App.SUB_TITLE">SUB_TITLE</a></code></li>
<li><code><a title="textual.app.App.TITLE" href="#textual.app.App.TITLE">TITLE</a></code></li>
<li><code><a title="textual.app.App.action" href="#textual.app.App.action">action</a></code></li>
<li><code><a title="textual.app.App.action_add_class_" href="#textual.app.App.action_add_class_">action_add_class_</a></code></li>
<li><code><a title="textual.app.App.action_back" href="#textual.app.App.action_back">action_back</a></code></li>
<li><code><a title="textual.app.App.action_bang" href="#textual.app.App.action_bang">action_bang</a></code></li>
<li><code><a title="textual.app.App.action_bell" href="#textual.app.App.action_bell">action_bell</a></code></li>
<li><code><a title="textual.app.App.action_check_bindings" href="#textual.app.App.action_check_bindings">action_check_bindings</a></code></li>
<li><code><a title="textual.app.App.action_focus" href="#textual.app.App.action_focus">action_focus</a></code></li>
<li><code><a title="textual.app.App.action_pop_screen" href="#textual.app.App.action_pop_screen">action_pop_screen</a></code></li>
<li><code><a title="textual.app.App.action_push_screen" href="#textual.app.App.action_push_screen">action_push_screen</a></code></li>
<li><code><a title="textual.app.App.action_quit" href="#textual.app.App.action_quit">action_quit</a></code></li>
<li><code><a title="textual.app.App.action_remove_class_" href="#textual.app.App.action_remove_class_">action_remove_class_</a></code></li>
<li><code><a title="textual.app.App.action_screenshot" href="#textual.app.App.action_screenshot">action_screenshot</a></code></li>
<li><code><a title="textual.app.App.action_switch_screen" href="#textual.app.App.action_switch_screen">action_switch_screen</a></code></li>
<li><code><a title="textual.app.App.action_toggle_class" href="#textual.app.App.action_toggle_class">action_toggle_class</a></code></li>
<li><code><a title="textual.app.App.action_toggle_dark" href="#textual.app.App.action_toggle_dark">action_toggle_dark</a></code></li>
<li><code><a title="textual.app.App.animate" href="#textual.app.App.animate">animate</a></code></li>
<li><code><a title="textual.app.App.animator" href="#textual.app.App.animator">animator</a></code></li>
<li><code><a title="textual.app.App.bell" href="#textual.app.App.bell">bell</a></code></li>
<li><code><a title="textual.app.App.bind" href="#textual.app.App.bind">bind</a></code></li>
<li><code><a title="textual.app.App.capture_mouse" href="#textual.app.App.capture_mouse">capture_mouse</a></code></li>
<li><code><a title="textual.app.App.check_bindings" href="#textual.app.App.check_bindings">check_bindings</a></code></li>
<li><code><a title="textual.app.App.compose" href="#textual.app.App.compose">compose</a></code></li>
<li><code><a title="textual.app.App.dark" href="#textual.app.App.dark">dark</a></code></li>
<li><code><a title="textual.app.App.debug" href="#textual.app.App.debug">debug</a></code></li>
<li><code><a title="textual.app.App.exit" href="#textual.app.App.exit">exit</a></code></li>
<li><code><a title="textual.app.App.export_screenshot" href="#textual.app.App.export_screenshot">export_screenshot</a></code></li>
<li><code><a title="textual.app.App.fatal_error" href="#textual.app.App.fatal_error">fatal_error</a></code></li>
<li><code><a title="textual.app.App.focused" href="#textual.app.App.focused">focused</a></code></li>
<li><code><a title="textual.app.App.get_child" href="#textual.app.App.get_child">get_child</a></code></li>
<li><code><a title="textual.app.App.get_css_variables" href="#textual.app.App.get_css_variables">get_css_variables</a></code></li>
<li><code><a title="textual.app.App.get_driver_class" href="#textual.app.App.get_driver_class">get_driver_class</a></code></li>
<li><code><a title="textual.app.App.get_screen" href="#textual.app.App.get_screen">get_screen</a></code></li>
<li><code><a title="textual.app.App.get_widget_at" href="#textual.app.App.get_widget_at">get_widget_at</a></code></li>
<li><code><a title="textual.app.App.install_screen" href="#textual.app.App.install_screen">install_screen</a></code></li>
<li><code><a title="textual.app.App.is_headless" href="#textual.app.App.is_headless">is_headless</a></code></li>
<li><code><a title="textual.app.App.is_mounted" href="#textual.app.App.is_mounted">is_mounted</a></code></li>
<li><code><a title="textual.app.App.is_screen_installed" href="#textual.app.App.is_screen_installed">is_screen_installed</a></code></li>
<li><code><a title="textual.app.App.is_transparent" href="#textual.app.App.is_transparent">is_transparent</a></code></li>
<li><code><a title="textual.app.App.mount" href="#textual.app.App.mount">mount</a></code></li>
<li><code><a title="textual.app.App.mount_all" href="#textual.app.App.mount_all">mount_all</a></code></li>
<li><code><a title="textual.app.App.namespace_bindings" href="#textual.app.App.namespace_bindings">namespace_bindings</a></code></li>
<li><code><a title="textual.app.App.panic" href="#textual.app.App.panic">panic</a></code></li>
<li><code><a title="textual.app.App.pop_screen" href="#textual.app.App.pop_screen">pop_screen</a></code></li>
<li><code><a title="textual.app.App.push_screen" href="#textual.app.App.push_screen">push_screen</a></code></li>
<li><code><a title="textual.app.App.refresh" href="#textual.app.App.refresh">refresh</a></code></li>
<li><code><a title="textual.app.App.refresh_css" href="#textual.app.App.refresh_css">refresh_css</a></code></li>
<li><code><a title="textual.app.App.render" href="#textual.app.App.render">render</a></code></li>
<li><code><a title="textual.app.App.run" href="#textual.app.App.run">run</a></code></li>
<li><code><a title="textual.app.App.save_screenshot" href="#textual.app.App.save_screenshot">save_screenshot</a></code></li>
<li><code><a title="textual.app.App.screen" href="#textual.app.App.screen">screen</a></code></li>
<li><code><a title="textual.app.App.screen_stack" href="#textual.app.App.screen_stack">screen_stack</a></code></li>
<li><code><a title="textual.app.App.set_focus" href="#textual.app.App.set_focus">set_focus</a></code></li>
<li><code><a title="textual.app.App.shutdown" href="#textual.app.App.shutdown">shutdown</a></code></li>
<li><code><a title="textual.app.App.size" href="#textual.app.App.size">size</a></code></li>
<li><code><a title="textual.app.App.sub_title" href="#textual.app.App.sub_title">sub_title</a></code></li>
<li><code><a title="textual.app.App.switch_screen" href="#textual.app.App.switch_screen">switch_screen</a></code></li>
<li><code><a title="textual.app.App.title" href="#textual.app.App.title">title</a></code></li>
<li><code><a title="textual.app.App.uninstall_screen" href="#textual.app.App.uninstall_screen">uninstall_screen</a></code></li>
<li><code><a title="textual.app.App.update_styles" href="#textual.app.App.update_styles">update_styles</a></code></li>
<li><code><a title="textual.app.App.watch_dark" href="#textual.app.App.watch_dark">watch_dark</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.app.AppError" href="#textual.app.AppError">AppError</a></code></h4>
</li>
<li>
<h4><code><a title="textual.app.ScreenError" href="#textual.app.ScreenError">ScreenError</a></code></h4>
</li>
<li>
<h4><code><a title="textual.app.ScreenStackError" href="#textual.app.ScreenStackError">ScreenStackError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>