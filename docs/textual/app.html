<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.app API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.app</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import asyncio
from datetime import datetime
import inspect
import io
import os
import platform
import sys
import warnings
from contextlib import redirect_stdout
from pathlib import PurePath
from time import perf_counter
from typing import (
    Any,
    Generic,
    Iterable,
    Iterator,
    TextIO,
    Type,
    TypeVar,
    TYPE_CHECKING,
)

if sys.version_info &gt;= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal  # pragma: no cover

import rich
import rich.repr
from rich.console import Console, RenderableType
from rich.measure import Measurement
from rich.protocol import is_renderable
from rich.segment import Segments
from rich.style import Style
from rich.traceback import Traceback

from . import actions
from . import events
from . import log
from . import messages
from ._animator import Animator
from ._callback import invoke
from ._context import active_app
from ._event_broker import extract_handler_actions, NoHandler
from ._timer import Timer
from .binding import Bindings, NoBinding
from .css.stylesheet import Stylesheet
from .design import ColorSystem
from .devtools.client import DevtoolsClient, DevtoolsConnectionError, DevtoolsLog
from .devtools.redirect_output import StdoutRedirector
from .dom import DOMNode
from .driver import Driver
from .features import parse_features, FeatureFlag
from .file_monitor import FileMonitor
from .geometry import Offset, Region, Size
from .layouts.dock import Dock
from .message_pump import MessagePump
from .reactive import Reactive
from .screen import Screen
from .widget import Widget

if TYPE_CHECKING:
    from .css.query import DOMQuery

PLATFORM = platform.system()
WINDOWS = PLATFORM == &#34;Windows&#34;

# asyncio will warn against resources not being cleared
warnings.simplefilter(&#34;always&#34;, ResourceWarning)

# `asyncio.get_event_loop()` is deprecated since Python 3.10:
_ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED = sys.version_info &gt;= (3, 10, 0)

LayoutDefinition = &#34;dict[str, Any]&#34;


DEFAULT_COLORS = ColorSystem(
    primary=&#34;#406e8e&#34;,
    secondary=&#34;#ffa62b&#34;,
    warning=&#34;#ffa62b&#34;,
    error=&#34;#ba3c5b&#34;,
    success=&#34;#6d9f71&#34;,
    accent=&#34;#ffa62b&#34;,
    system=&#34;#5a4599&#34;,
    dark_surface=&#34;#292929&#34;,
)

ComposeResult = Iterable[Widget]


class AppError(Exception):
    pass


class ActionError(Exception):
    pass


ReturnType = TypeVar(&#34;ReturnType&#34;)


@rich.repr.auto
class App(Generic[ReturnType], DOMNode):
    &#34;&#34;&#34;The base class for Textual Applications&#34;&#34;&#34;

    CSS = &#34;&#34;&#34;

    &#34;&#34;&#34;

    CSS_PATH: str | None = None

    def __init__(
        self,
        driver_class: Type[Driver] | None = None,
        log_path: str | PurePath = &#34;&#34;,
        log_verbosity: int = 1,
        log_color_system: Literal[
            &#34;auto&#34;, &#34;standard&#34;, &#34;256&#34;, &#34;truecolor&#34;, &#34;windows&#34;
        ] = &#34;auto&#34;,
        title: str = &#34;Textual Application&#34;,
        css_path: str | PurePath | None = None,
        watch_css: bool = False,
    ):
        &#34;&#34;&#34;Textual application base class

        Args:
            driver_class (Type[Driver] | None, optional): Driver class or ``None`` to auto-detect. Defaults to None.
            log_path (str | PurePath, optional): Path to log file, or &#34;&#34; to disable. Defaults to &#34;&#34;.
            log_verbosity (int, optional): Log verbosity from 0-3. Defaults to 1.
            title (str, optional): Default title of the application. Defaults to &#34;Textual Application&#34;.
            css_path (str | PurePath | None, optional): Path to CSS or ``None`` for no CSS file. Defaults to None.
            watch_css (bool, optional): Watch CSS for changes. Defaults to False.
        &#34;&#34;&#34;
        # N.B. This must be done *before* we call the parent constructor, because MessagePump&#39;s
        # constructor instantiates a `asyncio.PriorityQueue` and in Python versions older than 3.10
        # this will create some first references to an asyncio loop.
        _init_uvloop()

        self.features: frozenset[FeatureFlag] = parse_features(os.getenv(&#34;TEXTUAL&#34;, &#34;&#34;))

        self.console = Console(
            file=(open(os.devnull, &#34;wt&#34;) if self.is_headless else sys.__stdout__),
            markup=True,
            highlight=False,
            emoji=False,
        )
        self.error_console = Console(markup=False, stderr=True)
        self.driver_class = driver_class or self.get_driver_class()
        self._title = title
        self._screen_stack: list[Screen] = []
        self._sync_available = (
            os.environ.get(&#34;TERM_PROGRAM&#34;, &#34;&#34;) != &#34;Apple_Terminal&#34; and not WINDOWS
        )

        self.focused: Widget | None = None
        self.mouse_over: Widget | None = None
        self.mouse_captured: Widget | None = None
        self._driver: Driver | None = None
        self._exit_renderables: list[RenderableType] = []

        self._docks: list[Dock] = []
        self._action_targets = {&#34;app&#34;, &#34;screen&#34;}
        self._animator = Animator(self)
        self.animate = self._animator.bind(self)
        self.mouse_position = Offset(0, 0)
        self.bindings = Bindings()
        self._title = title

        self._log_console: Console | None = None
        self._log_file: TextIO | None = None
        if log_path:
            self._log_file = open(log_path, &#34;wt&#34;)
            self._log_console = Console(
                file=self._log_file,
                color_system=log_color_system,
                markup=False,
                emoji=False,
                highlight=False,
                width=100,
            )

        self.log_verbosity = log_verbosity

        self.bindings.bind(&#34;ctrl+c&#34;, &#34;quit&#34;, show=False, allow_forward=False)
        self._refresh_required = False

        self.design = DEFAULT_COLORS

        self.stylesheet = Stylesheet(variables=self.get_css_variables())
        self._require_styles_update = False
        self.css_path = css_path or self.CSS_PATH

        self.registry: set[MessagePump] = set()
        self.devtools = DevtoolsClient()
        self._return_value: ReturnType | None = None

        self.css_monitor = (
            FileMonitor(css_path, self._on_css_change)
            if ((watch_css or self.debug) and css_path)
            else None
        )

        super().__init__()

    def __init_subclass__(cls, css_path: str | None = None) -&gt; None:
        super().__init_subclass__()
        cls.CSS_PATH = css_path

    title: Reactive[str] = Reactive(&#34;Textual&#34;)
    sub_title: Reactive[str] = Reactive(&#34;&#34;)
    background: Reactive[str] = Reactive(&#34;black&#34;)
    dark = Reactive(False)

    @property
    def devtools_enabled(self) -&gt; bool:
        &#34;&#34;&#34;Check if devtools are enabled.&#34;&#34;&#34;
        return &#34;devtools&#34; in self.features

    @property
    def debug(self) -&gt; bool:
        &#34;&#34;&#34;Check if debug mode is enabled.&#34;&#34;&#34;
        return &#34;debug&#34; in self.features

    @property
    def is_headless(self) -&gt; bool:
        &#34;&#34;&#34;Check if the app is running in &#39;headless&#39; mode.&#34;&#34;&#34;
        return &#34;headless&#34; in self.features

    def exit(self, result: ReturnType | None = None) -&gt; None:
        &#34;&#34;&#34;Exit the app, and return the supplied result.

        Args:
            result (ReturnType | None, optional): Return value. Defaults to None.
        &#34;&#34;&#34;
        self._return_value = result
        self.close_messages_no_wait()

    @property
    def focus_chain(self) -&gt; list[Widget]:
        &#34;&#34;&#34;Get widgets that may receive focus, in focus order.&#34;&#34;&#34;
        widgets: list[Widget] = []
        add_widget = widgets.append
        root = self.screen
        stack: list[Iterator[Widget]] = [iter(root.focusable_children)]
        pop = stack.pop
        push = stack.append

        while stack:
            node = next(stack[-1], None)
            if node is None:
                pop()
            else:
                if node.is_container and node.can_focus_children:
                    push(iter(node.focusable_children))
                else:
                    if node.can_focus:
                        add_widget(node)

        return widgets

    def _set_active(self) -&gt; None:
        &#34;&#34;&#34;Set this app to be the currently active app.&#34;&#34;&#34;
        active_app.set(self)

    def _move_focus(self, direction: int = 0) -&gt; Widget | None:
        &#34;&#34;&#34;Move the focus in the given direction.

        Args:
            direction (int, optional): 1 to move forward, -1 to move backward, or
                0 to highlight the current focus.

        Returns:
            Widget | None: Newly focused widget, or None for no focus.
        &#34;&#34;&#34;
        focusable_widgets = self.focus_chain

        if not focusable_widgets:
            # Nothing focusable, so nothing to do
            return self.focused
        if self.focused is None:
            # Nothing currently focused, so focus the first one
            self.set_focus(focusable_widgets[0])
        else:
            try:
                # Find the index of the currently focused widget
                current_index = focusable_widgets.index(self.focused)
            except ValueError:
                # Focused widget was removed in the interim, start again
                self.set_focus(focusable_widgets[0])
            else:
                # Only move the focus if we are currently showing the focus
                if direction:
                    current_index = (current_index + direction) % len(focusable_widgets)
                    self.set_focus(focusable_widgets[current_index])

        return self.focused

    def show_focus(self) -&gt; Widget | None:
        &#34;&#34;&#34;Highlight the currently focused widget.

        Returns:
            Widget | None: Focused widget, or None for no focus.
        &#34;&#34;&#34;
        return self._move_focus(0)

    def focus_next(self) -&gt; Widget | None:
        &#34;&#34;&#34;Focus the next widget.

        Returns:
            Widget | None: Newly focused widget, or None for no focus.
        &#34;&#34;&#34;
        return self._move_focus(1)

    def focus_previous(self) -&gt; Widget | None:
        &#34;&#34;&#34;Focus the previous widget.

        Returns:
            Widget | None: Newly focused widget, or None for no focus.
        &#34;&#34;&#34;
        return self._move_focus(-1)

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def get_css_variables(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Get a mapping of variables used to pre-populate CSS.

        Returns:
            dict[str, str]: A mapping of variable name to value.
        &#34;&#34;&#34;
        variables = self.design.generate(self.dark)
        return variables

    def watch_dark(self, dark: bool) -&gt; None:
        &#34;&#34;&#34;Watches the dark bool.&#34;&#34;&#34;
        self.screen.dark = dark
        self.refresh_css()

    def get_driver_class(self) -&gt; Type[Driver]:
        &#34;&#34;&#34;Get a driver class for this platform.

        Called by the constructor.

        Returns:
            Driver: A Driver class which manages input and display.
        &#34;&#34;&#34;
        driver_class: Type[Driver]
        if WINDOWS:
            from .drivers.windows_driver import WindowsDriver

            driver_class = WindowsDriver
        else:
            from .drivers.linux_driver import LinuxDriver

            driver_class = LinuxDriver
        return driver_class

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;title&#34;, self.title

    @property
    def animator(self) -&gt; Animator:
        return self._animator

    @property
    def screen(self) -&gt; Screen:
        return self._screen_stack[-1]

    @property
    def css_type(self) -&gt; str:
        return &#34;app&#34;

    @property
    def size(self) -&gt; Size:
        return Size(*self.console.size)

    def log(
        self,
        *objects: Any,
        verbosity: int = 1,
        _textual_calling_frame: inspect.FrameInfo | None = None,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;Write to logs.

        Args:
            *objects (Any): Positional arguments are converted to string and written to logs.
            verbosity (int, optional): Verbosity level 0-3. Defaults to 1.
            _textual_calling_frame (inspect.FrameInfo | None): The frame info to include in
                the log message sent to the devtools server.
        &#34;&#34;&#34;
        if verbosity &gt; self.log_verbosity:
            return

        if self.devtools.is_connected and not _textual_calling_frame:
            _textual_calling_frame = inspect.stack()[1]

        try:
            if len(objects) == 1 and not kwargs:
                if self._log_console is not None:
                    self._log_console.print(objects[0])
                if self.devtools.is_connected:
                    self.devtools.log(
                        DevtoolsLog(objects, caller=_textual_calling_frame)
                    )
            else:
                output = &#34; &#34;.join(str(arg) for arg in objects)
                if kwargs:
                    key_values = &#34; &#34;.join(
                        f&#34;{key}={value!r}&#34; for key, value in kwargs.items()
                    )
                    output = f&#34;{output} {key_values}&#34; if output else key_values
                if self._log_console is not None:
                    self._log_console.print(output, soft_wrap=True)
                if self.devtools.is_connected:
                    self.devtools.log(
                        DevtoolsLog(output, caller=_textual_calling_frame)
                    )
        except Exception as error:
            self.on_exception(error)

    def action_screenshot(self, path: str | None = None) -&gt; None:
        &#34;&#34;&#34;Action to save a screenshot.&#34;&#34;&#34;
        self.save_screenshot(path)

    def export_screenshot(self) -&gt; str:
        &#34;&#34;&#34;Export a SVG screenshot of the current screen.

        Args:
            path (str | None, optional): Path of the SVG to save, or None to
                generate a path automatically. Defaults to None.
        &#34;&#34;&#34;

        console = Console(
            width=self.console.width,
            height=self.console.height,
            file=io.StringIO(),
            force_terminal=True,
            color_system=&#34;truecolor&#34;,
            record=True,
        )
        console.print(self.screen._compositor.render(full=True))
        return console.export_svg(title=self.title)

    def save_screenshot(self, path: str | None = None) -&gt; str:
        &#34;&#34;&#34;Save a screenshot of the current screen.

        Args:
            path (str | None, optional): Path to SVG to save or None to pick
                a filename automatically. Defaults to None.

        Returns:
            str: Filename of screenshot.
        &#34;&#34;&#34;
        self.bell()
        if path is None:
            svg_path = f&#34;{self.title.lower()}_{datetime.now().isoformat()}.svg&#34;
            svg_path = svg_path.replace(&#34;/&#34;, &#34;_&#34;).replace(&#34;\\&#34;, &#34;_&#34;)
        else:
            svg_path = path
        screenshot_svg = self.export_screenshot()
        with open(svg_path, &#34;w&#34;) as svg_file:
            svg_file.write(screenshot_svg)
        return svg_path

    def bind(
        self,
        keys: str,
        action: str,
        description: str = &#34;&#34;,
        show: bool = True,
        key_display: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Bind a key to an action.

        Args:
            keys (str): A comma separated list of keys, i.e.
            action (str): Action to bind to.
            description (str, optional): Short description of action. Defaults to &#34;&#34;.
            show (bool, optional): Show key in UI. Defaults to True.
            key_display (str, optional): Replacement text for key, or None to use default. Defaults to None.
        &#34;&#34;&#34;
        self.bindings.bind(
            keys, action, description, show=show, key_display=key_display
        )

    def run(self) -&gt; ReturnType | None:
        &#34;&#34;&#34;The entry point to run a Textual app.&#34;&#34;&#34;

        async def run_app() -&gt; None:
            await self.process_messages()

        if _ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED:
            # N.B. This doesn&#39;t work with Python&lt;3.10, as we end up with 2 event loops:
            asyncio.run(run_app())
        else:
            # However, this works with Python&lt;3.10:
            event_loop = asyncio.get_event_loop()
            event_loop.run_until_complete(run_app())

        return self._return_value

    async def _on_css_change(self) -&gt; None:
        &#34;&#34;&#34;Called when the CSS changes (if watch_css is True).&#34;&#34;&#34;
        if self.css_path is not None:

            try:
                time = perf_counter()
                stylesheet = self.stylesheet.copy()
                stylesheet.read(self.css_path)
                stylesheet.parse()
                elapsed = (perf_counter() - time) * 1000
                self.log(f&#34;&lt;stylesheet&gt; loaded {self.css_path!r} in {elapsed:.0f} ms&#34;)
            except Exception as error:
                # TODO: Catch specific exceptions
                self.bell()
                self.log(error)
            else:
                self.stylesheet = stylesheet
                self.reset_styles()
                self.stylesheet.update(self)
                self.screen.refresh(layout=True)

    def render(self, styles: Style) -&gt; RenderableType:
        return &#34;&#34;

    def query(self, selector: str | None = None) -&gt; DOMQuery:
        &#34;&#34;&#34;Get a DOM query in the current screen.

        Args:
            selector (str, optional): A CSS selector or `None` for all nodes. Defaults to None.

        Returns:
            DOMQuery: A query object.
        &#34;&#34;&#34;
        from .css.query import DOMQuery

        return DOMQuery(self.screen, selector)

    def get_child(self, id: str) -&gt; DOMNode:
        &#34;&#34;&#34;Shorthand for self.screen.get_child(id: str)
        Returns the first child (immediate descendent) of this DOMNode
        with the given ID.

        Args:
            id (str): The ID of the node to search for.

        Returns:
            DOMNode: The first child of this node with the specified ID.

        Raises:
            NoMatchingNodesError: if no children could be found for this ID
        &#34;&#34;&#34;
        return self.screen.get_child(id)

    def update_styles(self) -&gt; None:
        &#34;&#34;&#34;Request update of styles.

        Should be called whenever CSS classes / pseudo classes change.

        &#34;&#34;&#34;
        self._require_styles_update = True
        self.check_idle()

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
        self.register(self.screen, *anon_widgets, **widgets)

    def push_screen(self, screen: Screen | None = None) -&gt; Screen:
        &#34;&#34;&#34;Push a new screen on the screen stack.

        Args:
            screen (Screen | None, optional): A new Screen instance or None to create
                one internally. Defaults to None.

        Returns:
            Screen: Newly active screen.
        &#34;&#34;&#34;
        new_screen = Screen() if screen is None else screen
        self._screen_stack.append(new_screen)
        return new_screen

    def set_focus(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Focus (or unfocus) a widget. A focused widget will receive key events first.

        Args:
            widget (Widget): [description]
        &#34;&#34;&#34;
        self.log(&#34;set_focus&#34;, widget=widget)
        if widget == self.focused:
            # Widget is already focused
            return

        if widget is None:
            # No focus, so blur currently focused widget if it exists
            if self.focused is not None:
                self.focused.post_message_no_wait(events.Blur(self))
                self.focused.emit_no_wait(events.DescendantBlur(self))
                self.focused = None
        elif widget.can_focus:
            if self.focused != widget:
                if self.focused is not None:
                    # Blur currently focused widget
                    self.focused.post_message_no_wait(events.Blur(self))
                    self.focused.emit_no_wait(events.DescendantBlur(self))
                # Change focus
                self.focused = widget
                # Send focus event
                widget.post_message_no_wait(events.Focus(self))
                widget.emit_no_wait(events.DescendantFocus(self))

    async def _set_mouse_over(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Called when the mouse is over another widget.

        Args:
            widget (Widget | None): Widget under mouse, or None for no widgets.
        &#34;&#34;&#34;
        if widget is None:
            if self.mouse_over is not None:
                try:
                    await self.mouse_over.post_message(events.Leave(self))
                finally:
                    self.mouse_over = None
        else:
            if self.mouse_over != widget:
                try:
                    if self.mouse_over is not None:
                        await self.mouse_over.forward_event(events.Leave(self))
                    if widget is not None:
                        await widget.forward_event(events.Enter(self))
                finally:
                    self.mouse_over = widget

    async def capture_mouse(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Send all mouse events to the given widget, disable mouse capture.

        Args:
            widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.
        &#34;&#34;&#34;
        if widget == self.mouse_captured:
            return
        if self.mouse_captured is not None:
            await self.mouse_captured.post_message(
                events.MouseRelease(self, self.mouse_position)
            )
        self.mouse_captured = widget
        if widget is not None:
            await widget.post_message(events.MouseCapture(self, self.mouse_position))

    def panic(self, *renderables: RenderableType) -&gt; None:
        &#34;&#34;&#34;Exits the app then displays a message.

        Args:
            *renderables (RenderableType, optional): Rich renderables to display on exit.
        &#34;&#34;&#34;

        assert all(
            is_renderable(renderable) for renderable in renderables
        ), &#34;Can only call panic with strings or Rich renderables&#34;

        prerendered = [
            Segments(self.console.render(renderable, self.console.options))
            for renderable in renderables
        ]

        self._exit_renderables.extend(prerendered)
        self.close_messages_no_wait()

    def on_exception(self, error: Exception) -&gt; None:
        &#34;&#34;&#34;Called with an unhandled exception.

        Args:
            error (Exception): An exception instance.
        &#34;&#34;&#34;

        if hasattr(error, &#34;__rich__&#34;):
            # Exception has a rich method, so we can defer to that for the rendering
            self.panic(error)
        else:
            # Use default exception rendering
            self.fatal_error()

    def fatal_error(self) -&gt; None:
        &#34;&#34;&#34;Exits the app after an unhandled exception.&#34;&#34;&#34;
        self.bell()
        traceback = Traceback(
            show_locals=True, width=None, locals_max_length=5, suppress=[rich]
        )
        self._exit_renderables.append(
            Segments(self.console.render(traceback, self.console.options))
        )
        self.close_messages_no_wait()

    def _print_error_renderables(self) -&gt; None:
        for renderable in self._exit_renderables:
            self.error_console.print(renderable)
        self._exit_renderables.clear()

    async def process_messages(self) -&gt; None:
        self._set_active()

        if self.devtools_enabled:
            try:
                await self.devtools.connect()
                self.log(f&#34;Connected to devtools ({self.devtools.url})&#34;)
            except DevtoolsConnectionError:
                self.log(f&#34;Couldn&#39;t connect to devtools ({self.devtools.url})&#34;)

        self.log(&#34;---&#34;)
        self.log(driver=self.driver_class)
        self.log(loop=asyncio.get_running_loop())
        self.log(features=self.features)

        try:
            if self.css_path is not None:
                self.stylesheet.read(self.css_path)
            if self.CSS is not None:
                self.stylesheet.add_source(
                    self.CSS, path=f&#34;&lt;{self.__class__.__name__}&gt;&#34;
                )
        except Exception as error:
            self.on_exception(error)
            self._print_error_renderables()
            return

        if self.css_monitor:
            self.set_interval(0.5, self.css_monitor, name=&#34;css monitor&#34;)
            self.log(&#34;started&#34;, self.css_monitor)

        self._running = True
        try:
            load_event = events.Load(sender=self)
            await self.dispatch_message(load_event)

            driver = self._driver = self.driver_class(self.console, self)
            driver.start_application_mode()
            try:
                mount_event = events.Mount(sender=self)
                await self.dispatch_message(mount_event)

                self.title = self._title
                self.refresh()
                await self.animator.start()

                with redirect_stdout(StdoutRedirector(self.devtools, self._log_file)):  # type: ignore
                    await self._ready()
                    await super().process_messages()
                    await self.animator.stop()
                    await self.close_all()
            finally:
                driver.stop_application_mode()
        except Exception as error:
            self.on_exception(error)
        finally:
            self._running = False
            self._print_error_renderables()
            if self.devtools.is_connected:
                await self._disconnect_devtools()
                if self._log_console is not None:
                    self._log_console.print(
                        f&#34;Disconnected from devtools ({self.devtools.url})&#34;
                    )
            if self._log_file is not None:
                self._log_file.close()
                self._log_console = None

    async def _ready(self) -&gt; None:
        &#34;&#34;&#34;Called immediately prior to processing messages.

        May be used as a hook for any operations that should run first.

        &#34;&#34;&#34;
        try:
            screenshot_timer = float(os.environ.get(&#34;TEXTUAL_SCREENSHOT&#34;, &#34;0&#34;))
        except ValueError:
            return

        if not screenshot_timer:
            return

        async def on_screenshot():
            &#34;&#34;&#34;Used by docs plugin.&#34;&#34;&#34;
            svg = self.export_screenshot()
            self._screenshot = svg  # type: ignore
            await self.shutdown()

        self.set_timer(screenshot_timer, on_screenshot)

    def on_mount(self) -&gt; None:
        widgets = list(self.compose())
        if widgets:
            self.mount(*widgets)

    async def on_idle(self) -&gt; None:
        &#34;&#34;&#34;Perform actions when there are no messages in the queue.&#34;&#34;&#34;
        if self._require_styles_update:
            await self.post_message(messages.StylesUpdated(self))
            self._require_styles_update = False

    def _register_child(self, parent: DOMNode, child: DOMNode) -&gt; bool:
        if child not in self.registry:
            parent.children._append(child)
            self.registry.add(child)
            child.set_parent(parent)
            child.on_register(self)
            child.start_messages()
            return True
        return False

    def register(
        self, parent: DOMNode, *anon_widgets: Widget, **widgets: Widget
    ) -&gt; None:
        &#34;&#34;&#34;Mount widget(s) so they may receive events.

        Args:
            parent (Widget): Parent Widget
        &#34;&#34;&#34;
        if not anon_widgets and not widgets:
            raise AppError(
                &#34;Nothing to mount, did you forget parent as first positional arg?&#34;
            )
        name_widgets: Iterable[tuple[str | None, Widget]]
        name_widgets = [*((None, widget) for widget in anon_widgets), *widgets.items()]
        apply_stylesheet = self.stylesheet.apply

        for widget_id, widget in name_widgets:
            if widget not in self.registry:
                if widget_id is not None:
                    widget.id = widget_id
                self._register_child(parent, widget)
                if widget.children:
                    self.register(widget, *widget.children)
                apply_stylesheet(widget)

        for _widget_id, widget in name_widgets:
            widget.post_message_no_wait(events.Mount(sender=parent))

    async def _disconnect_devtools(self):
        await self.devtools.disconnect()

    def start_widget(self, parent: Widget, widget: Widget) -&gt; None:
        &#34;&#34;&#34;Start a widget (run it&#39;s task) so that it can receive messages.

        Args:
            parent (Widget): The parent of the Widget.
            widget (Widget): The Widget to start.
        &#34;&#34;&#34;
        widget.set_parent(parent)
        widget.start_messages()
        widget.post_message_no_wait(events.Mount(sender=parent))

    def is_mounted(self, widget: Widget) -&gt; bool:
        return widget in self.registry

    async def close_all(self) -&gt; None:
        while self.registry:
            child = self.registry.pop()
            await child.close_messages()

    async def remove(self, child: MessagePump) -&gt; None:
        self.registry.remove(child)

    async def shutdown(self):
        await self._disconnect_devtools()
        driver = self._driver
        assert driver is not None
        driver.disable_input()
        await self.close_messages()

    def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
        self._display(self.screen._compositor)

    def refresh_css(self, animate: bool = True) -&gt; None:
        &#34;&#34;&#34;Refresh CSS.

        Args:
            animate (bool, optional): Also execute CSS animations. Defaults to True.
        &#34;&#34;&#34;
        stylesheet = self.app.stylesheet
        stylesheet.set_variables(self.get_css_variables())
        stylesheet.reparse()
        stylesheet.update(self.app, animate=animate)
        self.refresh(layout=True)

    def _display(self, renderable: RenderableType) -&gt; None:
        &#34;&#34;&#34;Display a renderable within a sync.

        Args:
            renderable (RenderableType): A Rich renderable.
        &#34;&#34;&#34;
        if self._running and not self._closed and not self.is_headless:
            console = self.console
            if self._sync_available:
                console.file.write(&#34;\x1bP=1s\x1b\\&#34;)
            try:
                console.print(renderable)
            except Exception as error:
                self.on_exception(error)
            if self._sync_available:
                console.file.write(&#34;\x1bP=2s\x1b\\&#34;)
            console.file.flush()

    def measure(self, renderable: RenderableType, max_width=100_000) -&gt; int:
        &#34;&#34;&#34;Get the optimal width for a widget or renderable.

        Args:
            renderable (RenderableType): A renderable (including Widget)
            max_width ([type], optional): Maximum width. Defaults to 100_000.

        Returns:
            int: Number of cells required to render.
        &#34;&#34;&#34;
        measurement = Measurement.get(
            self.console, self.console.options.update(max_width=max_width), renderable
        )
        return measurement.maximum

    def get_widget_at(self, x: int, y: int) -&gt; tuple[Widget, Region]:
        &#34;&#34;&#34;Get the widget under the given coordinates.

        Args:
            x (int): X Coord.
            y (int): Y Coord.

        Returns:
            tuple[Widget, Region]: The widget and the widget&#39;s screen region.
        &#34;&#34;&#34;
        return self.screen.get_widget_at(x, y)

    def bell(self) -&gt; None:
        &#34;&#34;&#34;Play the console &#39;bell&#39;.&#34;&#34;&#34;
        self.console.bell()

    async def press(self, key: str) -&gt; bool:
        &#34;&#34;&#34;Handle a key press.

        Args:
            key (str): A key

        Returns:
            bool: True if the key was handled by a binding, otherwise False
        &#34;&#34;&#34;
        try:
            binding = self.bindings.get_key(key)
        except NoBinding:
            return False
        else:
            await self.action(binding.action)
        return True

    async def on_event(self, event: events.Event) -&gt; None:
        # Handle input events that haven&#39;t been forwarded
        # If the event has been forwarded it may have bubbled up back to the App
        if isinstance(event, events.Mount):
            screen = Screen()
            self.register(self, screen)
            self.push_screen(screen)
            await super().on_event(event)

        elif isinstance(event, events.InputEvent) and not event.is_forwarded:
            if isinstance(event, events.MouseEvent):
                # Record current mouse position on App
                self.mouse_position = Offset(event.x, event.y)
            if isinstance(event, events.Key) and self.focused is not None:
                # Key events are sent direct to focused widget
                if self.bindings.allow_forward(event.key):
                    await self.focused.forward_event(event)
                else:
                    # Key has allow_forward=False which disallows forward to focused widget
                    await super().on_event(event)
            else:
                # Forward the event to the view
                await self.screen.forward_event(event)
        else:
            await super().on_event(event)

    async def action(
        self,
        action: str,
        default_namespace: object | None = None,
        modifiers: set[str] | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Perform an action.

        Args:
            action (str): Action encoded in a string.
        &#34;&#34;&#34;
        target, params = actions.parse(action)
        if &#34;.&#34; in target:
            destination, action_name = target.split(&#34;.&#34;, 1)
            if destination not in self._action_targets:
                raise ActionError(&#34;Action namespace {destination} is not known&#34;)
            action_target = getattr(self, destination)
        else:
            action_target = default_namespace or self
            action_name = target

        log(&#34;&lt;action&gt;&#34;, action)
        await self.dispatch_action(action_target, action_name, params)

    async def dispatch_action(
        self, namespace: object, action_name: str, params: Any
    ) -&gt; None:
        log(
            &#34;&lt;action&gt;&#34;,
            namespace=namespace,
            action_name=action_name,
            params=params,
        )
        _rich_traceback_guard = True
        method_name = f&#34;action_{action_name}&#34;
        method = getattr(namespace, method_name, None)
        if callable(method):
            await invoke(method, *params)

    async def broker_event(
        self, event_name: str, event: events.Event, default_namespace: object | None
    ) -&gt; bool:
        &#34;&#34;&#34;Allow the app an opportunity to dispatch events to action system.

        Args:
            event_name (str): _description_
            event (events.Event): An event object.
            default_namespace (object | None): TODO: _description_

        Returns:
            bool: True if an action was processed.
        &#34;&#34;&#34;
        event.stop()
        try:
            style = getattr(event, &#34;style&#34;)
        except AttributeError:
            return False
        try:
            modifiers, action = extract_handler_actions(event_name, style.meta)
        except NoHandler:
            return False
        if isinstance(action, str):
            await self.action(
                action, default_namespace=default_namespace, modifiers=modifiers
            )
        elif callable(action):
            await action()
        else:
            return False
        return True

    async def handle_update(self, message: messages.Update) -&gt; None:
        message.stop()
        self.app.refresh()

    async def handle_layout(self, message: messages.Layout) -&gt; None:
        message.stop()
        self.app.refresh()

    async def on_key(self, event: events.Key) -&gt; None:
        if event.key == &#34;tab&#34;:
            self.focus_next()
        elif event.key == &#34;shift+tab&#34;:
            self.focus_previous()
        else:
            await self.press(event.key)

    async def on_shutdown_request(self, event: events.ShutdownRequest) -&gt; None:
        log(&#34;shutdown request&#34;)
        await self.close_messages()

    async def on_resize(self, event: events.Resize) -&gt; None:
        await self.screen.post_message(event)

    async def action_press(self, key: str) -&gt; None:
        await self.press(key)

    async def action_quit(self) -&gt; None:
        await self.shutdown()

    async def action_bang(self) -&gt; None:
        1 / 0

    async def action_bell(self) -&gt; None:
        self.bell()

    async def action_add_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).add_class(class_name)

    async def action_remove_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).remove_class(class_name)

    async def action_toggle_class(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).toggle_class(class_name)

    async def handle_styles_updated(self, message: messages.StylesUpdated) -&gt; None:
        self.stylesheet.update(self, animate=True)


_uvloop_init_done: bool = False


def _init_uvloop() -&gt; None:
    &#34;&#34;&#34;
    Import and install the `uvloop` asyncio policy, if available.
    This is done only once, even if the function is called multiple times.
    &#34;&#34;&#34;
    global _uvloop_init_done

    if _uvloop_init_done:
        return

    try:
        import uvloop
    except ImportError:
        pass
    else:
        uvloop.install()

    _uvloop_init_done = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.app.ActionError"><code class="flex name class">
<span>class <span class="ident">ActionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActionError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textual.app.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
<span>(</span><span>driver_class: Type[Driver] | None = None, log_path: str | PurePath = '', log_verbosity: int = 1, log_color_system: "Literal[('auto', 'standard', '256', 'truecolor', 'windows')]" = 'auto', title: str = 'Textual Application', css_path: str | PurePath | None = None, watch_css: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for Textual Applications</p>
<p>Textual application base class</p>
<h2 id="args">Args</h2>
<dl>
<dt>driver_class (Type[Driver] | None, optional): Driver class or <code>None</code> to auto-detect. Defaults to None.</dt>
<dt>log_path (str | PurePath, optional): Path to log file, or "" to disable. Defaults to "".</dt>
<dt><strong><code>log_verbosity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Log verbosity from 0-3. Defaults to 1.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Default title of the application. Defaults to "Textual Application".</dd>
<dt>css_path (str | PurePath | None, optional): Path to CSS or <code>None</code> for no CSS file. Defaults to None.</dt>
<dt><strong><code>watch_css</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Watch CSS for changes. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class App(Generic[ReturnType], DOMNode):
    &#34;&#34;&#34;The base class for Textual Applications&#34;&#34;&#34;

    CSS = &#34;&#34;&#34;

    &#34;&#34;&#34;

    CSS_PATH: str | None = None

    def __init__(
        self,
        driver_class: Type[Driver] | None = None,
        log_path: str | PurePath = &#34;&#34;,
        log_verbosity: int = 1,
        log_color_system: Literal[
            &#34;auto&#34;, &#34;standard&#34;, &#34;256&#34;, &#34;truecolor&#34;, &#34;windows&#34;
        ] = &#34;auto&#34;,
        title: str = &#34;Textual Application&#34;,
        css_path: str | PurePath | None = None,
        watch_css: bool = False,
    ):
        &#34;&#34;&#34;Textual application base class

        Args:
            driver_class (Type[Driver] | None, optional): Driver class or ``None`` to auto-detect. Defaults to None.
            log_path (str | PurePath, optional): Path to log file, or &#34;&#34; to disable. Defaults to &#34;&#34;.
            log_verbosity (int, optional): Log verbosity from 0-3. Defaults to 1.
            title (str, optional): Default title of the application. Defaults to &#34;Textual Application&#34;.
            css_path (str | PurePath | None, optional): Path to CSS or ``None`` for no CSS file. Defaults to None.
            watch_css (bool, optional): Watch CSS for changes. Defaults to False.
        &#34;&#34;&#34;
        # N.B. This must be done *before* we call the parent constructor, because MessagePump&#39;s
        # constructor instantiates a `asyncio.PriorityQueue` and in Python versions older than 3.10
        # this will create some first references to an asyncio loop.
        _init_uvloop()

        self.features: frozenset[FeatureFlag] = parse_features(os.getenv(&#34;TEXTUAL&#34;, &#34;&#34;))

        self.console = Console(
            file=(open(os.devnull, &#34;wt&#34;) if self.is_headless else sys.__stdout__),
            markup=True,
            highlight=False,
            emoji=False,
        )
        self.error_console = Console(markup=False, stderr=True)
        self.driver_class = driver_class or self.get_driver_class()
        self._title = title
        self._screen_stack: list[Screen] = []
        self._sync_available = (
            os.environ.get(&#34;TERM_PROGRAM&#34;, &#34;&#34;) != &#34;Apple_Terminal&#34; and not WINDOWS
        )

        self.focused: Widget | None = None
        self.mouse_over: Widget | None = None
        self.mouse_captured: Widget | None = None
        self._driver: Driver | None = None
        self._exit_renderables: list[RenderableType] = []

        self._docks: list[Dock] = []
        self._action_targets = {&#34;app&#34;, &#34;screen&#34;}
        self._animator = Animator(self)
        self.animate = self._animator.bind(self)
        self.mouse_position = Offset(0, 0)
        self.bindings = Bindings()
        self._title = title

        self._log_console: Console | None = None
        self._log_file: TextIO | None = None
        if log_path:
            self._log_file = open(log_path, &#34;wt&#34;)
            self._log_console = Console(
                file=self._log_file,
                color_system=log_color_system,
                markup=False,
                emoji=False,
                highlight=False,
                width=100,
            )

        self.log_verbosity = log_verbosity

        self.bindings.bind(&#34;ctrl+c&#34;, &#34;quit&#34;, show=False, allow_forward=False)
        self._refresh_required = False

        self.design = DEFAULT_COLORS

        self.stylesheet = Stylesheet(variables=self.get_css_variables())
        self._require_styles_update = False
        self.css_path = css_path or self.CSS_PATH

        self.registry: set[MessagePump] = set()
        self.devtools = DevtoolsClient()
        self._return_value: ReturnType | None = None

        self.css_monitor = (
            FileMonitor(css_path, self._on_css_change)
            if ((watch_css or self.debug) and css_path)
            else None
        )

        super().__init__()

    def __init_subclass__(cls, css_path: str | None = None) -&gt; None:
        super().__init_subclass__()
        cls.CSS_PATH = css_path

    title: Reactive[str] = Reactive(&#34;Textual&#34;)
    sub_title: Reactive[str] = Reactive(&#34;&#34;)
    background: Reactive[str] = Reactive(&#34;black&#34;)
    dark = Reactive(False)

    @property
    def devtools_enabled(self) -&gt; bool:
        &#34;&#34;&#34;Check if devtools are enabled.&#34;&#34;&#34;
        return &#34;devtools&#34; in self.features

    @property
    def debug(self) -&gt; bool:
        &#34;&#34;&#34;Check if debug mode is enabled.&#34;&#34;&#34;
        return &#34;debug&#34; in self.features

    @property
    def is_headless(self) -&gt; bool:
        &#34;&#34;&#34;Check if the app is running in &#39;headless&#39; mode.&#34;&#34;&#34;
        return &#34;headless&#34; in self.features

    def exit(self, result: ReturnType | None = None) -&gt; None:
        &#34;&#34;&#34;Exit the app, and return the supplied result.

        Args:
            result (ReturnType | None, optional): Return value. Defaults to None.
        &#34;&#34;&#34;
        self._return_value = result
        self.close_messages_no_wait()

    @property
    def focus_chain(self) -&gt; list[Widget]:
        &#34;&#34;&#34;Get widgets that may receive focus, in focus order.&#34;&#34;&#34;
        widgets: list[Widget] = []
        add_widget = widgets.append
        root = self.screen
        stack: list[Iterator[Widget]] = [iter(root.focusable_children)]
        pop = stack.pop
        push = stack.append

        while stack:
            node = next(stack[-1], None)
            if node is None:
                pop()
            else:
                if node.is_container and node.can_focus_children:
                    push(iter(node.focusable_children))
                else:
                    if node.can_focus:
                        add_widget(node)

        return widgets

    def _set_active(self) -&gt; None:
        &#34;&#34;&#34;Set this app to be the currently active app.&#34;&#34;&#34;
        active_app.set(self)

    def _move_focus(self, direction: int = 0) -&gt; Widget | None:
        &#34;&#34;&#34;Move the focus in the given direction.

        Args:
            direction (int, optional): 1 to move forward, -1 to move backward, or
                0 to highlight the current focus.

        Returns:
            Widget | None: Newly focused widget, or None for no focus.
        &#34;&#34;&#34;
        focusable_widgets = self.focus_chain

        if not focusable_widgets:
            # Nothing focusable, so nothing to do
            return self.focused
        if self.focused is None:
            # Nothing currently focused, so focus the first one
            self.set_focus(focusable_widgets[0])
        else:
            try:
                # Find the index of the currently focused widget
                current_index = focusable_widgets.index(self.focused)
            except ValueError:
                # Focused widget was removed in the interim, start again
                self.set_focus(focusable_widgets[0])
            else:
                # Only move the focus if we are currently showing the focus
                if direction:
                    current_index = (current_index + direction) % len(focusable_widgets)
                    self.set_focus(focusable_widgets[current_index])

        return self.focused

    def show_focus(self) -&gt; Widget | None:
        &#34;&#34;&#34;Highlight the currently focused widget.

        Returns:
            Widget | None: Focused widget, or None for no focus.
        &#34;&#34;&#34;
        return self._move_focus(0)

    def focus_next(self) -&gt; Widget | None:
        &#34;&#34;&#34;Focus the next widget.

        Returns:
            Widget | None: Newly focused widget, or None for no focus.
        &#34;&#34;&#34;
        return self._move_focus(1)

    def focus_previous(self) -&gt; Widget | None:
        &#34;&#34;&#34;Focus the previous widget.

        Returns:
            Widget | None: Newly focused widget, or None for no focus.
        &#34;&#34;&#34;
        return self._move_focus(-1)

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def get_css_variables(self) -&gt; dict[str, str]:
        &#34;&#34;&#34;Get a mapping of variables used to pre-populate CSS.

        Returns:
            dict[str, str]: A mapping of variable name to value.
        &#34;&#34;&#34;
        variables = self.design.generate(self.dark)
        return variables

    def watch_dark(self, dark: bool) -&gt; None:
        &#34;&#34;&#34;Watches the dark bool.&#34;&#34;&#34;
        self.screen.dark = dark
        self.refresh_css()

    def get_driver_class(self) -&gt; Type[Driver]:
        &#34;&#34;&#34;Get a driver class for this platform.

        Called by the constructor.

        Returns:
            Driver: A Driver class which manages input and display.
        &#34;&#34;&#34;
        driver_class: Type[Driver]
        if WINDOWS:
            from .drivers.windows_driver import WindowsDriver

            driver_class = WindowsDriver
        else:
            from .drivers.linux_driver import LinuxDriver

            driver_class = LinuxDriver
        return driver_class

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;title&#34;, self.title

    @property
    def animator(self) -&gt; Animator:
        return self._animator

    @property
    def screen(self) -&gt; Screen:
        return self._screen_stack[-1]

    @property
    def css_type(self) -&gt; str:
        return &#34;app&#34;

    @property
    def size(self) -&gt; Size:
        return Size(*self.console.size)

    def log(
        self,
        *objects: Any,
        verbosity: int = 1,
        _textual_calling_frame: inspect.FrameInfo | None = None,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;Write to logs.

        Args:
            *objects (Any): Positional arguments are converted to string and written to logs.
            verbosity (int, optional): Verbosity level 0-3. Defaults to 1.
            _textual_calling_frame (inspect.FrameInfo | None): The frame info to include in
                the log message sent to the devtools server.
        &#34;&#34;&#34;
        if verbosity &gt; self.log_verbosity:
            return

        if self.devtools.is_connected and not _textual_calling_frame:
            _textual_calling_frame = inspect.stack()[1]

        try:
            if len(objects) == 1 and not kwargs:
                if self._log_console is not None:
                    self._log_console.print(objects[0])
                if self.devtools.is_connected:
                    self.devtools.log(
                        DevtoolsLog(objects, caller=_textual_calling_frame)
                    )
            else:
                output = &#34; &#34;.join(str(arg) for arg in objects)
                if kwargs:
                    key_values = &#34; &#34;.join(
                        f&#34;{key}={value!r}&#34; for key, value in kwargs.items()
                    )
                    output = f&#34;{output} {key_values}&#34; if output else key_values
                if self._log_console is not None:
                    self._log_console.print(output, soft_wrap=True)
                if self.devtools.is_connected:
                    self.devtools.log(
                        DevtoolsLog(output, caller=_textual_calling_frame)
                    )
        except Exception as error:
            self.on_exception(error)

    def action_screenshot(self, path: str | None = None) -&gt; None:
        &#34;&#34;&#34;Action to save a screenshot.&#34;&#34;&#34;
        self.save_screenshot(path)

    def export_screenshot(self) -&gt; str:
        &#34;&#34;&#34;Export a SVG screenshot of the current screen.

        Args:
            path (str | None, optional): Path of the SVG to save, or None to
                generate a path automatically. Defaults to None.
        &#34;&#34;&#34;

        console = Console(
            width=self.console.width,
            height=self.console.height,
            file=io.StringIO(),
            force_terminal=True,
            color_system=&#34;truecolor&#34;,
            record=True,
        )
        console.print(self.screen._compositor.render(full=True))
        return console.export_svg(title=self.title)

    def save_screenshot(self, path: str | None = None) -&gt; str:
        &#34;&#34;&#34;Save a screenshot of the current screen.

        Args:
            path (str | None, optional): Path to SVG to save or None to pick
                a filename automatically. Defaults to None.

        Returns:
            str: Filename of screenshot.
        &#34;&#34;&#34;
        self.bell()
        if path is None:
            svg_path = f&#34;{self.title.lower()}_{datetime.now().isoformat()}.svg&#34;
            svg_path = svg_path.replace(&#34;/&#34;, &#34;_&#34;).replace(&#34;\\&#34;, &#34;_&#34;)
        else:
            svg_path = path
        screenshot_svg = self.export_screenshot()
        with open(svg_path, &#34;w&#34;) as svg_file:
            svg_file.write(screenshot_svg)
        return svg_path

    def bind(
        self,
        keys: str,
        action: str,
        description: str = &#34;&#34;,
        show: bool = True,
        key_display: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Bind a key to an action.

        Args:
            keys (str): A comma separated list of keys, i.e.
            action (str): Action to bind to.
            description (str, optional): Short description of action. Defaults to &#34;&#34;.
            show (bool, optional): Show key in UI. Defaults to True.
            key_display (str, optional): Replacement text for key, or None to use default. Defaults to None.
        &#34;&#34;&#34;
        self.bindings.bind(
            keys, action, description, show=show, key_display=key_display
        )

    def run(self) -&gt; ReturnType | None:
        &#34;&#34;&#34;The entry point to run a Textual app.&#34;&#34;&#34;

        async def run_app() -&gt; None:
            await self.process_messages()

        if _ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED:
            # N.B. This doesn&#39;t work with Python&lt;3.10, as we end up with 2 event loops:
            asyncio.run(run_app())
        else:
            # However, this works with Python&lt;3.10:
            event_loop = asyncio.get_event_loop()
            event_loop.run_until_complete(run_app())

        return self._return_value

    async def _on_css_change(self) -&gt; None:
        &#34;&#34;&#34;Called when the CSS changes (if watch_css is True).&#34;&#34;&#34;
        if self.css_path is not None:

            try:
                time = perf_counter()
                stylesheet = self.stylesheet.copy()
                stylesheet.read(self.css_path)
                stylesheet.parse()
                elapsed = (perf_counter() - time) * 1000
                self.log(f&#34;&lt;stylesheet&gt; loaded {self.css_path!r} in {elapsed:.0f} ms&#34;)
            except Exception as error:
                # TODO: Catch specific exceptions
                self.bell()
                self.log(error)
            else:
                self.stylesheet = stylesheet
                self.reset_styles()
                self.stylesheet.update(self)
                self.screen.refresh(layout=True)

    def render(self, styles: Style) -&gt; RenderableType:
        return &#34;&#34;

    def query(self, selector: str | None = None) -&gt; DOMQuery:
        &#34;&#34;&#34;Get a DOM query in the current screen.

        Args:
            selector (str, optional): A CSS selector or `None` for all nodes. Defaults to None.

        Returns:
            DOMQuery: A query object.
        &#34;&#34;&#34;
        from .css.query import DOMQuery

        return DOMQuery(self.screen, selector)

    def get_child(self, id: str) -&gt; DOMNode:
        &#34;&#34;&#34;Shorthand for self.screen.get_child(id: str)
        Returns the first child (immediate descendent) of this DOMNode
        with the given ID.

        Args:
            id (str): The ID of the node to search for.

        Returns:
            DOMNode: The first child of this node with the specified ID.

        Raises:
            NoMatchingNodesError: if no children could be found for this ID
        &#34;&#34;&#34;
        return self.screen.get_child(id)

    def update_styles(self) -&gt; None:
        &#34;&#34;&#34;Request update of styles.

        Should be called whenever CSS classes / pseudo classes change.

        &#34;&#34;&#34;
        self._require_styles_update = True
        self.check_idle()

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
        self.register(self.screen, *anon_widgets, **widgets)

    def push_screen(self, screen: Screen | None = None) -&gt; Screen:
        &#34;&#34;&#34;Push a new screen on the screen stack.

        Args:
            screen (Screen | None, optional): A new Screen instance or None to create
                one internally. Defaults to None.

        Returns:
            Screen: Newly active screen.
        &#34;&#34;&#34;
        new_screen = Screen() if screen is None else screen
        self._screen_stack.append(new_screen)
        return new_screen

    def set_focus(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Focus (or unfocus) a widget. A focused widget will receive key events first.

        Args:
            widget (Widget): [description]
        &#34;&#34;&#34;
        self.log(&#34;set_focus&#34;, widget=widget)
        if widget == self.focused:
            # Widget is already focused
            return

        if widget is None:
            # No focus, so blur currently focused widget if it exists
            if self.focused is not None:
                self.focused.post_message_no_wait(events.Blur(self))
                self.focused.emit_no_wait(events.DescendantBlur(self))
                self.focused = None
        elif widget.can_focus:
            if self.focused != widget:
                if self.focused is not None:
                    # Blur currently focused widget
                    self.focused.post_message_no_wait(events.Blur(self))
                    self.focused.emit_no_wait(events.DescendantBlur(self))
                # Change focus
                self.focused = widget
                # Send focus event
                widget.post_message_no_wait(events.Focus(self))
                widget.emit_no_wait(events.DescendantFocus(self))

    async def _set_mouse_over(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Called when the mouse is over another widget.

        Args:
            widget (Widget | None): Widget under mouse, or None for no widgets.
        &#34;&#34;&#34;
        if widget is None:
            if self.mouse_over is not None:
                try:
                    await self.mouse_over.post_message(events.Leave(self))
                finally:
                    self.mouse_over = None
        else:
            if self.mouse_over != widget:
                try:
                    if self.mouse_over is not None:
                        await self.mouse_over.forward_event(events.Leave(self))
                    if widget is not None:
                        await widget.forward_event(events.Enter(self))
                finally:
                    self.mouse_over = widget

    async def capture_mouse(self, widget: Widget | None) -&gt; None:
        &#34;&#34;&#34;Send all mouse events to the given widget, disable mouse capture.

        Args:
            widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.
        &#34;&#34;&#34;
        if widget == self.mouse_captured:
            return
        if self.mouse_captured is not None:
            await self.mouse_captured.post_message(
                events.MouseRelease(self, self.mouse_position)
            )
        self.mouse_captured = widget
        if widget is not None:
            await widget.post_message(events.MouseCapture(self, self.mouse_position))

    def panic(self, *renderables: RenderableType) -&gt; None:
        &#34;&#34;&#34;Exits the app then displays a message.

        Args:
            *renderables (RenderableType, optional): Rich renderables to display on exit.
        &#34;&#34;&#34;

        assert all(
            is_renderable(renderable) for renderable in renderables
        ), &#34;Can only call panic with strings or Rich renderables&#34;

        prerendered = [
            Segments(self.console.render(renderable, self.console.options))
            for renderable in renderables
        ]

        self._exit_renderables.extend(prerendered)
        self.close_messages_no_wait()

    def on_exception(self, error: Exception) -&gt; None:
        &#34;&#34;&#34;Called with an unhandled exception.

        Args:
            error (Exception): An exception instance.
        &#34;&#34;&#34;

        if hasattr(error, &#34;__rich__&#34;):
            # Exception has a rich method, so we can defer to that for the rendering
            self.panic(error)
        else:
            # Use default exception rendering
            self.fatal_error()

    def fatal_error(self) -&gt; None:
        &#34;&#34;&#34;Exits the app after an unhandled exception.&#34;&#34;&#34;
        self.bell()
        traceback = Traceback(
            show_locals=True, width=None, locals_max_length=5, suppress=[rich]
        )
        self._exit_renderables.append(
            Segments(self.console.render(traceback, self.console.options))
        )
        self.close_messages_no_wait()

    def _print_error_renderables(self) -&gt; None:
        for renderable in self._exit_renderables:
            self.error_console.print(renderable)
        self._exit_renderables.clear()

    async def process_messages(self) -&gt; None:
        self._set_active()

        if self.devtools_enabled:
            try:
                await self.devtools.connect()
                self.log(f&#34;Connected to devtools ({self.devtools.url})&#34;)
            except DevtoolsConnectionError:
                self.log(f&#34;Couldn&#39;t connect to devtools ({self.devtools.url})&#34;)

        self.log(&#34;---&#34;)
        self.log(driver=self.driver_class)
        self.log(loop=asyncio.get_running_loop())
        self.log(features=self.features)

        try:
            if self.css_path is not None:
                self.stylesheet.read(self.css_path)
            if self.CSS is not None:
                self.stylesheet.add_source(
                    self.CSS, path=f&#34;&lt;{self.__class__.__name__}&gt;&#34;
                )
        except Exception as error:
            self.on_exception(error)
            self._print_error_renderables()
            return

        if self.css_monitor:
            self.set_interval(0.5, self.css_monitor, name=&#34;css monitor&#34;)
            self.log(&#34;started&#34;, self.css_monitor)

        self._running = True
        try:
            load_event = events.Load(sender=self)
            await self.dispatch_message(load_event)

            driver = self._driver = self.driver_class(self.console, self)
            driver.start_application_mode()
            try:
                mount_event = events.Mount(sender=self)
                await self.dispatch_message(mount_event)

                self.title = self._title
                self.refresh()
                await self.animator.start()

                with redirect_stdout(StdoutRedirector(self.devtools, self._log_file)):  # type: ignore
                    await self._ready()
                    await super().process_messages()
                    await self.animator.stop()
                    await self.close_all()
            finally:
                driver.stop_application_mode()
        except Exception as error:
            self.on_exception(error)
        finally:
            self._running = False
            self._print_error_renderables()
            if self.devtools.is_connected:
                await self._disconnect_devtools()
                if self._log_console is not None:
                    self._log_console.print(
                        f&#34;Disconnected from devtools ({self.devtools.url})&#34;
                    )
            if self._log_file is not None:
                self._log_file.close()
                self._log_console = None

    async def _ready(self) -&gt; None:
        &#34;&#34;&#34;Called immediately prior to processing messages.

        May be used as a hook for any operations that should run first.

        &#34;&#34;&#34;
        try:
            screenshot_timer = float(os.environ.get(&#34;TEXTUAL_SCREENSHOT&#34;, &#34;0&#34;))
        except ValueError:
            return

        if not screenshot_timer:
            return

        async def on_screenshot():
            &#34;&#34;&#34;Used by docs plugin.&#34;&#34;&#34;
            svg = self.export_screenshot()
            self._screenshot = svg  # type: ignore
            await self.shutdown()

        self.set_timer(screenshot_timer, on_screenshot)

    def on_mount(self) -&gt; None:
        widgets = list(self.compose())
        if widgets:
            self.mount(*widgets)

    async def on_idle(self) -&gt; None:
        &#34;&#34;&#34;Perform actions when there are no messages in the queue.&#34;&#34;&#34;
        if self._require_styles_update:
            await self.post_message(messages.StylesUpdated(self))
            self._require_styles_update = False

    def _register_child(self, parent: DOMNode, child: DOMNode) -&gt; bool:
        if child not in self.registry:
            parent.children._append(child)
            self.registry.add(child)
            child.set_parent(parent)
            child.on_register(self)
            child.start_messages()
            return True
        return False

    def register(
        self, parent: DOMNode, *anon_widgets: Widget, **widgets: Widget
    ) -&gt; None:
        &#34;&#34;&#34;Mount widget(s) so they may receive events.

        Args:
            parent (Widget): Parent Widget
        &#34;&#34;&#34;
        if not anon_widgets and not widgets:
            raise AppError(
                &#34;Nothing to mount, did you forget parent as first positional arg?&#34;
            )
        name_widgets: Iterable[tuple[str | None, Widget]]
        name_widgets = [*((None, widget) for widget in anon_widgets), *widgets.items()]
        apply_stylesheet = self.stylesheet.apply

        for widget_id, widget in name_widgets:
            if widget not in self.registry:
                if widget_id is not None:
                    widget.id = widget_id
                self._register_child(parent, widget)
                if widget.children:
                    self.register(widget, *widget.children)
                apply_stylesheet(widget)

        for _widget_id, widget in name_widgets:
            widget.post_message_no_wait(events.Mount(sender=parent))

    async def _disconnect_devtools(self):
        await self.devtools.disconnect()

    def start_widget(self, parent: Widget, widget: Widget) -&gt; None:
        &#34;&#34;&#34;Start a widget (run it&#39;s task) so that it can receive messages.

        Args:
            parent (Widget): The parent of the Widget.
            widget (Widget): The Widget to start.
        &#34;&#34;&#34;
        widget.set_parent(parent)
        widget.start_messages()
        widget.post_message_no_wait(events.Mount(sender=parent))

    def is_mounted(self, widget: Widget) -&gt; bool:
        return widget in self.registry

    async def close_all(self) -&gt; None:
        while self.registry:
            child = self.registry.pop()
            await child.close_messages()

    async def remove(self, child: MessagePump) -&gt; None:
        self.registry.remove(child)

    async def shutdown(self):
        await self._disconnect_devtools()
        driver = self._driver
        assert driver is not None
        driver.disable_input()
        await self.close_messages()

    def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
        self._display(self.screen._compositor)

    def refresh_css(self, animate: bool = True) -&gt; None:
        &#34;&#34;&#34;Refresh CSS.

        Args:
            animate (bool, optional): Also execute CSS animations. Defaults to True.
        &#34;&#34;&#34;
        stylesheet = self.app.stylesheet
        stylesheet.set_variables(self.get_css_variables())
        stylesheet.reparse()
        stylesheet.update(self.app, animate=animate)
        self.refresh(layout=True)

    def _display(self, renderable: RenderableType) -&gt; None:
        &#34;&#34;&#34;Display a renderable within a sync.

        Args:
            renderable (RenderableType): A Rich renderable.
        &#34;&#34;&#34;
        if self._running and not self._closed and not self.is_headless:
            console = self.console
            if self._sync_available:
                console.file.write(&#34;\x1bP=1s\x1b\\&#34;)
            try:
                console.print(renderable)
            except Exception as error:
                self.on_exception(error)
            if self._sync_available:
                console.file.write(&#34;\x1bP=2s\x1b\\&#34;)
            console.file.flush()

    def measure(self, renderable: RenderableType, max_width=100_000) -&gt; int:
        &#34;&#34;&#34;Get the optimal width for a widget or renderable.

        Args:
            renderable (RenderableType): A renderable (including Widget)
            max_width ([type], optional): Maximum width. Defaults to 100_000.

        Returns:
            int: Number of cells required to render.
        &#34;&#34;&#34;
        measurement = Measurement.get(
            self.console, self.console.options.update(max_width=max_width), renderable
        )
        return measurement.maximum

    def get_widget_at(self, x: int, y: int) -&gt; tuple[Widget, Region]:
        &#34;&#34;&#34;Get the widget under the given coordinates.

        Args:
            x (int): X Coord.
            y (int): Y Coord.

        Returns:
            tuple[Widget, Region]: The widget and the widget&#39;s screen region.
        &#34;&#34;&#34;
        return self.screen.get_widget_at(x, y)

    def bell(self) -&gt; None:
        &#34;&#34;&#34;Play the console &#39;bell&#39;.&#34;&#34;&#34;
        self.console.bell()

    async def press(self, key: str) -&gt; bool:
        &#34;&#34;&#34;Handle a key press.

        Args:
            key (str): A key

        Returns:
            bool: True if the key was handled by a binding, otherwise False
        &#34;&#34;&#34;
        try:
            binding = self.bindings.get_key(key)
        except NoBinding:
            return False
        else:
            await self.action(binding.action)
        return True

    async def on_event(self, event: events.Event) -&gt; None:
        # Handle input events that haven&#39;t been forwarded
        # If the event has been forwarded it may have bubbled up back to the App
        if isinstance(event, events.Mount):
            screen = Screen()
            self.register(self, screen)
            self.push_screen(screen)
            await super().on_event(event)

        elif isinstance(event, events.InputEvent) and not event.is_forwarded:
            if isinstance(event, events.MouseEvent):
                # Record current mouse position on App
                self.mouse_position = Offset(event.x, event.y)
            if isinstance(event, events.Key) and self.focused is not None:
                # Key events are sent direct to focused widget
                if self.bindings.allow_forward(event.key):
                    await self.focused.forward_event(event)
                else:
                    # Key has allow_forward=False which disallows forward to focused widget
                    await super().on_event(event)
            else:
                # Forward the event to the view
                await self.screen.forward_event(event)
        else:
            await super().on_event(event)

    async def action(
        self,
        action: str,
        default_namespace: object | None = None,
        modifiers: set[str] | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Perform an action.

        Args:
            action (str): Action encoded in a string.
        &#34;&#34;&#34;
        target, params = actions.parse(action)
        if &#34;.&#34; in target:
            destination, action_name = target.split(&#34;.&#34;, 1)
            if destination not in self._action_targets:
                raise ActionError(&#34;Action namespace {destination} is not known&#34;)
            action_target = getattr(self, destination)
        else:
            action_target = default_namespace or self
            action_name = target

        log(&#34;&lt;action&gt;&#34;, action)
        await self.dispatch_action(action_target, action_name, params)

    async def dispatch_action(
        self, namespace: object, action_name: str, params: Any
    ) -&gt; None:
        log(
            &#34;&lt;action&gt;&#34;,
            namespace=namespace,
            action_name=action_name,
            params=params,
        )
        _rich_traceback_guard = True
        method_name = f&#34;action_{action_name}&#34;
        method = getattr(namespace, method_name, None)
        if callable(method):
            await invoke(method, *params)

    async def broker_event(
        self, event_name: str, event: events.Event, default_namespace: object | None
    ) -&gt; bool:
        &#34;&#34;&#34;Allow the app an opportunity to dispatch events to action system.

        Args:
            event_name (str): _description_
            event (events.Event): An event object.
            default_namespace (object | None): TODO: _description_

        Returns:
            bool: True if an action was processed.
        &#34;&#34;&#34;
        event.stop()
        try:
            style = getattr(event, &#34;style&#34;)
        except AttributeError:
            return False
        try:
            modifiers, action = extract_handler_actions(event_name, style.meta)
        except NoHandler:
            return False
        if isinstance(action, str):
            await self.action(
                action, default_namespace=default_namespace, modifiers=modifiers
            )
        elif callable(action):
            await action()
        else:
            return False
        return True

    async def handle_update(self, message: messages.Update) -&gt; None:
        message.stop()
        self.app.refresh()

    async def handle_layout(self, message: messages.Layout) -&gt; None:
        message.stop()
        self.app.refresh()

    async def on_key(self, event: events.Key) -&gt; None:
        if event.key == &#34;tab&#34;:
            self.focus_next()
        elif event.key == &#34;shift+tab&#34;:
            self.focus_previous()
        else:
            await self.press(event.key)

    async def on_shutdown_request(self, event: events.ShutdownRequest) -&gt; None:
        log(&#34;shutdown request&#34;)
        await self.close_messages()

    async def on_resize(self, event: events.Resize) -&gt; None:
        await self.screen.post_message(event)

    async def action_press(self, key: str) -&gt; None:
        await self.press(key)

    async def action_quit(self) -&gt; None:
        await self.shutdown()

    async def action_bang(self) -&gt; None:
        1 / 0

    async def action_bell(self) -&gt; None:
        self.bell()

    async def action_add_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).add_class(class_name)

    async def action_remove_class_(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).remove_class(class_name)

    async def action_toggle_class(self, selector: str, class_name: str) -&gt; None:
        self.screen.query(selector).toggle_class(class_name)

    async def handle_styles_updated(self, message: messages.StylesUpdated) -&gt; None:
        self.stylesheet.update(self, animate=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
<li><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></li>
<li><a title="textual.message_pump.MessagePump" href="message_pump.html#textual.message_pump.MessagePump">MessagePump</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="textual.app.App.CSS"><code class="name">var <span class="ident">CSS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.app.App.CSS_PATH"><code class="name">var <span class="ident">CSS_PATH</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="textual.app.App.animator"><code class="name">var <span class="ident">animator</span> : textual._animator.Animator</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def animator(self) -&gt; Animator:
    return self._animator</code></pre>
</details>
</dd>
<dt id="textual.app.App.background"><code class="name">var <span class="ident">background</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.dark"><code class="name">var <span class="ident">dark</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.debug"><code class="name">var <span class="ident">debug</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if debug mode is enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def debug(self) -&gt; bool:
    &#34;&#34;&#34;Check if debug mode is enabled.&#34;&#34;&#34;
    return &#34;debug&#34; in self.features</code></pre>
</details>
</dd>
<dt id="textual.app.App.devtools_enabled"><code class="name">var <span class="ident">devtools_enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if devtools are enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def devtools_enabled(self) -&gt; bool:
    &#34;&#34;&#34;Check if devtools are enabled.&#34;&#34;&#34;
    return &#34;devtools&#34; in self.features</code></pre>
</details>
</dd>
<dt id="textual.app.App.focus_chain"><code class="name">var <span class="ident">focus_chain</span> : list[Widget]</code></dt>
<dd>
<div class="desc"><p>Get widgets that may receive focus, in focus order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def focus_chain(self) -&gt; list[Widget]:
    &#34;&#34;&#34;Get widgets that may receive focus, in focus order.&#34;&#34;&#34;
    widgets: list[Widget] = []
    add_widget = widgets.append
    root = self.screen
    stack: list[Iterator[Widget]] = [iter(root.focusable_children)]
    pop = stack.pop
    push = stack.append

    while stack:
        node = next(stack[-1], None)
        if node is None:
            pop()
        else:
            if node.is_container and node.can_focus_children:
                push(iter(node.focusable_children))
            else:
                if node.can_focus:
                    add_widget(node)

    return widgets</code></pre>
</details>
</dd>
<dt id="textual.app.App.is_headless"><code class="name">var <span class="ident">is_headless</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if the app is running in 'headless' mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_headless(self) -&gt; bool:
    &#34;&#34;&#34;Check if the app is running in &#39;headless&#39; mode.&#34;&#34;&#34;
    return &#34;headless&#34; in self.features</code></pre>
</details>
</dd>
<dt id="textual.app.App.size"><code class="name">var <span class="ident">size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Size:
    return Size(*self.console.size)</code></pre>
</details>
</dd>
<dt id="textual.app.App.sub_title"><code class="name">var <span class="ident">sub_title</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.title"><code class="name">var <span class="ident">title</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.app.App.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, action: str, default_namespace: object | None = None, modifiers: set[str] | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Perform an action.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Action encoded in a string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(
    self,
    action: str,
    default_namespace: object | None = None,
    modifiers: set[str] | None = None,
) -&gt; None:
    &#34;&#34;&#34;Perform an action.

    Args:
        action (str): Action encoded in a string.
    &#34;&#34;&#34;
    target, params = actions.parse(action)
    if &#34;.&#34; in target:
        destination, action_name = target.split(&#34;.&#34;, 1)
        if destination not in self._action_targets:
            raise ActionError(&#34;Action namespace {destination} is not known&#34;)
        action_target = getattr(self, destination)
    else:
        action_target = default_namespace or self
        action_name = target

    log(&#34;&lt;action&gt;&#34;, action)
    await self.dispatch_action(action_target, action_name, params)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_add_class_"><code class="name flex">
<span>async def <span class="ident">action_add_class_</span></span>(<span>self, selector: str, class_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_add_class_(self, selector: str, class_name: str) -&gt; None:
    self.screen.query(selector).add_class(class_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_bang"><code class="name flex">
<span>async def <span class="ident">action_bang</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_bang(self) -&gt; None:
    1 / 0</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_bell"><code class="name flex">
<span>async def <span class="ident">action_bell</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_bell(self) -&gt; None:
    self.bell()</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_press"><code class="name flex">
<span>async def <span class="ident">action_press</span></span>(<span>self, key: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_press(self, key: str) -&gt; None:
    await self.press(key)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_quit"><code class="name flex">
<span>async def <span class="ident">action_quit</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_quit(self) -&gt; None:
    await self.shutdown()</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_remove_class_"><code class="name flex">
<span>async def <span class="ident">action_remove_class_</span></span>(<span>self, selector: str, class_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_remove_class_(self, selector: str, class_name: str) -&gt; None:
    self.screen.query(selector).remove_class(class_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_screenshot"><code class="name flex">
<span>def <span class="ident">action_screenshot</span></span>(<span>self, path: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Action to save a screenshot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def action_screenshot(self, path: str | None = None) -&gt; None:
    &#34;&#34;&#34;Action to save a screenshot.&#34;&#34;&#34;
    self.save_screenshot(path)</code></pre>
</details>
</dd>
<dt id="textual.app.App.action_toggle_class"><code class="name flex">
<span>async def <span class="ident">action_toggle_class</span></span>(<span>self, selector: str, class_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action_toggle_class(self, selector: str, class_name: str) -&gt; None:
    self.screen.query(selector).toggle_class(class_name)</code></pre>
</details>
</dd>
<dt id="textual.app.App.bell"><code class="name flex">
<span>def <span class="ident">bell</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Play the console 'bell'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bell(self) -&gt; None:
    &#34;&#34;&#34;Play the console &#39;bell&#39;.&#34;&#34;&#34;
    self.console.bell()</code></pre>
</details>
</dd>
<dt id="textual.app.App.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, keys: str, action: str, description: str = '', show: bool = True, key_display: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Bind a key to an action.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keys</code></strong> :&ensp;<code>str</code></dt>
<dd>A comma separated list of keys, i.e.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Action to bind to.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Short description of action. Defaults to "".</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Show key in UI. Defaults to True.</dd>
<dt><strong><code>key_display</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Replacement text for key, or None to use default. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind(
    self,
    keys: str,
    action: str,
    description: str = &#34;&#34;,
    show: bool = True,
    key_display: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Bind a key to an action.

    Args:
        keys (str): A comma separated list of keys, i.e.
        action (str): Action to bind to.
        description (str, optional): Short description of action. Defaults to &#34;&#34;.
        show (bool, optional): Show key in UI. Defaults to True.
        key_display (str, optional): Replacement text for key, or None to use default. Defaults to None.
    &#34;&#34;&#34;
    self.bindings.bind(
        keys, action, description, show=show, key_display=key_display
    )</code></pre>
</details>
</dd>
<dt id="textual.app.App.broker_event"><code class="name flex">
<span>async def <span class="ident">broker_event</span></span>(<span>self, event_name: str, event: events.Event, default_namespace: object | None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Allow the app an opportunity to dispatch events to action system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code>str</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>event</code></strong> :&ensp;<code>events.Event</code></dt>
<dd>An event object.</dd>
</dl>
<p>default_namespace (object | None): TODO: <em>description</em></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if an action was processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def broker_event(
    self, event_name: str, event: events.Event, default_namespace: object | None
) -&gt; bool:
    &#34;&#34;&#34;Allow the app an opportunity to dispatch events to action system.

    Args:
        event_name (str): _description_
        event (events.Event): An event object.
        default_namespace (object | None): TODO: _description_

    Returns:
        bool: True if an action was processed.
    &#34;&#34;&#34;
    event.stop()
    try:
        style = getattr(event, &#34;style&#34;)
    except AttributeError:
        return False
    try:
        modifiers, action = extract_handler_actions(event_name, style.meta)
    except NoHandler:
        return False
    if isinstance(action, str):
        await self.action(
            action, default_namespace=default_namespace, modifiers=modifiers
        )
    elif callable(action):
        await action()
    else:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="textual.app.App.capture_mouse"><code class="name flex">
<span>async def <span class="ident">capture_mouse</span></span>(<span>self, widget: Widget | None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Send all mouse events to the given widget, disable mouse capture.</p>
<h2 id="args">Args</h2>
<p>widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def capture_mouse(self, widget: Widget | None) -&gt; None:
    &#34;&#34;&#34;Send all mouse events to the given widget, disable mouse capture.

    Args:
        widget (Widget | None): If a widget, capture mouse event, or None to end mouse capture.
    &#34;&#34;&#34;
    if widget == self.mouse_captured:
        return
    if self.mouse_captured is not None:
        await self.mouse_captured.post_message(
            events.MouseRelease(self, self.mouse_position)
        )
    self.mouse_captured = widget
    if widget is not None:
        await widget.post_message(events.MouseCapture(self, self.mouse_position))</code></pre>
</details>
</dd>
<dt id="textual.app.App.close_all"><code class="name flex">
<span>async def <span class="ident">close_all</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close_all(self) -&gt; None:
    while self.registry:
        child = self.registry.pop()
        await child.close_messages()</code></pre>
</details>
</dd>
<dt id="textual.app.App.compose"><code class="name flex">
<span>def <span class="ident">compose</span></span>(<span>self) ‑> Iterable[<a title="textual.widget.Widget" href="widget.html#textual.widget.Widget">Widget</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Yield child widgets for a container.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose(self) -&gt; ComposeResult:
    &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
    return
    yield</code></pre>
</details>
</dd>
<dt id="textual.app.App.dispatch_action"><code class="name flex">
<span>async def <span class="ident">dispatch_action</span></span>(<span>self, namespace: object, action_name: str, params: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dispatch_action(
    self, namespace: object, action_name: str, params: Any
) -&gt; None:
    log(
        &#34;&lt;action&gt;&#34;,
        namespace=namespace,
        action_name=action_name,
        params=params,
    )
    _rich_traceback_guard = True
    method_name = f&#34;action_{action_name}&#34;
    method = getattr(namespace, method_name, None)
    if callable(method):
        await invoke(method, *params)</code></pre>
</details>
</dd>
<dt id="textual.app.App.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self, result: ReturnType | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Exit the app, and return the supplied result.</p>
<h2 id="args">Args</h2>
<p>result (ReturnType | None, optional): Return value. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit(self, result: ReturnType | None = None) -&gt; None:
    &#34;&#34;&#34;Exit the app, and return the supplied result.

    Args:
        result (ReturnType | None, optional): Return value. Defaults to None.
    &#34;&#34;&#34;
    self._return_value = result
    self.close_messages_no_wait()</code></pre>
</details>
</dd>
<dt id="textual.app.App.export_screenshot"><code class="name flex">
<span>def <span class="ident">export_screenshot</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Export a SVG screenshot of the current screen.</p>
<h2 id="args">Args</h2>
<p>path (str | None, optional): Path of the SVG to save, or None to
generate a path automatically. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_screenshot(self) -&gt; str:
    &#34;&#34;&#34;Export a SVG screenshot of the current screen.

    Args:
        path (str | None, optional): Path of the SVG to save, or None to
            generate a path automatically. Defaults to None.
    &#34;&#34;&#34;

    console = Console(
        width=self.console.width,
        height=self.console.height,
        file=io.StringIO(),
        force_terminal=True,
        color_system=&#34;truecolor&#34;,
        record=True,
    )
    console.print(self.screen._compositor.render(full=True))
    return console.export_svg(title=self.title)</code></pre>
</details>
</dd>
<dt id="textual.app.App.fatal_error"><code class="name flex">
<span>def <span class="ident">fatal_error</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Exits the app after an unhandled exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fatal_error(self) -&gt; None:
    &#34;&#34;&#34;Exits the app after an unhandled exception.&#34;&#34;&#34;
    self.bell()
    traceback = Traceback(
        show_locals=True, width=None, locals_max_length=5, suppress=[rich]
    )
    self._exit_renderables.append(
        Segments(self.console.render(traceback, self.console.options))
    )
    self.close_messages_no_wait()</code></pre>
</details>
</dd>
<dt id="textual.app.App.focus_next"><code class="name flex">
<span>def <span class="ident">focus_next</span></span>(<span>self) ‑> Widget | None</span>
</code></dt>
<dd>
<div class="desc"><p>Focus the next widget.</p>
<h2 id="returns">Returns</h2>
<p>Widget | None: Newly focused widget, or None for no focus.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus_next(self) -&gt; Widget | None:
    &#34;&#34;&#34;Focus the next widget.

    Returns:
        Widget | None: Newly focused widget, or None for no focus.
    &#34;&#34;&#34;
    return self._move_focus(1)</code></pre>
</details>
</dd>
<dt id="textual.app.App.focus_previous"><code class="name flex">
<span>def <span class="ident">focus_previous</span></span>(<span>self) ‑> Widget | None</span>
</code></dt>
<dd>
<div class="desc"><p>Focus the previous widget.</p>
<h2 id="returns">Returns</h2>
<p>Widget | None: Newly focused widget, or None for no focus.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus_previous(self) -&gt; Widget | None:
    &#34;&#34;&#34;Focus the previous widget.

    Returns:
        Widget | None: Newly focused widget, or None for no focus.
    &#34;&#34;&#34;
    return self._move_focus(-1)</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_child"><code class="name flex">
<span>def <span class="ident">get_child</span></span>(<span>self, id: str) ‑> <a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shorthand for self.screen.get_child(id: str)
Returns the first child (immediate descendent) of this DOMNode
with the given ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the node to search for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DOMNode</code></dt>
<dd>The first child of this node with the specified ID.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NoMatchingNodesError</code></dt>
<dd>if no children could be found for this ID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_child(self, id: str) -&gt; DOMNode:
    &#34;&#34;&#34;Shorthand for self.screen.get_child(id: str)
    Returns the first child (immediate descendent) of this DOMNode
    with the given ID.

    Args:
        id (str): The ID of the node to search for.

    Returns:
        DOMNode: The first child of this node with the specified ID.

    Raises:
        NoMatchingNodesError: if no children could be found for this ID
    &#34;&#34;&#34;
    return self.screen.get_child(id)</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_css_variables"><code class="name flex">
<span>def <span class="ident">get_css_variables</span></span>(<span>self) ‑> dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a mapping of variables used to pre-populate CSS.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, str]</code></dt>
<dd>A mapping of variable name to value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_css_variables(self) -&gt; dict[str, str]:
    &#34;&#34;&#34;Get a mapping of variables used to pre-populate CSS.

    Returns:
        dict[str, str]: A mapping of variable name to value.
    &#34;&#34;&#34;
    variables = self.design.generate(self.dark)
    return variables</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_driver_class"><code class="name flex">
<span>def <span class="ident">get_driver_class</span></span>(<span>self) ‑> Type[<a title="textual.driver.Driver" href="driver.html#textual.driver.Driver">Driver</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a driver class for this platform.</p>
<p>Called by the constructor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Driver</code></dt>
<dd>A Driver class which manages input and display.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_driver_class(self) -&gt; Type[Driver]:
    &#34;&#34;&#34;Get a driver class for this platform.

    Called by the constructor.

    Returns:
        Driver: A Driver class which manages input and display.
    &#34;&#34;&#34;
    driver_class: Type[Driver]
    if WINDOWS:
        from .drivers.windows_driver import WindowsDriver

        driver_class = WindowsDriver
    else:
        from .drivers.linux_driver import LinuxDriver

        driver_class = LinuxDriver
    return driver_class</code></pre>
</details>
</dd>
<dt id="textual.app.App.get_widget_at"><code class="name flex">
<span>def <span class="ident">get_widget_at</span></span>(<span>self, x: int, y: int) ‑> tuple[Widget, Region]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the widget under the given coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>X Coord.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Y Coord.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[Widget, Region]</code></dt>
<dd>The widget and the widget's screen region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_widget_at(self, x: int, y: int) -&gt; tuple[Widget, Region]:
    &#34;&#34;&#34;Get the widget under the given coordinates.

    Args:
        x (int): X Coord.
        y (int): Y Coord.

    Returns:
        tuple[Widget, Region]: The widget and the widget&#39;s screen region.
    &#34;&#34;&#34;
    return self.screen.get_widget_at(x, y)</code></pre>
</details>
</dd>
<dt id="textual.app.App.handle_layout"><code class="name flex">
<span>async def <span class="ident">handle_layout</span></span>(<span>self, message: messages.Layout) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_layout(self, message: messages.Layout) -&gt; None:
    message.stop()
    self.app.refresh()</code></pre>
</details>
</dd>
<dt id="textual.app.App.handle_styles_updated"><code class="name flex">
<span>async def <span class="ident">handle_styles_updated</span></span>(<span>self, message: messages.StylesUpdated) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_styles_updated(self, message: messages.StylesUpdated) -&gt; None:
    self.stylesheet.update(self, animate=True)</code></pre>
</details>
</dd>
<dt id="textual.app.App.handle_update"><code class="name flex">
<span>async def <span class="ident">handle_update</span></span>(<span>self, message: messages.Update) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_update(self, message: messages.Update) -&gt; None:
    message.stop()
    self.app.refresh()</code></pre>
</details>
</dd>
<dt id="textual.app.App.is_mounted"><code class="name flex">
<span>def <span class="ident">is_mounted</span></span>(<span>self, widget: Widget) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_mounted(self, widget: Widget) -&gt; bool:
    return widget in self.registry</code></pre>
</details>
</dd>
<dt id="textual.app.App.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, *objects: Any, verbosity: int = 1, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Write to logs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*objects</code></strong> :&ensp;<code>Any</code></dt>
<dd>Positional arguments are converted to string and written to logs.</dd>
<dt><strong><code>verbosity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Verbosity level 0-3. Defaults to 1.</dd>
</dl>
<p>_textual_calling_frame (inspect.FrameInfo | None): The frame info to include in
the log message sent to the devtools server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(
    self,
    *objects: Any,
    verbosity: int = 1,
    _textual_calling_frame: inspect.FrameInfo | None = None,
    **kwargs,
) -&gt; None:
    &#34;&#34;&#34;Write to logs.

    Args:
        *objects (Any): Positional arguments are converted to string and written to logs.
        verbosity (int, optional): Verbosity level 0-3. Defaults to 1.
        _textual_calling_frame (inspect.FrameInfo | None): The frame info to include in
            the log message sent to the devtools server.
    &#34;&#34;&#34;
    if verbosity &gt; self.log_verbosity:
        return

    if self.devtools.is_connected and not _textual_calling_frame:
        _textual_calling_frame = inspect.stack()[1]

    try:
        if len(objects) == 1 and not kwargs:
            if self._log_console is not None:
                self._log_console.print(objects[0])
            if self.devtools.is_connected:
                self.devtools.log(
                    DevtoolsLog(objects, caller=_textual_calling_frame)
                )
        else:
            output = &#34; &#34;.join(str(arg) for arg in objects)
            if kwargs:
                key_values = &#34; &#34;.join(
                    f&#34;{key}={value!r}&#34; for key, value in kwargs.items()
                )
                output = f&#34;{output} {key_values}&#34; if output else key_values
            if self._log_console is not None:
                self._log_console.print(output, soft_wrap=True)
            if self.devtools.is_connected:
                self.devtools.log(
                    DevtoolsLog(output, caller=_textual_calling_frame)
                )
    except Exception as error:
        self.on_exception(error)</code></pre>
</details>
</dd>
<dt id="textual.app.App.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>self, renderable: RenderableType, max_width=100000) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get the optimal width for a widget or renderable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>renderable</code></strong> :&ensp;<code>RenderableType</code></dt>
<dd>A renderable (including Widget)</dd>
<dt><strong><code>max_width</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>Maximum width. Defaults to 100_000.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of cells required to render.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure(self, renderable: RenderableType, max_width=100_000) -&gt; int:
    &#34;&#34;&#34;Get the optimal width for a widget or renderable.

    Args:
        renderable (RenderableType): A renderable (including Widget)
        max_width ([type], optional): Maximum width. Defaults to 100_000.

    Returns:
        int: Number of cells required to render.
    &#34;&#34;&#34;
    measurement = Measurement.get(
        self.console, self.console.options.update(max_width=max_width), renderable
    )
    return measurement.maximum</code></pre>
</details>
</dd>
<dt id="textual.app.App.mount"><code class="name flex">
<span>def <span class="ident">mount</span></span>(<span>self, *anon_widgets: Widget, **widgets: Widget) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
    self.register(self.screen, *anon_widgets, **widgets)</code></pre>
</details>
</dd>
<dt id="textual.app.App.on_event"><code class="name flex">
<span>async def <span class="ident">on_event</span></span>(<span>self, event: events.Event) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_event(self, event: events.Event) -&gt; None:
    # Handle input events that haven&#39;t been forwarded
    # If the event has been forwarded it may have bubbled up back to the App
    if isinstance(event, events.Mount):
        screen = Screen()
        self.register(self, screen)
        self.push_screen(screen)
        await super().on_event(event)

    elif isinstance(event, events.InputEvent) and not event.is_forwarded:
        if isinstance(event, events.MouseEvent):
            # Record current mouse position on App
            self.mouse_position = Offset(event.x, event.y)
        if isinstance(event, events.Key) and self.focused is not None:
            # Key events are sent direct to focused widget
            if self.bindings.allow_forward(event.key):
                await self.focused.forward_event(event)
            else:
                # Key has allow_forward=False which disallows forward to focused widget
                await super().on_event(event)
        else:
            # Forward the event to the view
            await self.screen.forward_event(event)
    else:
        await super().on_event(event)</code></pre>
</details>
</dd>
<dt id="textual.app.App.on_exception"><code class="name flex">
<span>def <span class="ident">on_exception</span></span>(<span>self, error: Exception) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called with an unhandled exception.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Exception</code></dt>
<dd>An exception instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_exception(self, error: Exception) -&gt; None:
    &#34;&#34;&#34;Called with an unhandled exception.

    Args:
        error (Exception): An exception instance.
    &#34;&#34;&#34;

    if hasattr(error, &#34;__rich__&#34;):
        # Exception has a rich method, so we can defer to that for the rendering
        self.panic(error)
    else:
        # Use default exception rendering
        self.fatal_error()</code></pre>
</details>
</dd>
<dt id="textual.app.App.on_idle"><code class="name flex">
<span>async def <span class="ident">on_idle</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Perform actions when there are no messages in the queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_idle(self) -&gt; None:
    &#34;&#34;&#34;Perform actions when there are no messages in the queue.&#34;&#34;&#34;
    if self._require_styles_update:
        await self.post_message(messages.StylesUpdated(self))
        self._require_styles_update = False</code></pre>
</details>
</dd>
<dt id="textual.app.App.on_key"><code class="name flex">
<span>async def <span class="ident">on_key</span></span>(<span>self, event: events.Key) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_key(self, event: events.Key) -&gt; None:
    if event.key == &#34;tab&#34;:
        self.focus_next()
    elif event.key == &#34;shift+tab&#34;:
        self.focus_previous()
    else:
        await self.press(event.key)</code></pre>
</details>
</dd>
<dt id="textual.app.App.on_mount"><code class="name flex">
<span>def <span class="ident">on_mount</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_mount(self) -&gt; None:
    widgets = list(self.compose())
    if widgets:
        self.mount(*widgets)</code></pre>
</details>
</dd>
<dt id="textual.app.App.on_resize"><code class="name flex">
<span>async def <span class="ident">on_resize</span></span>(<span>self, event: events.Resize) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_resize(self, event: events.Resize) -&gt; None:
    await self.screen.post_message(event)</code></pre>
</details>
</dd>
<dt id="textual.app.App.on_shutdown_request"><code class="name flex">
<span>async def <span class="ident">on_shutdown_request</span></span>(<span>self, event: events.ShutdownRequest) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_shutdown_request(self, event: events.ShutdownRequest) -&gt; None:
    log(&#34;shutdown request&#34;)
    await self.close_messages()</code></pre>
</details>
</dd>
<dt id="textual.app.App.panic"><code class="name flex">
<span>def <span class="ident">panic</span></span>(<span>self, *renderables: RenderableType) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Exits the app then displays a message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*renderables</code></strong> :&ensp;<code>RenderableType</code>, optional</dt>
<dd>Rich renderables to display on exit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panic(self, *renderables: RenderableType) -&gt; None:
    &#34;&#34;&#34;Exits the app then displays a message.

    Args:
        *renderables (RenderableType, optional): Rich renderables to display on exit.
    &#34;&#34;&#34;

    assert all(
        is_renderable(renderable) for renderable in renderables
    ), &#34;Can only call panic with strings or Rich renderables&#34;

    prerendered = [
        Segments(self.console.render(renderable, self.console.options))
        for renderable in renderables
    ]

    self._exit_renderables.extend(prerendered)
    self.close_messages_no_wait()</code></pre>
</details>
</dd>
<dt id="textual.app.App.press"><code class="name flex">
<span>async def <span class="ident">press</span></span>(<span>self, key: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Handle a key press.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>A key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the key was handled by a binding, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def press(self, key: str) -&gt; bool:
    &#34;&#34;&#34;Handle a key press.

    Args:
        key (str): A key

    Returns:
        bool: True if the key was handled by a binding, otherwise False
    &#34;&#34;&#34;
    try:
        binding = self.bindings.get_key(key)
    except NoBinding:
        return False
    else:
        await self.action(binding.action)
    return True</code></pre>
</details>
</dd>
<dt id="textual.app.App.process_messages"><code class="name flex">
<span>async def <span class="ident">process_messages</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def process_messages(self) -&gt; None:
    self._set_active()

    if self.devtools_enabled:
        try:
            await self.devtools.connect()
            self.log(f&#34;Connected to devtools ({self.devtools.url})&#34;)
        except DevtoolsConnectionError:
            self.log(f&#34;Couldn&#39;t connect to devtools ({self.devtools.url})&#34;)

    self.log(&#34;---&#34;)
    self.log(driver=self.driver_class)
    self.log(loop=asyncio.get_running_loop())
    self.log(features=self.features)

    try:
        if self.css_path is not None:
            self.stylesheet.read(self.css_path)
        if self.CSS is not None:
            self.stylesheet.add_source(
                self.CSS, path=f&#34;&lt;{self.__class__.__name__}&gt;&#34;
            )
    except Exception as error:
        self.on_exception(error)
        self._print_error_renderables()
        return

    if self.css_monitor:
        self.set_interval(0.5, self.css_monitor, name=&#34;css monitor&#34;)
        self.log(&#34;started&#34;, self.css_monitor)

    self._running = True
    try:
        load_event = events.Load(sender=self)
        await self.dispatch_message(load_event)

        driver = self._driver = self.driver_class(self.console, self)
        driver.start_application_mode()
        try:
            mount_event = events.Mount(sender=self)
            await self.dispatch_message(mount_event)

            self.title = self._title
            self.refresh()
            await self.animator.start()

            with redirect_stdout(StdoutRedirector(self.devtools, self._log_file)):  # type: ignore
                await self._ready()
                await super().process_messages()
                await self.animator.stop()
                await self.close_all()
        finally:
            driver.stop_application_mode()
    except Exception as error:
        self.on_exception(error)
    finally:
        self._running = False
        self._print_error_renderables()
        if self.devtools.is_connected:
            await self._disconnect_devtools()
            if self._log_console is not None:
                self._log_console.print(
                    f&#34;Disconnected from devtools ({self.devtools.url})&#34;
                )
        if self._log_file is not None:
            self._log_file.close()
            self._log_console = None</code></pre>
</details>
</dd>
<dt id="textual.app.App.push_screen"><code class="name flex">
<span>def <span class="ident">push_screen</span></span>(<span>self, screen: Screen | None = None) ‑> Screen</span>
</code></dt>
<dd>
<div class="desc"><p>Push a new screen on the screen stack.</p>
<h2 id="args">Args</h2>
<p>screen (Screen | None, optional): A new Screen instance or None to create
one internally. Defaults to None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Screen</code></dt>
<dd>Newly active screen.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_screen(self, screen: Screen | None = None) -&gt; Screen:
    &#34;&#34;&#34;Push a new screen on the screen stack.

    Args:
        screen (Screen | None, optional): A new Screen instance or None to create
            one internally. Defaults to None.

    Returns:
        Screen: Newly active screen.
    &#34;&#34;&#34;
    new_screen = Screen() if screen is None else screen
    self._screen_stack.append(new_screen)
    return new_screen</code></pre>
</details>
</dd>
<dt id="textual.app.App.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, selector: str | None = None) ‑> DOMQuery</span>
</code></dt>
<dd>
<div class="desc"><p>Get a DOM query in the current screen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A CSS selector or <code>None</code> for all nodes. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DOMQuery</code></dt>
<dd>A query object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, selector: str | None = None) -&gt; DOMQuery:
    &#34;&#34;&#34;Get a DOM query in the current screen.

    Args:
        selector (str, optional): A CSS selector or `None` for all nodes. Defaults to None.

    Returns:
        DOMQuery: A query object.
    &#34;&#34;&#34;
    from .css.query import DOMQuery

    return DOMQuery(self.screen, selector)</code></pre>
</details>
</dd>
<dt id="textual.app.App.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, *, repaint: bool = True, layout: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
    self._display(self.screen._compositor)</code></pre>
</details>
</dd>
<dt id="textual.app.App.refresh_css"><code class="name flex">
<span>def <span class="ident">refresh_css</span></span>(<span>self, animate: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh CSS.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Also execute CSS animations. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_css(self, animate: bool = True) -&gt; None:
    &#34;&#34;&#34;Refresh CSS.

    Args:
        animate (bool, optional): Also execute CSS animations. Defaults to True.
    &#34;&#34;&#34;
    stylesheet = self.app.stylesheet
    stylesheet.set_variables(self.get_css_variables())
    stylesheet.reparse()
    stylesheet.update(self.app, animate=animate)
    self.refresh(layout=True)</code></pre>
</details>
</dd>
<dt id="textual.app.App.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, parent: DOMNode, *anon_widgets: Widget, **widgets: Widget) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Mount widget(s) so they may receive events.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>Widget</code></dt>
<dd>Parent Widget</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(
    self, parent: DOMNode, *anon_widgets: Widget, **widgets: Widget
) -&gt; None:
    &#34;&#34;&#34;Mount widget(s) so they may receive events.

    Args:
        parent (Widget): Parent Widget
    &#34;&#34;&#34;
    if not anon_widgets and not widgets:
        raise AppError(
            &#34;Nothing to mount, did you forget parent as first positional arg?&#34;
        )
    name_widgets: Iterable[tuple[str | None, Widget]]
    name_widgets = [*((None, widget) for widget in anon_widgets), *widgets.items()]
    apply_stylesheet = self.stylesheet.apply

    for widget_id, widget in name_widgets:
        if widget not in self.registry:
            if widget_id is not None:
                widget.id = widget_id
            self._register_child(parent, widget)
            if widget.children:
                self.register(widget, *widget.children)
            apply_stylesheet(widget)

    for _widget_id, widget in name_widgets:
        widget.post_message_no_wait(events.Mount(sender=parent))</code></pre>
</details>
</dd>
<dt id="textual.app.App.remove"><code class="name flex">
<span>async def <span class="ident">remove</span></span>(<span>self, child: MessagePump) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remove(self, child: MessagePump) -&gt; None:
    self.registry.remove(child)</code></pre>
</details>
</dd>
<dt id="textual.app.App.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, styles: Style) ‑> Union[rich.console.ConsoleRenderable, rich.console.RichCast, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, styles: Style) -&gt; RenderableType:
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="textual.app.App.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self) ‑> ReturnType | None</span>
</code></dt>
<dd>
<div class="desc"><p>The entry point to run a Textual app.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self) -&gt; ReturnType | None:
    &#34;&#34;&#34;The entry point to run a Textual app.&#34;&#34;&#34;

    async def run_app() -&gt; None:
        await self.process_messages()

    if _ASYNCIO_GET_EVENT_LOOP_IS_DEPRECATED:
        # N.B. This doesn&#39;t work with Python&lt;3.10, as we end up with 2 event loops:
        asyncio.run(run_app())
    else:
        # However, this works with Python&lt;3.10:
        event_loop = asyncio.get_event_loop()
        event_loop.run_until_complete(run_app())

    return self._return_value</code></pre>
</details>
</dd>
<dt id="textual.app.App.save_screenshot"><code class="name flex">
<span>def <span class="ident">save_screenshot</span></span>(<span>self, path: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Save a screenshot of the current screen.</p>
<h2 id="args">Args</h2>
<p>path (str | None, optional): Path to SVG to save or None to pick
a filename automatically. Defaults to None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Filename of screenshot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_screenshot(self, path: str | None = None) -&gt; str:
    &#34;&#34;&#34;Save a screenshot of the current screen.

    Args:
        path (str | None, optional): Path to SVG to save or None to pick
            a filename automatically. Defaults to None.

    Returns:
        str: Filename of screenshot.
    &#34;&#34;&#34;
    self.bell()
    if path is None:
        svg_path = f&#34;{self.title.lower()}_{datetime.now().isoformat()}.svg&#34;
        svg_path = svg_path.replace(&#34;/&#34;, &#34;_&#34;).replace(&#34;\\&#34;, &#34;_&#34;)
    else:
        svg_path = path
    screenshot_svg = self.export_screenshot()
    with open(svg_path, &#34;w&#34;) as svg_file:
        svg_file.write(screenshot_svg)
    return svg_path</code></pre>
</details>
</dd>
<dt id="textual.app.App.set_focus"><code class="name flex">
<span>def <span class="ident">set_focus</span></span>(<span>self, widget: Widget | None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Focus (or unfocus) a widget. A focused widget will receive key events first.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget</code></strong> :&ensp;<code>Widget</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_focus(self, widget: Widget | None) -&gt; None:
    &#34;&#34;&#34;Focus (or unfocus) a widget. A focused widget will receive key events first.

    Args:
        widget (Widget): [description]
    &#34;&#34;&#34;
    self.log(&#34;set_focus&#34;, widget=widget)
    if widget == self.focused:
        # Widget is already focused
        return

    if widget is None:
        # No focus, so blur currently focused widget if it exists
        if self.focused is not None:
            self.focused.post_message_no_wait(events.Blur(self))
            self.focused.emit_no_wait(events.DescendantBlur(self))
            self.focused = None
    elif widget.can_focus:
        if self.focused != widget:
            if self.focused is not None:
                # Blur currently focused widget
                self.focused.post_message_no_wait(events.Blur(self))
                self.focused.emit_no_wait(events.DescendantBlur(self))
            # Change focus
            self.focused = widget
            # Send focus event
            widget.post_message_no_wait(events.Focus(self))
            widget.emit_no_wait(events.DescendantFocus(self))</code></pre>
</details>
</dd>
<dt id="textual.app.App.show_focus"><code class="name flex">
<span>def <span class="ident">show_focus</span></span>(<span>self) ‑> Widget | None</span>
</code></dt>
<dd>
<div class="desc"><p>Highlight the currently focused widget.</p>
<h2 id="returns">Returns</h2>
<p>Widget | None: Focused widget, or None for no focus.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_focus(self) -&gt; Widget | None:
    &#34;&#34;&#34;Highlight the currently focused widget.

    Returns:
        Widget | None: Focused widget, or None for no focus.
    &#34;&#34;&#34;
    return self._move_focus(0)</code></pre>
</details>
</dd>
<dt id="textual.app.App.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self):
    await self._disconnect_devtools()
    driver = self._driver
    assert driver is not None
    driver.disable_input()
    await self.close_messages()</code></pre>
</details>
</dd>
<dt id="textual.app.App.start_widget"><code class="name flex">
<span>def <span class="ident">start_widget</span></span>(<span>self, parent: Widget, widget: Widget) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Start a widget (run it's task) so that it can receive messages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>Widget</code></dt>
<dd>The parent of the Widget.</dd>
<dt><strong><code>widget</code></strong> :&ensp;<code>Widget</code></dt>
<dd>The Widget to start.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_widget(self, parent: Widget, widget: Widget) -&gt; None:
    &#34;&#34;&#34;Start a widget (run it&#39;s task) so that it can receive messages.

    Args:
        parent (Widget): The parent of the Widget.
        widget (Widget): The Widget to start.
    &#34;&#34;&#34;
    widget.set_parent(parent)
    widget.start_messages()
    widget.post_message_no_wait(events.Mount(sender=parent))</code></pre>
</details>
</dd>
<dt id="textual.app.App.update_styles"><code class="name flex">
<span>def <span class="ident">update_styles</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Request update of styles.</p>
<p>Should be called whenever CSS classes / pseudo classes change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_styles(self) -&gt; None:
    &#34;&#34;&#34;Request update of styles.

    Should be called whenever CSS classes / pseudo classes change.

    &#34;&#34;&#34;
    self._require_styles_update = True
    self.check_idle()</code></pre>
</details>
</dd>
<dt id="textual.app.App.watch_dark"><code class="name flex">
<span>def <span class="ident">watch_dark</span></span>(<span>self, dark: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Watches the dark bool.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_dark(self, dark: bool) -&gt; None:
    &#34;&#34;&#34;Watches the dark bool.&#34;&#34;&#34;
    self.screen.dark = dark
    self.refresh_css()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></b></code>:
<ul class="hlist">
<li><code><a title="textual.dom.DOMNode.add_child" href="dom.html#textual.dom.DOMNode.add_child">add_child</a></code></li>
<li><code><a title="textual.dom.DOMNode.add_children" href="dom.html#textual.dom.DOMNode.add_children">add_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.add_class" href="dom.html#textual.dom.DOMNode.add_class">add_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.ancestors" href="dom.html#textual.dom.DOMNode.ancestors">ancestors</a></code></li>
<li><code><a title="textual.dom.DOMNode.app" href="message_pump.html#textual.message_pump.MessagePump.app">app</a></code></li>
<li><code><a title="textual.dom.DOMNode.call_later" href="message_pump.html#textual.message_pump.MessagePump.call_later">call_later</a></code></li>
<li><code><a title="textual.dom.DOMNode.check_idle" href="message_pump.html#textual.message_pump.MessagePump.check_idle">check_idle</a></code></li>
<li><code><a title="textual.dom.DOMNode.close_messages" href="message_pump.html#textual.message_pump.MessagePump.close_messages">close_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.close_messages_no_wait" href="message_pump.html#textual.message_pump.MessagePump.close_messages_no_wait">close_messages_no_wait</a></code></li>
<li><code><a title="textual.dom.DOMNode.colors" href="dom.html#textual.dom.DOMNode.colors">colors</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier" href="dom.html#textual.dom.DOMNode.css_identifier">css_identifier</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier_styled" href="dom.html#textual.dom.DOMNode.css_identifier_styled">css_identifier_styled</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_path_nodes" href="dom.html#textual.dom.DOMNode.css_path_nodes">css_path_nodes</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_type" href="dom.html#textual.dom.DOMNode.css_type">css_type</a></code></li>
<li><code><a title="textual.dom.DOMNode.disable_messages" href="message_pump.html#textual.message_pump.MessagePump.disable_messages">disable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.dispatch_key" href="message_pump.html#textual.message_pump.MessagePump.dispatch_key">dispatch_key</a></code></li>
<li><code><a title="textual.dom.DOMNode.display" href="dom.html#textual.dom.DOMNode.display">display</a></code></li>
<li><code><a title="textual.dom.DOMNode.displayed_children" href="dom.html#textual.dom.DOMNode.displayed_children">displayed_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.enable_messages" href="message_pump.html#textual.message_pump.MessagePump.enable_messages">enable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.focusable_children" href="dom.html#textual.dom.DOMNode.focusable_children">focusable_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_message" href="message_pump.html#textual.message_pump.MessagePump.get_message">get_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_pseudo_classes" href="dom.html#textual.dom.DOMNode.get_pseudo_classes">get_pseudo_classes</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_class" href="dom.html#textual.dom.DOMNode.has_class">has_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_pseudo_class" href="dom.html#textual.dom.DOMNode.has_pseudo_class">has_pseudo_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.id" href="dom.html#textual.dom.DOMNode.id">id</a></code></li>
<li><code><a title="textual.dom.DOMNode.on_register" href="dom.html#textual.dom.DOMNode.on_register">on_register</a></code></li>
<li><code><a title="textual.dom.DOMNode.parent" href="dom.html#textual.dom.DOMNode.parent">parent</a></code></li>
<li><code><a title="textual.dom.DOMNode.peek_message" href="message_pump.html#textual.message_pump.MessagePump.peek_message">peek_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.post_priority_message" href="message_pump.html#textual.message_pump.MessagePump.post_priority_message">post_priority_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.pseudo_classes" href="dom.html#textual.dom.DOMNode.pseudo_classes">pseudo_classes</a></code></li>
<li><code><a title="textual.dom.DOMNode.remove_class" href="dom.html#textual.dom.DOMNode.remove_class">remove_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.screen" href="dom.html#textual.dom.DOMNode.screen">screen</a></code></li>
<li><code><a title="textual.dom.DOMNode.set_styles" href="dom.html#textual.dom.DOMNode.set_styles">set_styles</a></code></li>
<li><code><a title="textual.dom.DOMNode.text_style" href="dom.html#textual.dom.DOMNode.text_style">text_style</a></code></li>
<li><code><a title="textual.dom.DOMNode.toggle_class" href="dom.html#textual.dom.DOMNode.toggle_class">toggle_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.tree" href="dom.html#textual.dom.DOMNode.tree">tree</a></code></li>
<li><code><a title="textual.dom.DOMNode.walk_children" href="dom.html#textual.dom.DOMNode.walk_children">walk_children</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="textual.app.AppError"><code class="flex name class">
<span>class <span class="ident">AppError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual" href="index.html">textual</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.app.ActionError" href="#textual.app.ActionError">ActionError</a></code></h4>
</li>
<li>
<h4><code><a title="textual.app.App" href="#textual.app.App">App</a></code></h4>
<ul class="">
<li><code><a title="textual.app.App.CSS" href="#textual.app.App.CSS">CSS</a></code></li>
<li><code><a title="textual.app.App.CSS_PATH" href="#textual.app.App.CSS_PATH">CSS_PATH</a></code></li>
<li><code><a title="textual.app.App.action" href="#textual.app.App.action">action</a></code></li>
<li><code><a title="textual.app.App.action_add_class_" href="#textual.app.App.action_add_class_">action_add_class_</a></code></li>
<li><code><a title="textual.app.App.action_bang" href="#textual.app.App.action_bang">action_bang</a></code></li>
<li><code><a title="textual.app.App.action_bell" href="#textual.app.App.action_bell">action_bell</a></code></li>
<li><code><a title="textual.app.App.action_press" href="#textual.app.App.action_press">action_press</a></code></li>
<li><code><a title="textual.app.App.action_quit" href="#textual.app.App.action_quit">action_quit</a></code></li>
<li><code><a title="textual.app.App.action_remove_class_" href="#textual.app.App.action_remove_class_">action_remove_class_</a></code></li>
<li><code><a title="textual.app.App.action_screenshot" href="#textual.app.App.action_screenshot">action_screenshot</a></code></li>
<li><code><a title="textual.app.App.action_toggle_class" href="#textual.app.App.action_toggle_class">action_toggle_class</a></code></li>
<li><code><a title="textual.app.App.animator" href="#textual.app.App.animator">animator</a></code></li>
<li><code><a title="textual.app.App.background" href="#textual.app.App.background">background</a></code></li>
<li><code><a title="textual.app.App.bell" href="#textual.app.App.bell">bell</a></code></li>
<li><code><a title="textual.app.App.bind" href="#textual.app.App.bind">bind</a></code></li>
<li><code><a title="textual.app.App.broker_event" href="#textual.app.App.broker_event">broker_event</a></code></li>
<li><code><a title="textual.app.App.capture_mouse" href="#textual.app.App.capture_mouse">capture_mouse</a></code></li>
<li><code><a title="textual.app.App.close_all" href="#textual.app.App.close_all">close_all</a></code></li>
<li><code><a title="textual.app.App.compose" href="#textual.app.App.compose">compose</a></code></li>
<li><code><a title="textual.app.App.dark" href="#textual.app.App.dark">dark</a></code></li>
<li><code><a title="textual.app.App.debug" href="#textual.app.App.debug">debug</a></code></li>
<li><code><a title="textual.app.App.devtools_enabled" href="#textual.app.App.devtools_enabled">devtools_enabled</a></code></li>
<li><code><a title="textual.app.App.dispatch_action" href="#textual.app.App.dispatch_action">dispatch_action</a></code></li>
<li><code><a title="textual.app.App.exit" href="#textual.app.App.exit">exit</a></code></li>
<li><code><a title="textual.app.App.export_screenshot" href="#textual.app.App.export_screenshot">export_screenshot</a></code></li>
<li><code><a title="textual.app.App.fatal_error" href="#textual.app.App.fatal_error">fatal_error</a></code></li>
<li><code><a title="textual.app.App.focus_chain" href="#textual.app.App.focus_chain">focus_chain</a></code></li>
<li><code><a title="textual.app.App.focus_next" href="#textual.app.App.focus_next">focus_next</a></code></li>
<li><code><a title="textual.app.App.focus_previous" href="#textual.app.App.focus_previous">focus_previous</a></code></li>
<li><code><a title="textual.app.App.get_child" href="#textual.app.App.get_child">get_child</a></code></li>
<li><code><a title="textual.app.App.get_css_variables" href="#textual.app.App.get_css_variables">get_css_variables</a></code></li>
<li><code><a title="textual.app.App.get_driver_class" href="#textual.app.App.get_driver_class">get_driver_class</a></code></li>
<li><code><a title="textual.app.App.get_widget_at" href="#textual.app.App.get_widget_at">get_widget_at</a></code></li>
<li><code><a title="textual.app.App.handle_layout" href="#textual.app.App.handle_layout">handle_layout</a></code></li>
<li><code><a title="textual.app.App.handle_styles_updated" href="#textual.app.App.handle_styles_updated">handle_styles_updated</a></code></li>
<li><code><a title="textual.app.App.handle_update" href="#textual.app.App.handle_update">handle_update</a></code></li>
<li><code><a title="textual.app.App.is_headless" href="#textual.app.App.is_headless">is_headless</a></code></li>
<li><code><a title="textual.app.App.is_mounted" href="#textual.app.App.is_mounted">is_mounted</a></code></li>
<li><code><a title="textual.app.App.log" href="#textual.app.App.log">log</a></code></li>
<li><code><a title="textual.app.App.measure" href="#textual.app.App.measure">measure</a></code></li>
<li><code><a title="textual.app.App.mount" href="#textual.app.App.mount">mount</a></code></li>
<li><code><a title="textual.app.App.on_event" href="#textual.app.App.on_event">on_event</a></code></li>
<li><code><a title="textual.app.App.on_exception" href="#textual.app.App.on_exception">on_exception</a></code></li>
<li><code><a title="textual.app.App.on_idle" href="#textual.app.App.on_idle">on_idle</a></code></li>
<li><code><a title="textual.app.App.on_key" href="#textual.app.App.on_key">on_key</a></code></li>
<li><code><a title="textual.app.App.on_mount" href="#textual.app.App.on_mount">on_mount</a></code></li>
<li><code><a title="textual.app.App.on_resize" href="#textual.app.App.on_resize">on_resize</a></code></li>
<li><code><a title="textual.app.App.on_shutdown_request" href="#textual.app.App.on_shutdown_request">on_shutdown_request</a></code></li>
<li><code><a title="textual.app.App.panic" href="#textual.app.App.panic">panic</a></code></li>
<li><code><a title="textual.app.App.press" href="#textual.app.App.press">press</a></code></li>
<li><code><a title="textual.app.App.process_messages" href="#textual.app.App.process_messages">process_messages</a></code></li>
<li><code><a title="textual.app.App.push_screen" href="#textual.app.App.push_screen">push_screen</a></code></li>
<li><code><a title="textual.app.App.query" href="#textual.app.App.query">query</a></code></li>
<li><code><a title="textual.app.App.refresh" href="#textual.app.App.refresh">refresh</a></code></li>
<li><code><a title="textual.app.App.refresh_css" href="#textual.app.App.refresh_css">refresh_css</a></code></li>
<li><code><a title="textual.app.App.register" href="#textual.app.App.register">register</a></code></li>
<li><code><a title="textual.app.App.remove" href="#textual.app.App.remove">remove</a></code></li>
<li><code><a title="textual.app.App.render" href="#textual.app.App.render">render</a></code></li>
<li><code><a title="textual.app.App.run" href="#textual.app.App.run">run</a></code></li>
<li><code><a title="textual.app.App.save_screenshot" href="#textual.app.App.save_screenshot">save_screenshot</a></code></li>
<li><code><a title="textual.app.App.set_focus" href="#textual.app.App.set_focus">set_focus</a></code></li>
<li><code><a title="textual.app.App.show_focus" href="#textual.app.App.show_focus">show_focus</a></code></li>
<li><code><a title="textual.app.App.shutdown" href="#textual.app.App.shutdown">shutdown</a></code></li>
<li><code><a title="textual.app.App.size" href="#textual.app.App.size">size</a></code></li>
<li><code><a title="textual.app.App.start_widget" href="#textual.app.App.start_widget">start_widget</a></code></li>
<li><code><a title="textual.app.App.sub_title" href="#textual.app.App.sub_title">sub_title</a></code></li>
<li><code><a title="textual.app.App.title" href="#textual.app.App.title">title</a></code></li>
<li><code><a title="textual.app.App.update_styles" href="#textual.app.App.update_styles">update_styles</a></code></li>
<li><code><a title="textual.app.App.watch_dark" href="#textual.app.App.watch_dark">watch_dark</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.app.AppError" href="#textual.app.AppError">AppError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>