<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.widget API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.widget</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

from fractions import Fraction
from operator import attrgetter
from typing import (
    TYPE_CHECKING,
    Any,
    Awaitable,
    Callable,
    ClassVar,
    Collection,
    Iterable,
    NamedTuple,
)

import rich.repr
from rich.align import Align
from rich.console import Console, RenderableType
from rich.measure import Measurement

from rich.segment import Segment
from rich.style import Style
from rich.styled import Styled
from rich.text import Text

from . import errors, events, messages
from ._animator import BoundAnimator
from ._arrange import arrange, DockArrangeResult
from ._context import active_app
from ._layout import ArrangeResult, Layout
from ._segment_tools import line_crop
from ._styles_cache import StylesCache
from ._types import Lines
from .box_model import BoxModel, get_box_model
from .dom import DOMNode
from .geometry import Offset, Region, Size, Spacing, clamp
from .layouts.vertical import VerticalLayout
from .message import Message
from .reactive import Reactive, watch

if TYPE_CHECKING:
    from .app import App, ComposeResult
    from .scrollbar import (
        ScrollBar,
        ScrollDown,
        ScrollLeft,
        ScrollRight,
        ScrollTo,
        ScrollUp,
    )


class RenderCache(NamedTuple):
    &#34;&#34;&#34;Stores results of a previous render.&#34;&#34;&#34;

    size: Size
    lines: Lines

    @property
    def cursor_line(self) -&gt; int | None:
        for index, line in enumerate(self.lines):
            for _text, style, _control in line:
                if style and style._meta and style.meta.get(&#34;cursor&#34;, False):
                    return index
        return None


@rich.repr.auto
class Widget(DOMNode):

    CSS = &#34;&#34;&#34;
    Widget{
        scrollbar-background: $panel-darken-1;
        scrollbar-background-hover: $panel-darken-2;
        scrollbar-color: $primary-lighten-1;
        scrollbar-color-active: $warning-darken-1;
        scrollbar-size-vertical: 2;
        scrollbar-size-horizontal: 1;
    }
    &#34;&#34;&#34;

    COMPONENT_CLASSES: ClassVar[set[str]] = set()

    can_focus: bool = False
    can_focus_children: bool = True

    def __init__(
        self,
        *children: Widget,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
    ) -&gt; None:

        self._size = Size(0, 0)
        self._container_size = Size(0, 0)
        self._layout_required = False
        self._repaint_required = False
        self._default_layout = VerticalLayout()
        self._animate: BoundAnimator | None = None
        self._reactive_watches: dict[str, Callable] = {}
        self.highlight_style: Style | None = None

        self._vertical_scrollbar: ScrollBar | None = None
        self._horizontal_scrollbar: ScrollBar | None = None

        self._render_cache = RenderCache(Size(0, 0), [])
        # Regions which need to be updated (in Widget)
        self._dirty_regions: set[Region] = set()
        # Regions which need to be transferred from cache to screen
        self._repaint_regions: set[Region] = set()

        # Cache the auto content dimensions
        # TODO: add mechanism to explicitly clear this
        self._content_width_cache: tuple[object, int] = (None, 0)
        self._content_height_cache: tuple[object, int] = (None, 0)

        self._arrangement: DockArrangeResult | None = None
        self._arrangement_cache_key: tuple[int, Size] = (-1, Size())

        self._styles_cache = StylesCache()

        super().__init__(name=name, id=id, classes=classes)
        self.add_children(*children)

    virtual_size = Reactive(Size(0, 0), layout=True)
    auto_width = Reactive(True)
    auto_height = Reactive(True)
    has_focus = Reactive(False)
    descendant_has_focus = Reactive(False)
    mouse_over = Reactive(False)
    scroll_x = Reactive(0.0, repaint=False, layout=False)
    scroll_y = Reactive(0.0, repaint=False, layout=False)
    scroll_target_x = Reactive(0.0, repaint=False)
    scroll_target_y = Reactive(0.0, repaint=False)
    show_vertical_scrollbar = Reactive(False, layout=True)
    show_horizontal_scrollbar = Reactive(False, layout=True)

    def _arrange(self, size: Size) -&gt; DockArrangeResult:
        &#34;&#34;&#34;Arrange children.

        Args:
            size (Size): Size of container.

        Returns:
            ArrangeResult: Widget locations.
        &#34;&#34;&#34;

        arrange_cache_key = (self.children._updates, size)
        if (
            self._arrangement is not None
            and arrange_cache_key == self._arrangement_cache_key
        ):
            return self._arrangement

        self._arrangement_cache_key = arrange_cache_key
        self._arrangement = arrange(self, self.children, size, self.screen.size)
        return self._arrangement

    def _clear_arrangement_cache(self) -&gt; None:
        self._arrangement = None

    def watch_show_horizontal_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_horizontal_scrollbar attribute.

        Args:
            value (bool): Show horizontal scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def watch_show_vertical_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_vertical_scrollbar attribute.

        Args:
            value (bool): Show vertical scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
        self.app.register(self, *anon_widgets, **widgets)
        self.screen.refresh()

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def on_register(self, app: App) -&gt; None:
        &#34;&#34;&#34;Called when the instance is registered.

        Args:
            app (App): App instance.
        &#34;&#34;&#34;
        # Parse the Widget&#39;s CSS
        for path, css in self.css:
            self.app.stylesheet.add_source(css, path=path, is_default_css=True)

    def get_box_model(
        self, container: Size, viewport: Size, fraction_unit: Fraction
    ) -&gt; BoxModel:
        &#34;&#34;&#34;Process the box model for this widget.

        Args:
            container (Size): The size of the container widget (with a layout)
            viewport (Size): The viewport size.

        Returns:
            BoxModel: The size and margin for this widget.
        &#34;&#34;&#34;
        box_model = get_box_model(
            self.styles,
            container,
            viewport,
            fraction_unit,
            self.get_content_width,
            self.get_content_height,
        )
        return box_model

    def get_content_width(self, container: Size, viewport: Size) -&gt; int:
        &#34;&#34;&#34;Gets the width of the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.

        Returns:
            int: The optimal width of the content.
        &#34;&#34;&#34;
        if self.is_container:
            assert self.layout is not None
            return (
                self.layout.get_content_width(self, container, viewport)
                + self.scrollbar_size_vertical
            )

        cache_key = container.width
        if self._content_width_cache[0] == cache_key:
            return self._content_width_cache[1]

        console = self.app.console
        renderable = self.render()
        measurement = Measurement.get(
            console,
            console.options.update_width(container.width),
            renderable,
        )
        width = measurement.maximum
        self._content_width_cache = (cache_key, width)
        return width

    def get_content_height(self, container: Size, viewport: Size, width: int) -&gt; int:
        &#34;&#34;&#34;Gets the height (number of lines) in the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.
            width (int): Width of renderable.

        Returns:
            int: The height of the content.
        &#34;&#34;&#34;
        if self.is_container:
            assert self.layout is not None
            height = (
                self.layout.get_content_height(
                    self,
                    container,
                    viewport,
                    width,
                )
                + self.scrollbar_size_horizontal
            )
        else:
            cache_key = width

            if self._content_height_cache[0] == cache_key:
                return self._content_height_cache[1]

            renderable = self.render()
            options = self.console.options.update_width(width).update(highlight=False)
            segments = self.console.render(renderable, options)
            # Cheaper than counting the lines returned from render_lines!
            height = sum(text.count(&#34;\n&#34;) for text, _, _ in segments)
            self._content_height_cache = (cache_key, height)

        return height

    def watch_scroll_x(self, new_value: float) -&gt; None:
        self.horizontal_scrollbar.position = int(new_value)
        self.refresh(layout=True)
        self.horizontal_scrollbar.refresh()

    def watch_scroll_y(self, new_value: float) -&gt; None:
        self.vertical_scrollbar.position = int(new_value)
        self.refresh(layout=True)
        self.vertical_scrollbar.refresh()

    def validate_scroll_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_target_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    def validate_scroll_target_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    @property
    def max_scroll_x(self) -&gt; int:
        &#34;&#34;&#34;The maximum value of `scroll_x`.&#34;&#34;&#34;
        return max(
            0,
            self.virtual_size.width
            - self.container_size.width
            + self.scrollbar_size_vertical,
        )

    @property
    def max_scroll_y(self) -&gt; int:
        &#34;&#34;&#34;The maximum value of `scroll_y`.&#34;&#34;&#34;
        return max(
            0,
            self.virtual_size.height
            - self.container_size.height
            + self.scrollbar_size_horizontal,
        )

    @property
    def vertical_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._vertical_scrollbar is not None:
            return self._vertical_scrollbar
        self._vertical_scrollbar = scroll_bar = ScrollBar(
            vertical=True, name=&#34;vertical&#34;, thickness=self.scrollbar_size_vertical
        )
        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    @property
    def horizontal_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._horizontal_scrollbar is not None:
            return self._horizontal_scrollbar
        self._horizontal_scrollbar = scroll_bar = ScrollBar(
            vertical=False, name=&#34;horizontal&#34;, thickness=self.scrollbar_size_horizontal
        )

        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    def _refresh_scrollbars(self) -&gt; None:
        &#34;&#34;&#34;Refresh scrollbar visibility.&#34;&#34;&#34;
        if not self.is_scrollable:
            return

        styles = self.styles
        overflow_x = styles.overflow_x
        overflow_y = styles.overflow_y
        width, height = self.container_size

        show_horizontal = self.show_horizontal_scrollbar
        if overflow_x == &#34;hidden&#34;:
            show_horizontal = False
        if overflow_x == &#34;scroll&#34;:
            show_horizontal = True
        elif overflow_x == &#34;auto&#34;:
            show_horizontal = self.virtual_size.width &gt; width

        show_vertical = self.show_vertical_scrollbar
        if overflow_y == &#34;hidden&#34;:
            show_vertical = False
        elif overflow_y == &#34;scroll&#34;:
            show_vertical = True
        elif overflow_y == &#34;auto&#34;:
            show_vertical = self.virtual_size.height &gt; height

        self.show_horizontal_scrollbar = show_horizontal
        self.show_vertical_scrollbar = show_vertical
        self.horizontal_scrollbar.display = show_horizontal
        self.vertical_scrollbar.display = show_vertical

    @property
    def scrollbars_enabled(self) -&gt; tuple[bool, bool]:
        &#34;&#34;&#34;A tuple of booleans that indicate if scrollbars are enabled.

        Returns:
            tuple[bool, bool]: A tuple of (&lt;vertical scrollbar enabled&gt;, &lt;horizontal scrollbar enabled&gt;)

        &#34;&#34;&#34;
        if not self.is_scrollable:
            return False, False

        enabled = self.show_vertical_scrollbar, self.show_horizontal_scrollbar
        return enabled

    @property
    def scrollbar_size_vertical(self) -&gt; int:
        &#34;&#34;&#34;Get the width used by the *vertical* scrollbar.&#34;&#34;&#34;
        return (
            self.styles.scrollbar_size_vertical if self.show_vertical_scrollbar else 0
        )

    @property
    def scrollbar_size_horizontal(self) -&gt; int:
        &#34;&#34;&#34;Get the height used by the *horizontal* scrollbar.&#34;&#34;&#34;
        return (
            self.styles.scrollbar_size_horizontal
            if self.show_horizontal_scrollbar
            else 0
        )

    @property
    def scrollbar_gutter(self) -&gt; Spacing:
        gutter = Spacing(
            0, self.scrollbar_size_vertical, self.scrollbar_size_horizontal, 0
        )
        return gutter

    @property
    def gutter(self) -&gt; Spacing:
        &#34;&#34;&#34;Spacing for padding / border / scrollbars.&#34;&#34;&#34;
        return self.styles.gutter + self.scrollbar_gutter

    @property
    def size(self) -&gt; Size:
        &#34;&#34;&#34;The size of the content area.&#34;&#34;&#34;
        return self.content_region.size

    @property
    def outer_size(self) -&gt; Size:
        &#34;&#34;&#34;The size of the widget (including padding and border).&#34;&#34;&#34;
        return self._size

    @property
    def container_size(self) -&gt; Size:
        &#34;&#34;&#34;The size of the container (parent widget).&#34;&#34;&#34;
        return self._container_size

    @property
    def content_region(self) -&gt; Region:
        &#34;&#34;&#34;Gets an absolute region containing the content (minus padding and border).&#34;&#34;&#34;
        content_region = self.region.shrink(self.gutter)
        return content_region

    @property
    def content_offset(self) -&gt; Offset:
        &#34;&#34;&#34;An offset from the Widget origin where the content begins.&#34;&#34;&#34;
        x, y = self.gutter.top_left
        return Offset(x, y)

    @property
    def region(self) -&gt; Region:
        &#34;&#34;&#34;The region occupied by this widget, relative to the Screen.&#34;&#34;&#34;
        try:
            return self.screen.find_widget(self).region
        except errors.NoWidget:
            return Region()

    @property
    def virtual_region(self) -&gt; Region:
        &#34;&#34;&#34;The widget region relative to it&#39;s container. Which may not be visible,
        depending on scroll offset.
        &#34;&#34;&#34;
        try:
            return self.screen.find_widget(self).virtual_region
        except errors.NoWidget:
            return Region()

    @property
    def window_region(self) -&gt; Region:
        &#34;&#34;&#34;The region within the scrollable area that is currently visible.

        Returns:
            Region: New region.
        &#34;&#34;&#34;
        window_region = self.region.at_offset(self.scroll_offset)
        return window_region

    @property
    def virtual_region_with_margin(self) -&gt; Region:
        &#34;&#34;&#34;The widget region relative to its container (*including margin*), which may not be visible,
        depending on the scroll offset.

        Returns:
            Region: The virtual region of the Widget, inclusive of its margin.
        &#34;&#34;&#34;
        return self.virtual_region.grow(self.styles.margin)

    @property
    def focusable_children(self) -&gt; list[Widget]:
        &#34;&#34;&#34;Get the children which may be focused.&#34;&#34;&#34;
        focusable = [
            child for child in self.children if child.display and child.visible
        ]
        return sorted(focusable, key=attrgetter(&#34;_focus_sort_key&#34;))

    @property
    def _focus_sort_key(self) -&gt; tuple[int, int]:
        x, y, _, _ = self.virtual_region
        top, _, _, left = self.styles.margin
        return y - top, x - left

    @property
    def scroll_offset(self) -&gt; Offset:
        return Offset(int(self.scroll_x), int(self.scroll_y))

    @property
    def is_transparent(self) -&gt; bool:
        &#34;&#34;&#34;Check if the background styles is not set.

        Returns:
            bool: ``True`` if there is background color, otherwise ``False``.
        &#34;&#34;&#34;
        return self.is_scrollable and self.styles.background.is_transparent

    @property
    def console(self) -&gt; Console:
        &#34;&#34;&#34;Get the current console.&#34;&#34;&#34;
        return active_app.get().console

    @property
    def animate(self) -&gt; BoundAnimator:
        if self._animate is None:
            self._animate = self.app.animator.bind(self)
        assert self._animate is not None
        return self._animate

    @property
    def layout(self) -&gt; Layout:
        &#34;&#34;&#34;Get the layout object if set in styles, or a default layout.&#34;&#34;&#34;
        return self.styles.layout or self._default_layout

    @property
    def is_container(self) -&gt; bool:
        &#34;&#34;&#34;Check if this widget is a container (contains other widgets).

        Returns:
            bool: True if this widget is a container.
        &#34;&#34;&#34;
        return self.styles.layout is not None or bool(self.children)

    @property
    def is_scrollable(self) -&gt; bool:
        &#34;&#34;&#34;Check if this Widget may be scrolled.

        Returns:
            bool: True if this widget may be scrolled.
        &#34;&#34;&#34;
        return self.is_container

    @property
    def layer(self) -&gt; str:
        &#34;&#34;&#34;Get the name of this widgets layer.&#34;&#34;&#34;
        return self.styles.layer or &#34;default&#34;

    @property
    def layers(self) -&gt; tuple[str, ...]:
        &#34;&#34;&#34;Layers of from parent.

        Returns:
            tuple[str, ...]: Tuple of layer names.
        &#34;&#34;&#34;
        for node in self.ancestors:
            if not isinstance(node, Widget):
                break
            if node.styles.has_rule(&#34;layers&#34;):
                return node.styles.layers
        return (&#34;default&#34;,)

    def _set_dirty(self, *regions: Region) -&gt; None:
        &#34;&#34;&#34;Set the Widget as &#39;dirty&#39; (requiring re-paint).

        Regions should be specified as positional args. If no regions are added, then
        the entire widget will be considered dirty.

        Args:
            *regions (Region): Regions which require a repaint.

        &#34;&#34;&#34;
        if regions:
            content_offset = self.content_offset
            widget_regions = [region.translate(content_offset) for region in regions]
            self._dirty_regions.update(widget_regions)
            self._repaint_regions.update(widget_regions)
            self._styles_cache.set_dirty(*widget_regions)
        else:
            self._dirty_regions.clear()
            self._repaint_regions.clear()
            self._styles_cache.clear()
            self._dirty_regions.add(self.outer_size.region)
            self._repaint_regions.add(self.outer_size.region)

    def _exchange_repaint_regions(self) -&gt; Collection[Region]:
        &#34;&#34;&#34;Get a copy of the regions which need a repaint, and clear internal cache.

        Returns:
            Collection[Region]: Regions to repaint.
        &#34;&#34;&#34;
        regions = self._repaint_regions.copy()
        self._repaint_regions.clear()
        return regions

    def scroll_to(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll to a given (absolute) coordinate, optionally animating.

        Args:
            x (int | None, optional): X coordinate (column) to scroll to, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y coordinate (row) to scroll to, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        scrolled_x = scrolled_y = False
        if animate:
            # TODO: configure animation speed
            if duration is None and speed is None:
                speed = 50
            if x is not None:
                self.scroll_target_x = x
                if x != self.scroll_x:
                    self.animate(
                        &#34;scroll_x&#34;,
                        self.scroll_target_x,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_x = True
            if y is not None:
                self.scroll_target_y = y
                if y != self.scroll_y:
                    self.animate(
                        &#34;scroll_y&#34;,
                        self.scroll_target_y,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_y = True

        else:
            if x is not None:
                scroll_x = self.scroll_x
                self.scroll_target_x = self.scroll_x = x
                scrolled_x = scroll_x != self.scroll_x
            if y is not None:
                scroll_y = self.scroll_y
                self.scroll_target_y = self.scroll_y = y
                scrolled_y = scroll_y != self.scroll_y
            if scrolled_x or scrolled_y:
                self.refresh(repaint=False, layout=True)

        return scrolled_x or scrolled_y

    def scroll_relative(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll relative to current position.

        Args:
            x (int | None, optional): X distance (columns) to scroll, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y distance (rows) to scroll, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        return self.scroll_to(
            None if x is None else (self.scroll_x + x),
            None if y is None else (self.scroll_y + y),
            animate=animate,
            speed=speed,
            duration=duration,
        )

    def scroll_home(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, 0, animate=animate, duration=1)

    def scroll_end(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, self.max_scroll_y, animate=animate, duration=1)

    def scroll_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x - 1, animate=animate)

    def scroll_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x + 1, animate=animate)

    def scroll_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y + 1, animate=animate)

    def scroll_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y - 1, animate=animate)

    def scroll_page_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y - self.container_size.height, animate=animate
        )

    def scroll_page_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y + self.container_size.height, animate=animate
        )

    def scroll_page_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x - self.container_size.width,
            animate=animate,
            duration=0.3,
        )

    def scroll_page_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x + self.container_size.width,
            animate=animate,
            duration=0.3,
        )

    def scroll_to_widget(self, widget: Widget, *, animate: bool = True) -&gt; bool:
        &#34;&#34;&#34;Scroll scrolling to bring a widget in to view.

        Args:
            widget (Widget): A descendant widget.
            animate (bool, optional): True to animate, or False to jump. Defaults to True.

        Returns:
            bool: True if any scrolling has occurred in any descendant, otherwise False.
        &#34;&#34;&#34;

        # Grow the region by the margin so to keep the margin in view.
        region = widget.virtual_region_with_margin
        scrolled = False

        while isinstance(widget.parent, Widget) and widget is not self:
            container = widget.parent
            scroll_offset = container.scroll_to_region(region, animate=animate)
            if scroll_offset:
                scrolled = True

            # Adjust the region by the amount we just scrolled it, and convert to
            # it&#39;s parent&#39;s virtual coordinate system.
            region = (
                region.translate(-scroll_offset)
                .translate(-widget.scroll_offset)
                .translate(container.virtual_region.offset)
            ).intersection(container.virtual_region)
            widget = container
        return scrolled

    def scroll_to_region(
        self, region: Region, *, spacing: Spacing | None = None, animate: bool = True
    ) -&gt; Offset:
        &#34;&#34;&#34;Scrolls a given region in to view, if required.

        This method will scroll the least distance required to move `region` fully within
        the scrollable area.

        Args:
            region (Region): A region that should be visible.
            animate (bool, optional): Enable animation. Defaults to True.
            spacing (Spacing): Space to subtract from the window region.

        Returns:
            Offset: The distance that was scrolled.
        &#34;&#34;&#34;

        window = self.content_region.at_offset(self.scroll_offset)
        if spacing is not None:
            window = window.shrink(spacing)
        delta_x, delta_y = Region.get_scroll_to_visible(window, region)
        scroll_x, scroll_y = self.scroll_offset
        delta = Offset(
            clamp(scroll_x + delta_x, 0, self.max_scroll_x) - scroll_x,
            clamp(scroll_y + delta_y, 0, self.max_scroll_y) - scroll_y,
        )
        if delta:
            self.scroll_relative(
                delta.x or None,
                delta.y or None,
                animate=animate,
                duration=0.2,
            )
        return delta

    def __init_subclass__(
        cls,
        can_focus: bool = False,
        can_focus_children: bool = True,
        inherit_css: bool = True,
    ) -&gt; None:
        super().__init_subclass__(inherit_css=inherit_css)
        cls.can_focus = can_focus
        cls.can_focus_children = can_focus_children

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;id&#34;, self.id, None
        if self.name:
            yield &#34;name&#34;, self.name
        if self.classes:
            yield &#34;classes&#34;, set(self.classes)
        pseudo_classes = self.pseudo_classes
        if pseudo_classes:
            yield &#34;pseudo_classes&#34;, set(pseudo_classes)

    def _get_scrollable_region(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Adjusts the Widget region to accommodate scrollbars.

        Args:
            region (Region): A region for the widget.

        Returns:
            Region: The widget region minus scrollbars.
        &#34;&#34;&#34;
        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled

        scrollbar_size_horizontal = self.styles.scrollbar_size_horizontal
        scrollbar_size_vertical = self.styles.scrollbar_size_vertical

        if self.styles.scrollbar_gutter == &#34;stable&#34;:
            # Let&#39;s _always_ reserve some space, whether the scrollbar is actually displayed or not:
            show_vertical_scrollbar = True
            scrollbar_size_vertical = self.styles.scrollbar_size_vertical

        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (region, _, _, _) = region.split(
                -scrollbar_size_vertical,
                -scrollbar_size_horizontal,
            )
        elif show_vertical_scrollbar:
            region, _ = region.split_vertical(-scrollbar_size_vertical)
        elif show_horizontal_scrollbar:
            region, _ = region.split_horizontal(-scrollbar_size_horizontal)
        return region

    def _arrange_scrollbars(self, region: Region) -&gt; Iterable[tuple[Widget, Region]]:
        &#34;&#34;&#34;Arrange the &#39;chrome&#39; widgets (typically scrollbars) for a layout element.

        Args:
            region (Region): The containing region.

        Returns:
            Iterable[tuple[Widget, Region]]: Tuples of scrollbar Widget and region.

        &#34;&#34;&#34;

        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled

        scrollbar_size_horizontal = self.scrollbar_size_horizontal
        scrollbar_size_vertical = self.scrollbar_size_vertical

        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (
                _,
                vertical_scrollbar_region,
                horizontal_scrollbar_region,
                _,
            ) = region.split(
                -scrollbar_size_vertical,
                -scrollbar_size_horizontal,
            )
            if vertical_scrollbar_region:
                yield self.vertical_scrollbar, vertical_scrollbar_region
            if horizontal_scrollbar_region:
                yield self.horizontal_scrollbar, horizontal_scrollbar_region
        elif show_vertical_scrollbar:
            _, scrollbar_region = region.split_vertical(-scrollbar_size_vertical)
            if scrollbar_region:
                yield self.vertical_scrollbar, scrollbar_region
        elif show_horizontal_scrollbar:
            _, scrollbar_region = region.split_horizontal(-scrollbar_size_horizontal)
            if scrollbar_region:
                yield self.horizontal_scrollbar, scrollbar_region

    def get_pseudo_classes(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;Pseudo classes for a widget&#34;&#34;&#34;
        if self.mouse_over:
            yield &#34;hover&#34;
        if self.has_focus:
            yield &#34;focus&#34;
        if self.descendant_has_focus:
            yield &#34;focus-within&#34;

    def watch(self, attribute_name, callback: Callable[[Any], Awaitable[None]]) -&gt; None:
        watch(self, attribute_name, callback)

    def _render_styled(self) -&gt; RenderableType:
        &#34;&#34;&#34;Applies style attributes to the default renderable.

        Returns:
            RenderableType: A new renderable.
        &#34;&#34;&#34;

        renderable = self.render()

        if isinstance(renderable, str):
            renderable = Text.from_markup(renderable)

        rich_style = self.rich_style
        if isinstance(renderable, Text):
            renderable.stylize(rich_style)
        else:
            renderable = Styled(renderable, rich_style)

        styles = self.styles
        content_align = (
            styles.content_align_horizontal,
            styles.content_align_vertical,
        )
        if content_align != (&#34;left&#34;, &#34;top&#34;):
            horizontal, vertical = content_align
            renderable = Align(renderable, horizontal, vertical=vertical)

        return renderable

    def watch_mouse_over(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if mouse over state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def watch_has_focus(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if has focus state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def size_updated(
        self, size: Size, virtual_size: Size, container_size: Size
    ) -&gt; None:
        if self._size != size or self.virtual_size != virtual_size:
            self._size = size
            self.virtual_size = virtual_size
            self._container_size = container_size
            if self.is_scrollable:
                self._refresh_scrollbars()
                width, height = self.container_size
                if self.show_vertical_scrollbar:
                    self.vertical_scrollbar.window_virtual_size = virtual_size.height
                    self.vertical_scrollbar.window_size = height
                if self.show_horizontal_scrollbar:
                    self.horizontal_scrollbar.window_virtual_size = virtual_size.width
                    self.horizontal_scrollbar.window_size = width

                self.scroll_x = self.validate_scroll_x(self.scroll_x)
                self.scroll_y = self.validate_scroll_y(self.scroll_y)
                self.refresh(layout=True)
                self.call_later(self.scroll_to, self.scroll_x, self.scroll_y)
            else:
                self.refresh()

    def _render_content(self) -&gt; None:
        &#34;&#34;&#34;Render all lines.&#34;&#34;&#34;
        width, height = self.size
        renderable = self._render_styled()
        options = self.console.options.update_dimensions(width, height).update(
            highlight=False
        )
        lines = self.console.render_lines(renderable, options)
        self._render_cache = RenderCache(self.size, lines)
        self._dirty_regions.clear()

    def render_line(self, y: int) -&gt; list[Segment]:
        &#34;&#34;&#34;Render a line of content.

        Args:
            y (int): Y Coordinate of line.

        Returns:
            list[Segment]: A rendered line.
        &#34;&#34;&#34;
        if self._dirty_regions:
            self._render_content()
        line = self._render_cache.lines[y]
        return line

    def render_lines(self, crop: Region) -&gt; Lines:
        &#34;&#34;&#34;Render the widget in to lines.

        Args:
            crop (Region): Region within visible area to render.

        Returns:
            Lines: A list of list of segments.
        &#34;&#34;&#34;
        lines = self._styles_cache.render_widget(self, crop)
        return lines

    def get_style_at(self, x: int, y: int) -&gt; Style:
        offset_x, offset_y = self.screen.get_offset(self)
        return self.screen.get_style_at(x + offset_x, y + offset_y)

    def call_later(self, callback: Callable, *args, **kwargs) -&gt; None:
        self.app.call_later(callback, *args, **kwargs)

    async def forward_event(self, event: events.Event) -&gt; None:
        event.set_forwarded()
        await self.post_message(event)

    def refresh(
        self, *regions: Region, repaint: bool = True, layout: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Initiate a refresh of the widget.

        This method sets an internal flag to perform a refresh, which will be done on the
        next idle event. Only one refresh will be done even if this method is called multiple times.

        Args:
            repaint (bool, optional): Repaint the widget (will call render() again). Defaults to True.
            layout (bool, optional): Also layout widgets in the view. Defaults to False.
        &#34;&#34;&#34;

        if layout:
            self._layout_required = True
            self._clear_arrangement_cache()
        if repaint:
            self._set_dirty(*regions)
            self._content_width_cache = (None, 0)
            self._content_height_cache = (None, 0)
            self._repaint_required = True
            if isinstance(self.parent, Widget) and self.styles.auto_dimensions:
                self.parent.refresh(layout=True)

        self.check_idle()

    def render(self) -&gt; RenderableType:
        &#34;&#34;&#34;Get renderable for widget.

        Args:
            style (Styles): The Styles object for this Widget.

        Returns:
            RenderableType: Any renderable
        &#34;&#34;&#34;
        return &#34;&#34; if self.is_container else self.css_identifier_styled

    async def action(self, action: str, *params) -&gt; None:
        await self.app.action(action, self)

    async def post_message(self, message: Message) -&gt; bool:
        if not self.check_message_enabled(message):
            return True
        if not self.is_running:
            self.log(self, f&#34;IS NOT RUNNING, {message!r} not sent&#34;)
        return await super().post_message(message)

    def on_idle(self, event: events.Idle) -&gt; None:
        &#34;&#34;&#34;Called when there are no more events on the queue.

        Args:
            event (events.Idle): Idle event.
        &#34;&#34;&#34;

        if self._repaint_required:
            self.screen.post_message_no_wait(messages.Update(self, self))
        if self._layout_required:
            self.screen.post_message_no_wait(messages.Layout(self))
        self._layout_required = False
        self._repaint_required = False

    def focus(self) -&gt; None:
        &#34;&#34;&#34;Give input focus to this widget.&#34;&#34;&#34;
        self.app.set_focus(self)

    async def capture_mouse(self, capture: bool = True) -&gt; None:
        &#34;&#34;&#34;Capture (or release) the mouse.

        When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.

        Args:
            capture (bool, optional): True to capture or False to release. Defaults to True.
        &#34;&#34;&#34;
        await self.app.capture_mouse(self if capture else None)

    async def release_mouse(self) -&gt; None:
        &#34;&#34;&#34;Release the mouse.

        Mouse events will only be sent when the mouse is over the widget.
        &#34;&#34;&#34;
        await self.app.capture_mouse(None)

    async def broker_event(self, event_name: str, event: events.Event) -&gt; bool:
        return await self.app.broker_event(event_name, event, default_namespace=self)

    async def on_mouse_down(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.down&#34;, event)

    async def on_mouse_up(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.up&#34;, event)

    async def on_click(self, event: events.Click) -&gt; None:
        await self.broker_event(&#34;click&#34;, event)

    async def on_key(self, event: events.Key) -&gt; None:
        await self.dispatch_key(event)

    def on_mount(self, event: events.Mount) -&gt; None:
        widgets = list(self.compose())
        if widgets:
            self.mount(*widgets)
            self.screen.refresh(repaint=False, layout=True)

    def on_leave(self) -&gt; None:
        self.mouse_over = False

    def on_enter(self) -&gt; None:
        self.mouse_over = True

    def on_focus(self, event: events.Focus) -&gt; None:
        self.emit_no_wait(events.DescendantFocus(self))
        self.has_focus = True
        self.refresh()

    def on_blur(self, event: events.Blur) -&gt; None:
        self.emit_no_wait(events.DescendantBlur(self))
        self.has_focus = False
        self.refresh()

    def on_descendant_focus(self, event: events.DescendantFocus) -&gt; None:
        self.descendant_has_focus = True
        if &#34;focus-within&#34; in self.pseudo_classes:
            sender = event.sender
            for child in self.walk_children(False):
                child.refresh()
                if child is sender:
                    break

    def on_descendant_blur(self, event: events.DescendantBlur) -&gt; None:
        self.descendant_has_focus = False
        if &#34;focus-within&#34; in self.pseudo_classes:
            sender = event.sender
            for child in self.walk_children(False):
                child.refresh()
                if child is sender:
                    break

    def on_mouse_scroll_down(self, event) -&gt; None:
        if self.is_scrollable:
            if self.scroll_down(animate=False):
                event.stop()

    def on_mouse_scroll_up(self, event) -&gt; None:
        if self.is_scrollable:
            if self.scroll_up(animate=False):
                event.stop()

    def handle_scroll_to(self, message: ScrollTo) -&gt; None:
        if self.is_scrollable:
            self.scroll_to(message.x, message.y, animate=message.animate, duration=0.1)
            message.stop()

    def handle_scroll_up(self, event: ScrollUp) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_up()
            event.stop()

    def handle_scroll_down(self, event: ScrollDown) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_down()
            event.stop()

    def handle_scroll_left(self, event: ScrollLeft) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_left()
            event.stop()

    def handle_scroll_right(self, event: ScrollRight) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_right()
            event.stop()

    def key_home(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_home()
            return True
        return False

    def key_end(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_end()
            return True
        return False

    def key_left(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_left()
            return True
        return False

    def key_right(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_right()
            return True
        return False

    def key_down(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_up()
            return True
        return False

    def key_up(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_down()
            return True
        return False

    def key_pagedown(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_page_down()
            return True
        return False

    def key_pageup(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_page_up()
            return True
        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.widget.RenderCache"><code class="flex name class">
<span>class <span class="ident">RenderCache</span></span>
<span>(</span><span>size: Size, lines: Lines)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores results of a previous render.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RenderCache(NamedTuple):
    &#34;&#34;&#34;Stores results of a previous render.&#34;&#34;&#34;

    size: Size
    lines: Lines

    @property
    def cursor_line(self) -&gt; int | None:
        for index, line in enumerate(self.lines):
            for _text, style, _control in line:
                if style and style._meta and style.meta.get(&#34;cursor&#34;, False):
                    return index
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="textual.widget.RenderCache.cursor_line"><code class="name">var <span class="ident">cursor_line</span> : int | None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cursor_line(self) -&gt; int | None:
    for index, line in enumerate(self.lines):
        for _text, style, _control in line:
            if style and style._meta and style.meta.get(&#34;cursor&#34;, False):
                return index
    return None</code></pre>
</details>
</dd>
<dt id="textual.widget.RenderCache.lines"><code class="name">var <span class="ident">lines</span> : List[List[rich.segment.Segment]]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="textual.widget.RenderCache.size"><code class="name">var <span class="ident">size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="textual.widget.Widget"><code class="flex name class">
<span>class <span class="ident">Widget</span></span>
<span>(</span><span>*children: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>, name: str | None = None, id: str | None = None, classes: str | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A node in a hierarchy of things forming the UI.</p>
<p>Nodes are mountable and may be styled with CSS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Widget(DOMNode):

    CSS = &#34;&#34;&#34;
    Widget{
        scrollbar-background: $panel-darken-1;
        scrollbar-background-hover: $panel-darken-2;
        scrollbar-color: $primary-lighten-1;
        scrollbar-color-active: $warning-darken-1;
        scrollbar-size-vertical: 2;
        scrollbar-size-horizontal: 1;
    }
    &#34;&#34;&#34;

    COMPONENT_CLASSES: ClassVar[set[str]] = set()

    can_focus: bool = False
    can_focus_children: bool = True

    def __init__(
        self,
        *children: Widget,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
    ) -&gt; None:

        self._size = Size(0, 0)
        self._container_size = Size(0, 0)
        self._layout_required = False
        self._repaint_required = False
        self._default_layout = VerticalLayout()
        self._animate: BoundAnimator | None = None
        self._reactive_watches: dict[str, Callable] = {}
        self.highlight_style: Style | None = None

        self._vertical_scrollbar: ScrollBar | None = None
        self._horizontal_scrollbar: ScrollBar | None = None

        self._render_cache = RenderCache(Size(0, 0), [])
        # Regions which need to be updated (in Widget)
        self._dirty_regions: set[Region] = set()
        # Regions which need to be transferred from cache to screen
        self._repaint_regions: set[Region] = set()

        # Cache the auto content dimensions
        # TODO: add mechanism to explicitly clear this
        self._content_width_cache: tuple[object, int] = (None, 0)
        self._content_height_cache: tuple[object, int] = (None, 0)

        self._arrangement: DockArrangeResult | None = None
        self._arrangement_cache_key: tuple[int, Size] = (-1, Size())

        self._styles_cache = StylesCache()

        super().__init__(name=name, id=id, classes=classes)
        self.add_children(*children)

    virtual_size = Reactive(Size(0, 0), layout=True)
    auto_width = Reactive(True)
    auto_height = Reactive(True)
    has_focus = Reactive(False)
    descendant_has_focus = Reactive(False)
    mouse_over = Reactive(False)
    scroll_x = Reactive(0.0, repaint=False, layout=False)
    scroll_y = Reactive(0.0, repaint=False, layout=False)
    scroll_target_x = Reactive(0.0, repaint=False)
    scroll_target_y = Reactive(0.0, repaint=False)
    show_vertical_scrollbar = Reactive(False, layout=True)
    show_horizontal_scrollbar = Reactive(False, layout=True)

    def _arrange(self, size: Size) -&gt; DockArrangeResult:
        &#34;&#34;&#34;Arrange children.

        Args:
            size (Size): Size of container.

        Returns:
            ArrangeResult: Widget locations.
        &#34;&#34;&#34;

        arrange_cache_key = (self.children._updates, size)
        if (
            self._arrangement is not None
            and arrange_cache_key == self._arrangement_cache_key
        ):
            return self._arrangement

        self._arrangement_cache_key = arrange_cache_key
        self._arrangement = arrange(self, self.children, size, self.screen.size)
        return self._arrangement

    def _clear_arrangement_cache(self) -&gt; None:
        self._arrangement = None

    def watch_show_horizontal_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_horizontal_scrollbar attribute.

        Args:
            value (bool): Show horizontal scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def watch_show_vertical_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_vertical_scrollbar attribute.

        Args:
            value (bool): Show vertical scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
        self.app.register(self, *anon_widgets, **widgets)
        self.screen.refresh()

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def on_register(self, app: App) -&gt; None:
        &#34;&#34;&#34;Called when the instance is registered.

        Args:
            app (App): App instance.
        &#34;&#34;&#34;
        # Parse the Widget&#39;s CSS
        for path, css in self.css:
            self.app.stylesheet.add_source(css, path=path, is_default_css=True)

    def get_box_model(
        self, container: Size, viewport: Size, fraction_unit: Fraction
    ) -&gt; BoxModel:
        &#34;&#34;&#34;Process the box model for this widget.

        Args:
            container (Size): The size of the container widget (with a layout)
            viewport (Size): The viewport size.

        Returns:
            BoxModel: The size and margin for this widget.
        &#34;&#34;&#34;
        box_model = get_box_model(
            self.styles,
            container,
            viewport,
            fraction_unit,
            self.get_content_width,
            self.get_content_height,
        )
        return box_model

    def get_content_width(self, container: Size, viewport: Size) -&gt; int:
        &#34;&#34;&#34;Gets the width of the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.

        Returns:
            int: The optimal width of the content.
        &#34;&#34;&#34;
        if self.is_container:
            assert self.layout is not None
            return (
                self.layout.get_content_width(self, container, viewport)
                + self.scrollbar_size_vertical
            )

        cache_key = container.width
        if self._content_width_cache[0] == cache_key:
            return self._content_width_cache[1]

        console = self.app.console
        renderable = self.render()
        measurement = Measurement.get(
            console,
            console.options.update_width(container.width),
            renderable,
        )
        width = measurement.maximum
        self._content_width_cache = (cache_key, width)
        return width

    def get_content_height(self, container: Size, viewport: Size, width: int) -&gt; int:
        &#34;&#34;&#34;Gets the height (number of lines) in the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.
            width (int): Width of renderable.

        Returns:
            int: The height of the content.
        &#34;&#34;&#34;
        if self.is_container:
            assert self.layout is not None
            height = (
                self.layout.get_content_height(
                    self,
                    container,
                    viewport,
                    width,
                )
                + self.scrollbar_size_horizontal
            )
        else:
            cache_key = width

            if self._content_height_cache[0] == cache_key:
                return self._content_height_cache[1]

            renderable = self.render()
            options = self.console.options.update_width(width).update(highlight=False)
            segments = self.console.render(renderable, options)
            # Cheaper than counting the lines returned from render_lines!
            height = sum(text.count(&#34;\n&#34;) for text, _, _ in segments)
            self._content_height_cache = (cache_key, height)

        return height

    def watch_scroll_x(self, new_value: float) -&gt; None:
        self.horizontal_scrollbar.position = int(new_value)
        self.refresh(layout=True)
        self.horizontal_scrollbar.refresh()

    def watch_scroll_y(self, new_value: float) -&gt; None:
        self.vertical_scrollbar.position = int(new_value)
        self.refresh(layout=True)
        self.vertical_scrollbar.refresh()

    def validate_scroll_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_target_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    def validate_scroll_target_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    @property
    def max_scroll_x(self) -&gt; int:
        &#34;&#34;&#34;The maximum value of `scroll_x`.&#34;&#34;&#34;
        return max(
            0,
            self.virtual_size.width
            - self.container_size.width
            + self.scrollbar_size_vertical,
        )

    @property
    def max_scroll_y(self) -&gt; int:
        &#34;&#34;&#34;The maximum value of `scroll_y`.&#34;&#34;&#34;
        return max(
            0,
            self.virtual_size.height
            - self.container_size.height
            + self.scrollbar_size_horizontal,
        )

    @property
    def vertical_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._vertical_scrollbar is not None:
            return self._vertical_scrollbar
        self._vertical_scrollbar = scroll_bar = ScrollBar(
            vertical=True, name=&#34;vertical&#34;, thickness=self.scrollbar_size_vertical
        )
        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    @property
    def horizontal_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._horizontal_scrollbar is not None:
            return self._horizontal_scrollbar
        self._horizontal_scrollbar = scroll_bar = ScrollBar(
            vertical=False, name=&#34;horizontal&#34;, thickness=self.scrollbar_size_horizontal
        )

        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    def _refresh_scrollbars(self) -&gt; None:
        &#34;&#34;&#34;Refresh scrollbar visibility.&#34;&#34;&#34;
        if not self.is_scrollable:
            return

        styles = self.styles
        overflow_x = styles.overflow_x
        overflow_y = styles.overflow_y
        width, height = self.container_size

        show_horizontal = self.show_horizontal_scrollbar
        if overflow_x == &#34;hidden&#34;:
            show_horizontal = False
        if overflow_x == &#34;scroll&#34;:
            show_horizontal = True
        elif overflow_x == &#34;auto&#34;:
            show_horizontal = self.virtual_size.width &gt; width

        show_vertical = self.show_vertical_scrollbar
        if overflow_y == &#34;hidden&#34;:
            show_vertical = False
        elif overflow_y == &#34;scroll&#34;:
            show_vertical = True
        elif overflow_y == &#34;auto&#34;:
            show_vertical = self.virtual_size.height &gt; height

        self.show_horizontal_scrollbar = show_horizontal
        self.show_vertical_scrollbar = show_vertical
        self.horizontal_scrollbar.display = show_horizontal
        self.vertical_scrollbar.display = show_vertical

    @property
    def scrollbars_enabled(self) -&gt; tuple[bool, bool]:
        &#34;&#34;&#34;A tuple of booleans that indicate if scrollbars are enabled.

        Returns:
            tuple[bool, bool]: A tuple of (&lt;vertical scrollbar enabled&gt;, &lt;horizontal scrollbar enabled&gt;)

        &#34;&#34;&#34;
        if not self.is_scrollable:
            return False, False

        enabled = self.show_vertical_scrollbar, self.show_horizontal_scrollbar
        return enabled

    @property
    def scrollbar_size_vertical(self) -&gt; int:
        &#34;&#34;&#34;Get the width used by the *vertical* scrollbar.&#34;&#34;&#34;
        return (
            self.styles.scrollbar_size_vertical if self.show_vertical_scrollbar else 0
        )

    @property
    def scrollbar_size_horizontal(self) -&gt; int:
        &#34;&#34;&#34;Get the height used by the *horizontal* scrollbar.&#34;&#34;&#34;
        return (
            self.styles.scrollbar_size_horizontal
            if self.show_horizontal_scrollbar
            else 0
        )

    @property
    def scrollbar_gutter(self) -&gt; Spacing:
        gutter = Spacing(
            0, self.scrollbar_size_vertical, self.scrollbar_size_horizontal, 0
        )
        return gutter

    @property
    def gutter(self) -&gt; Spacing:
        &#34;&#34;&#34;Spacing for padding / border / scrollbars.&#34;&#34;&#34;
        return self.styles.gutter + self.scrollbar_gutter

    @property
    def size(self) -&gt; Size:
        &#34;&#34;&#34;The size of the content area.&#34;&#34;&#34;
        return self.content_region.size

    @property
    def outer_size(self) -&gt; Size:
        &#34;&#34;&#34;The size of the widget (including padding and border).&#34;&#34;&#34;
        return self._size

    @property
    def container_size(self) -&gt; Size:
        &#34;&#34;&#34;The size of the container (parent widget).&#34;&#34;&#34;
        return self._container_size

    @property
    def content_region(self) -&gt; Region:
        &#34;&#34;&#34;Gets an absolute region containing the content (minus padding and border).&#34;&#34;&#34;
        content_region = self.region.shrink(self.gutter)
        return content_region

    @property
    def content_offset(self) -&gt; Offset:
        &#34;&#34;&#34;An offset from the Widget origin where the content begins.&#34;&#34;&#34;
        x, y = self.gutter.top_left
        return Offset(x, y)

    @property
    def region(self) -&gt; Region:
        &#34;&#34;&#34;The region occupied by this widget, relative to the Screen.&#34;&#34;&#34;
        try:
            return self.screen.find_widget(self).region
        except errors.NoWidget:
            return Region()

    @property
    def virtual_region(self) -&gt; Region:
        &#34;&#34;&#34;The widget region relative to it&#39;s container. Which may not be visible,
        depending on scroll offset.
        &#34;&#34;&#34;
        try:
            return self.screen.find_widget(self).virtual_region
        except errors.NoWidget:
            return Region()

    @property
    def window_region(self) -&gt; Region:
        &#34;&#34;&#34;The region within the scrollable area that is currently visible.

        Returns:
            Region: New region.
        &#34;&#34;&#34;
        window_region = self.region.at_offset(self.scroll_offset)
        return window_region

    @property
    def virtual_region_with_margin(self) -&gt; Region:
        &#34;&#34;&#34;The widget region relative to its container (*including margin*), which may not be visible,
        depending on the scroll offset.

        Returns:
            Region: The virtual region of the Widget, inclusive of its margin.
        &#34;&#34;&#34;
        return self.virtual_region.grow(self.styles.margin)

    @property
    def focusable_children(self) -&gt; list[Widget]:
        &#34;&#34;&#34;Get the children which may be focused.&#34;&#34;&#34;
        focusable = [
            child for child in self.children if child.display and child.visible
        ]
        return sorted(focusable, key=attrgetter(&#34;_focus_sort_key&#34;))

    @property
    def _focus_sort_key(self) -&gt; tuple[int, int]:
        x, y, _, _ = self.virtual_region
        top, _, _, left = self.styles.margin
        return y - top, x - left

    @property
    def scroll_offset(self) -&gt; Offset:
        return Offset(int(self.scroll_x), int(self.scroll_y))

    @property
    def is_transparent(self) -&gt; bool:
        &#34;&#34;&#34;Check if the background styles is not set.

        Returns:
            bool: ``True`` if there is background color, otherwise ``False``.
        &#34;&#34;&#34;
        return self.is_scrollable and self.styles.background.is_transparent

    @property
    def console(self) -&gt; Console:
        &#34;&#34;&#34;Get the current console.&#34;&#34;&#34;
        return active_app.get().console

    @property
    def animate(self) -&gt; BoundAnimator:
        if self._animate is None:
            self._animate = self.app.animator.bind(self)
        assert self._animate is not None
        return self._animate

    @property
    def layout(self) -&gt; Layout:
        &#34;&#34;&#34;Get the layout object if set in styles, or a default layout.&#34;&#34;&#34;
        return self.styles.layout or self._default_layout

    @property
    def is_container(self) -&gt; bool:
        &#34;&#34;&#34;Check if this widget is a container (contains other widgets).

        Returns:
            bool: True if this widget is a container.
        &#34;&#34;&#34;
        return self.styles.layout is not None or bool(self.children)

    @property
    def is_scrollable(self) -&gt; bool:
        &#34;&#34;&#34;Check if this Widget may be scrolled.

        Returns:
            bool: True if this widget may be scrolled.
        &#34;&#34;&#34;
        return self.is_container

    @property
    def layer(self) -&gt; str:
        &#34;&#34;&#34;Get the name of this widgets layer.&#34;&#34;&#34;
        return self.styles.layer or &#34;default&#34;

    @property
    def layers(self) -&gt; tuple[str, ...]:
        &#34;&#34;&#34;Layers of from parent.

        Returns:
            tuple[str, ...]: Tuple of layer names.
        &#34;&#34;&#34;
        for node in self.ancestors:
            if not isinstance(node, Widget):
                break
            if node.styles.has_rule(&#34;layers&#34;):
                return node.styles.layers
        return (&#34;default&#34;,)

    def _set_dirty(self, *regions: Region) -&gt; None:
        &#34;&#34;&#34;Set the Widget as &#39;dirty&#39; (requiring re-paint).

        Regions should be specified as positional args. If no regions are added, then
        the entire widget will be considered dirty.

        Args:
            *regions (Region): Regions which require a repaint.

        &#34;&#34;&#34;
        if regions:
            content_offset = self.content_offset
            widget_regions = [region.translate(content_offset) for region in regions]
            self._dirty_regions.update(widget_regions)
            self._repaint_regions.update(widget_regions)
            self._styles_cache.set_dirty(*widget_regions)
        else:
            self._dirty_regions.clear()
            self._repaint_regions.clear()
            self._styles_cache.clear()
            self._dirty_regions.add(self.outer_size.region)
            self._repaint_regions.add(self.outer_size.region)

    def _exchange_repaint_regions(self) -&gt; Collection[Region]:
        &#34;&#34;&#34;Get a copy of the regions which need a repaint, and clear internal cache.

        Returns:
            Collection[Region]: Regions to repaint.
        &#34;&#34;&#34;
        regions = self._repaint_regions.copy()
        self._repaint_regions.clear()
        return regions

    def scroll_to(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll to a given (absolute) coordinate, optionally animating.

        Args:
            x (int | None, optional): X coordinate (column) to scroll to, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y coordinate (row) to scroll to, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        scrolled_x = scrolled_y = False
        if animate:
            # TODO: configure animation speed
            if duration is None and speed is None:
                speed = 50
            if x is not None:
                self.scroll_target_x = x
                if x != self.scroll_x:
                    self.animate(
                        &#34;scroll_x&#34;,
                        self.scroll_target_x,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_x = True
            if y is not None:
                self.scroll_target_y = y
                if y != self.scroll_y:
                    self.animate(
                        &#34;scroll_y&#34;,
                        self.scroll_target_y,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_y = True

        else:
            if x is not None:
                scroll_x = self.scroll_x
                self.scroll_target_x = self.scroll_x = x
                scrolled_x = scroll_x != self.scroll_x
            if y is not None:
                scroll_y = self.scroll_y
                self.scroll_target_y = self.scroll_y = y
                scrolled_y = scroll_y != self.scroll_y
            if scrolled_x or scrolled_y:
                self.refresh(repaint=False, layout=True)

        return scrolled_x or scrolled_y

    def scroll_relative(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll relative to current position.

        Args:
            x (int | None, optional): X distance (columns) to scroll, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y distance (rows) to scroll, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        return self.scroll_to(
            None if x is None else (self.scroll_x + x),
            None if y is None else (self.scroll_y + y),
            animate=animate,
            speed=speed,
            duration=duration,
        )

    def scroll_home(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, 0, animate=animate, duration=1)

    def scroll_end(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, self.max_scroll_y, animate=animate, duration=1)

    def scroll_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x - 1, animate=animate)

    def scroll_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x + 1, animate=animate)

    def scroll_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y + 1, animate=animate)

    def scroll_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y - 1, animate=animate)

    def scroll_page_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y - self.container_size.height, animate=animate
        )

    def scroll_page_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y + self.container_size.height, animate=animate
        )

    def scroll_page_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x - self.container_size.width,
            animate=animate,
            duration=0.3,
        )

    def scroll_page_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x + self.container_size.width,
            animate=animate,
            duration=0.3,
        )

    def scroll_to_widget(self, widget: Widget, *, animate: bool = True) -&gt; bool:
        &#34;&#34;&#34;Scroll scrolling to bring a widget in to view.

        Args:
            widget (Widget): A descendant widget.
            animate (bool, optional): True to animate, or False to jump. Defaults to True.

        Returns:
            bool: True if any scrolling has occurred in any descendant, otherwise False.
        &#34;&#34;&#34;

        # Grow the region by the margin so to keep the margin in view.
        region = widget.virtual_region_with_margin
        scrolled = False

        while isinstance(widget.parent, Widget) and widget is not self:
            container = widget.parent
            scroll_offset = container.scroll_to_region(region, animate=animate)
            if scroll_offset:
                scrolled = True

            # Adjust the region by the amount we just scrolled it, and convert to
            # it&#39;s parent&#39;s virtual coordinate system.
            region = (
                region.translate(-scroll_offset)
                .translate(-widget.scroll_offset)
                .translate(container.virtual_region.offset)
            ).intersection(container.virtual_region)
            widget = container
        return scrolled

    def scroll_to_region(
        self, region: Region, *, spacing: Spacing | None = None, animate: bool = True
    ) -&gt; Offset:
        &#34;&#34;&#34;Scrolls a given region in to view, if required.

        This method will scroll the least distance required to move `region` fully within
        the scrollable area.

        Args:
            region (Region): A region that should be visible.
            animate (bool, optional): Enable animation. Defaults to True.
            spacing (Spacing): Space to subtract from the window region.

        Returns:
            Offset: The distance that was scrolled.
        &#34;&#34;&#34;

        window = self.content_region.at_offset(self.scroll_offset)
        if spacing is not None:
            window = window.shrink(spacing)
        delta_x, delta_y = Region.get_scroll_to_visible(window, region)
        scroll_x, scroll_y = self.scroll_offset
        delta = Offset(
            clamp(scroll_x + delta_x, 0, self.max_scroll_x) - scroll_x,
            clamp(scroll_y + delta_y, 0, self.max_scroll_y) - scroll_y,
        )
        if delta:
            self.scroll_relative(
                delta.x or None,
                delta.y or None,
                animate=animate,
                duration=0.2,
            )
        return delta

    def __init_subclass__(
        cls,
        can_focus: bool = False,
        can_focus_children: bool = True,
        inherit_css: bool = True,
    ) -&gt; None:
        super().__init_subclass__(inherit_css=inherit_css)
        cls.can_focus = can_focus
        cls.can_focus_children = can_focus_children

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;id&#34;, self.id, None
        if self.name:
            yield &#34;name&#34;, self.name
        if self.classes:
            yield &#34;classes&#34;, set(self.classes)
        pseudo_classes = self.pseudo_classes
        if pseudo_classes:
            yield &#34;pseudo_classes&#34;, set(pseudo_classes)

    def _get_scrollable_region(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Adjusts the Widget region to accommodate scrollbars.

        Args:
            region (Region): A region for the widget.

        Returns:
            Region: The widget region minus scrollbars.
        &#34;&#34;&#34;
        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled

        scrollbar_size_horizontal = self.styles.scrollbar_size_horizontal
        scrollbar_size_vertical = self.styles.scrollbar_size_vertical

        if self.styles.scrollbar_gutter == &#34;stable&#34;:
            # Let&#39;s _always_ reserve some space, whether the scrollbar is actually displayed or not:
            show_vertical_scrollbar = True
            scrollbar_size_vertical = self.styles.scrollbar_size_vertical

        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (region, _, _, _) = region.split(
                -scrollbar_size_vertical,
                -scrollbar_size_horizontal,
            )
        elif show_vertical_scrollbar:
            region, _ = region.split_vertical(-scrollbar_size_vertical)
        elif show_horizontal_scrollbar:
            region, _ = region.split_horizontal(-scrollbar_size_horizontal)
        return region

    def _arrange_scrollbars(self, region: Region) -&gt; Iterable[tuple[Widget, Region]]:
        &#34;&#34;&#34;Arrange the &#39;chrome&#39; widgets (typically scrollbars) for a layout element.

        Args:
            region (Region): The containing region.

        Returns:
            Iterable[tuple[Widget, Region]]: Tuples of scrollbar Widget and region.

        &#34;&#34;&#34;

        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled

        scrollbar_size_horizontal = self.scrollbar_size_horizontal
        scrollbar_size_vertical = self.scrollbar_size_vertical

        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (
                _,
                vertical_scrollbar_region,
                horizontal_scrollbar_region,
                _,
            ) = region.split(
                -scrollbar_size_vertical,
                -scrollbar_size_horizontal,
            )
            if vertical_scrollbar_region:
                yield self.vertical_scrollbar, vertical_scrollbar_region
            if horizontal_scrollbar_region:
                yield self.horizontal_scrollbar, horizontal_scrollbar_region
        elif show_vertical_scrollbar:
            _, scrollbar_region = region.split_vertical(-scrollbar_size_vertical)
            if scrollbar_region:
                yield self.vertical_scrollbar, scrollbar_region
        elif show_horizontal_scrollbar:
            _, scrollbar_region = region.split_horizontal(-scrollbar_size_horizontal)
            if scrollbar_region:
                yield self.horizontal_scrollbar, scrollbar_region

    def get_pseudo_classes(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;Pseudo classes for a widget&#34;&#34;&#34;
        if self.mouse_over:
            yield &#34;hover&#34;
        if self.has_focus:
            yield &#34;focus&#34;
        if self.descendant_has_focus:
            yield &#34;focus-within&#34;

    def watch(self, attribute_name, callback: Callable[[Any], Awaitable[None]]) -&gt; None:
        watch(self, attribute_name, callback)

    def _render_styled(self) -&gt; RenderableType:
        &#34;&#34;&#34;Applies style attributes to the default renderable.

        Returns:
            RenderableType: A new renderable.
        &#34;&#34;&#34;

        renderable = self.render()

        if isinstance(renderable, str):
            renderable = Text.from_markup(renderable)

        rich_style = self.rich_style
        if isinstance(renderable, Text):
            renderable.stylize(rich_style)
        else:
            renderable = Styled(renderable, rich_style)

        styles = self.styles
        content_align = (
            styles.content_align_horizontal,
            styles.content_align_vertical,
        )
        if content_align != (&#34;left&#34;, &#34;top&#34;):
            horizontal, vertical = content_align
            renderable = Align(renderable, horizontal, vertical=vertical)

        return renderable

    def watch_mouse_over(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if mouse over state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def watch_has_focus(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if has focus state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def size_updated(
        self, size: Size, virtual_size: Size, container_size: Size
    ) -&gt; None:
        if self._size != size or self.virtual_size != virtual_size:
            self._size = size
            self.virtual_size = virtual_size
            self._container_size = container_size
            if self.is_scrollable:
                self._refresh_scrollbars()
                width, height = self.container_size
                if self.show_vertical_scrollbar:
                    self.vertical_scrollbar.window_virtual_size = virtual_size.height
                    self.vertical_scrollbar.window_size = height
                if self.show_horizontal_scrollbar:
                    self.horizontal_scrollbar.window_virtual_size = virtual_size.width
                    self.horizontal_scrollbar.window_size = width

                self.scroll_x = self.validate_scroll_x(self.scroll_x)
                self.scroll_y = self.validate_scroll_y(self.scroll_y)
                self.refresh(layout=True)
                self.call_later(self.scroll_to, self.scroll_x, self.scroll_y)
            else:
                self.refresh()

    def _render_content(self) -&gt; None:
        &#34;&#34;&#34;Render all lines.&#34;&#34;&#34;
        width, height = self.size
        renderable = self._render_styled()
        options = self.console.options.update_dimensions(width, height).update(
            highlight=False
        )
        lines = self.console.render_lines(renderable, options)
        self._render_cache = RenderCache(self.size, lines)
        self._dirty_regions.clear()

    def render_line(self, y: int) -&gt; list[Segment]:
        &#34;&#34;&#34;Render a line of content.

        Args:
            y (int): Y Coordinate of line.

        Returns:
            list[Segment]: A rendered line.
        &#34;&#34;&#34;
        if self._dirty_regions:
            self._render_content()
        line = self._render_cache.lines[y]
        return line

    def render_lines(self, crop: Region) -&gt; Lines:
        &#34;&#34;&#34;Render the widget in to lines.

        Args:
            crop (Region): Region within visible area to render.

        Returns:
            Lines: A list of list of segments.
        &#34;&#34;&#34;
        lines = self._styles_cache.render_widget(self, crop)
        return lines

    def get_style_at(self, x: int, y: int) -&gt; Style:
        offset_x, offset_y = self.screen.get_offset(self)
        return self.screen.get_style_at(x + offset_x, y + offset_y)

    def call_later(self, callback: Callable, *args, **kwargs) -&gt; None:
        self.app.call_later(callback, *args, **kwargs)

    async def forward_event(self, event: events.Event) -&gt; None:
        event.set_forwarded()
        await self.post_message(event)

    def refresh(
        self, *regions: Region, repaint: bool = True, layout: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Initiate a refresh of the widget.

        This method sets an internal flag to perform a refresh, which will be done on the
        next idle event. Only one refresh will be done even if this method is called multiple times.

        Args:
            repaint (bool, optional): Repaint the widget (will call render() again). Defaults to True.
            layout (bool, optional): Also layout widgets in the view. Defaults to False.
        &#34;&#34;&#34;

        if layout:
            self._layout_required = True
            self._clear_arrangement_cache()
        if repaint:
            self._set_dirty(*regions)
            self._content_width_cache = (None, 0)
            self._content_height_cache = (None, 0)
            self._repaint_required = True
            if isinstance(self.parent, Widget) and self.styles.auto_dimensions:
                self.parent.refresh(layout=True)

        self.check_idle()

    def render(self) -&gt; RenderableType:
        &#34;&#34;&#34;Get renderable for widget.

        Args:
            style (Styles): The Styles object for this Widget.

        Returns:
            RenderableType: Any renderable
        &#34;&#34;&#34;
        return &#34;&#34; if self.is_container else self.css_identifier_styled

    async def action(self, action: str, *params) -&gt; None:
        await self.app.action(action, self)

    async def post_message(self, message: Message) -&gt; bool:
        if not self.check_message_enabled(message):
            return True
        if not self.is_running:
            self.log(self, f&#34;IS NOT RUNNING, {message!r} not sent&#34;)
        return await super().post_message(message)

    def on_idle(self, event: events.Idle) -&gt; None:
        &#34;&#34;&#34;Called when there are no more events on the queue.

        Args:
            event (events.Idle): Idle event.
        &#34;&#34;&#34;

        if self._repaint_required:
            self.screen.post_message_no_wait(messages.Update(self, self))
        if self._layout_required:
            self.screen.post_message_no_wait(messages.Layout(self))
        self._layout_required = False
        self._repaint_required = False

    def focus(self) -&gt; None:
        &#34;&#34;&#34;Give input focus to this widget.&#34;&#34;&#34;
        self.app.set_focus(self)

    async def capture_mouse(self, capture: bool = True) -&gt; None:
        &#34;&#34;&#34;Capture (or release) the mouse.

        When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.

        Args:
            capture (bool, optional): True to capture or False to release. Defaults to True.
        &#34;&#34;&#34;
        await self.app.capture_mouse(self if capture else None)

    async def release_mouse(self) -&gt; None:
        &#34;&#34;&#34;Release the mouse.

        Mouse events will only be sent when the mouse is over the widget.
        &#34;&#34;&#34;
        await self.app.capture_mouse(None)

    async def broker_event(self, event_name: str, event: events.Event) -&gt; bool:
        return await self.app.broker_event(event_name, event, default_namespace=self)

    async def on_mouse_down(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.down&#34;, event)

    async def on_mouse_up(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.up&#34;, event)

    async def on_click(self, event: events.Click) -&gt; None:
        await self.broker_event(&#34;click&#34;, event)

    async def on_key(self, event: events.Key) -&gt; None:
        await self.dispatch_key(event)

    def on_mount(self, event: events.Mount) -&gt; None:
        widgets = list(self.compose())
        if widgets:
            self.mount(*widgets)
            self.screen.refresh(repaint=False, layout=True)

    def on_leave(self) -&gt; None:
        self.mouse_over = False

    def on_enter(self) -&gt; None:
        self.mouse_over = True

    def on_focus(self, event: events.Focus) -&gt; None:
        self.emit_no_wait(events.DescendantFocus(self))
        self.has_focus = True
        self.refresh()

    def on_blur(self, event: events.Blur) -&gt; None:
        self.emit_no_wait(events.DescendantBlur(self))
        self.has_focus = False
        self.refresh()

    def on_descendant_focus(self, event: events.DescendantFocus) -&gt; None:
        self.descendant_has_focus = True
        if &#34;focus-within&#34; in self.pseudo_classes:
            sender = event.sender
            for child in self.walk_children(False):
                child.refresh()
                if child is sender:
                    break

    def on_descendant_blur(self, event: events.DescendantBlur) -&gt; None:
        self.descendant_has_focus = False
        if &#34;focus-within&#34; in self.pseudo_classes:
            sender = event.sender
            for child in self.walk_children(False):
                child.refresh()
                if child is sender:
                    break

    def on_mouse_scroll_down(self, event) -&gt; None:
        if self.is_scrollable:
            if self.scroll_down(animate=False):
                event.stop()

    def on_mouse_scroll_up(self, event) -&gt; None:
        if self.is_scrollable:
            if self.scroll_up(animate=False):
                event.stop()

    def handle_scroll_to(self, message: ScrollTo) -&gt; None:
        if self.is_scrollable:
            self.scroll_to(message.x, message.y, animate=message.animate, duration=0.1)
            message.stop()

    def handle_scroll_up(self, event: ScrollUp) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_up()
            event.stop()

    def handle_scroll_down(self, event: ScrollDown) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_down()
            event.stop()

    def handle_scroll_left(self, event: ScrollLeft) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_left()
            event.stop()

    def handle_scroll_right(self, event: ScrollRight) -&gt; None:
        if self.is_scrollable:
            self.scroll_page_right()
            event.stop()

    def key_home(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_home()
            return True
        return False

    def key_end(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_end()
            return True
        return False

    def key_left(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_left()
            return True
        return False

    def key_right(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_right()
            return True
        return False

    def key_down(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_up()
            return True
        return False

    def key_up(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_down()
            return True
        return False

    def key_pagedown(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_page_down()
            return True
        return False

    def key_pageup(self) -&gt; bool:
        if self.is_scrollable:
            self.scroll_page_up()
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></li>
<li><a title="textual.message_pump.MessagePump" href="message_pump.html#textual.message_pump.MessagePump">MessagePump</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textual.layout.Horizontal" href="layout.html#textual.layout.Horizontal">Horizontal</a></li>
<li><a title="textual.layout.Vertical" href="layout.html#textual.layout.Vertical">Vertical</a></li>
<li><a title="textual.screen.Screen" href="screen.html#textual.screen.Screen">Screen</a></li>
<li><a title="textual.scroll_view.ScrollView" href="scroll_view.html#textual.scroll_view.ScrollView">ScrollView</a></li>
<li><a title="textual.scrollbar.ScrollBar" href="scrollbar.html#textual.scrollbar.ScrollBar">ScrollBar</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="textual.widget.Widget.COMPONENT_CLASSES"><code class="name">var <span class="ident">COMPONENT_CLASSES</span> : ClassVar[set[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.widget.Widget.CSS"><code class="name">var <span class="ident">CSS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.widget.Widget.can_focus"><code class="name">var <span class="ident">can_focus</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.widget.Widget.can_focus_children"><code class="name">var <span class="ident">can_focus_children</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="textual.widget.Widget.animate"><code class="name">var <span class="ident">animate</span> : textual._animator.BoundAnimator</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def animate(self) -&gt; BoundAnimator:
    if self._animate is None:
        self._animate = self.app.animator.bind(self)
    assert self._animate is not None
    return self._animate</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.auto_height"><code class="name">var <span class="ident">auto_height</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.auto_width"><code class="name">var <span class="ident">auto_width</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.console"><code class="name">var <span class="ident">console</span> : rich.console.Console</code></dt>
<dd>
<div class="desc"><p>Get the current console.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def console(self) -&gt; Console:
    &#34;&#34;&#34;Get the current console.&#34;&#34;&#34;
    return active_app.get().console</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.container_size"><code class="name">var <span class="ident">container_size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"><p>The size of the container (parent widget).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def container_size(self) -&gt; Size:
    &#34;&#34;&#34;The size of the container (parent widget).&#34;&#34;&#34;
    return self._container_size</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.content_offset"><code class="name">var <span class="ident">content_offset</span> : <a title="textual.geometry.Offset" href="geometry.html#textual.geometry.Offset">Offset</a></code></dt>
<dd>
<div class="desc"><p>An offset from the Widget origin where the content begins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content_offset(self) -&gt; Offset:
    &#34;&#34;&#34;An offset from the Widget origin where the content begins.&#34;&#34;&#34;
    x, y = self.gutter.top_left
    return Offset(x, y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.content_region"><code class="name">var <span class="ident">content_region</span> : <a title="textual.geometry.Region" href="geometry.html#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>Gets an absolute region containing the content (minus padding and border).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content_region(self) -&gt; Region:
    &#34;&#34;&#34;Gets an absolute region containing the content (minus padding and border).&#34;&#34;&#34;
    content_region = self.region.shrink(self.gutter)
    return content_region</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.descendant_has_focus"><code class="name">var <span class="ident">descendant_has_focus</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.focusable_children"><code class="name">var <span class="ident">focusable_children</span> : list[<a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>]</code></dt>
<dd>
<div class="desc"><p>Get the children which may be focused.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def focusable_children(self) -&gt; list[Widget]:
    &#34;&#34;&#34;Get the children which may be focused.&#34;&#34;&#34;
    focusable = [
        child for child in self.children if child.display and child.visible
    ]
    return sorted(focusable, key=attrgetter(&#34;_focus_sort_key&#34;))</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.gutter"><code class="name">var <span class="ident">gutter</span> : <a title="textual.geometry.Spacing" href="geometry.html#textual.geometry.Spacing">Spacing</a></code></dt>
<dd>
<div class="desc"><p>Spacing for padding / border / scrollbars.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gutter(self) -&gt; Spacing:
    &#34;&#34;&#34;Spacing for padding / border / scrollbars.&#34;&#34;&#34;
    return self.styles.gutter + self.scrollbar_gutter</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.has_focus"><code class="name">var <span class="ident">has_focus</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.horizontal_scrollbar"><code class="name">var <span class="ident">horizontal_scrollbar</span> : ScrollBar</code></dt>
<dd>
<div class="desc"><p>Get a vertical scrollbar (create if necessary)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrollBar</code></dt>
<dd>ScrollBar Widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def horizontal_scrollbar(self) -&gt; ScrollBar:
    &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

    Returns:
        ScrollBar: ScrollBar Widget.
    &#34;&#34;&#34;
    from .scrollbar import ScrollBar

    if self._horizontal_scrollbar is not None:
        return self._horizontal_scrollbar
    self._horizontal_scrollbar = scroll_bar = ScrollBar(
        vertical=False, name=&#34;horizontal&#34;, thickness=self.scrollbar_size_horizontal
    )

    self.app.start_widget(self, scroll_bar)
    return scroll_bar</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.is_container"><code class="name">var <span class="ident">is_container</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if this widget is a container (contains other widgets).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if this widget is a container.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_container(self) -&gt; bool:
    &#34;&#34;&#34;Check if this widget is a container (contains other widgets).

    Returns:
        bool: True if this widget is a container.
    &#34;&#34;&#34;
    return self.styles.layout is not None or bool(self.children)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.is_scrollable"><code class="name">var <span class="ident">is_scrollable</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if this Widget may be scrolled.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if this widget may be scrolled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_scrollable(self) -&gt; bool:
    &#34;&#34;&#34;Check if this Widget may be scrolled.

    Returns:
        bool: True if this widget may be scrolled.
    &#34;&#34;&#34;
    return self.is_container</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.is_transparent"><code class="name">var <span class="ident">is_transparent</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if the background styles is not set.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if there is background color, otherwise <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_transparent(self) -&gt; bool:
    &#34;&#34;&#34;Check if the background styles is not set.

    Returns:
        bool: ``True`` if there is background color, otherwise ``False``.
    &#34;&#34;&#34;
    return self.is_scrollable and self.styles.background.is_transparent</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.layer"><code class="name">var <span class="ident">layer</span> : str</code></dt>
<dd>
<div class="desc"><p>Get the name of this widgets layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layer(self) -&gt; str:
    &#34;&#34;&#34;Get the name of this widgets layer.&#34;&#34;&#34;
    return self.styles.layer or &#34;default&#34;</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.layers"><code class="name">var <span class="ident">layers</span> : tuple[str, ...]</code></dt>
<dd>
<div class="desc"><p>Layers of from parent.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[str, &hellip;]</code></dt>
<dd>Tuple of layer names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layers(self) -&gt; tuple[str, ...]:
    &#34;&#34;&#34;Layers of from parent.

    Returns:
        tuple[str, ...]: Tuple of layer names.
    &#34;&#34;&#34;
    for node in self.ancestors:
        if not isinstance(node, Widget):
            break
        if node.styles.has_rule(&#34;layers&#34;):
            return node.styles.layers
    return (&#34;default&#34;,)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.layout"><code class="name">var <span class="ident">layout</span> : textual._layout.Layout</code></dt>
<dd>
<div class="desc"><p>Get the layout object if set in styles, or a default layout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layout(self) -&gt; Layout:
    &#34;&#34;&#34;Get the layout object if set in styles, or a default layout.&#34;&#34;&#34;
    return self.styles.layout or self._default_layout</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.max_scroll_x"><code class="name">var <span class="ident">max_scroll_x</span> : int</code></dt>
<dd>
<div class="desc"><p>The maximum value of <code>scroll_x</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_scroll_x(self) -&gt; int:
    &#34;&#34;&#34;The maximum value of `scroll_x`.&#34;&#34;&#34;
    return max(
        0,
        self.virtual_size.width
        - self.container_size.width
        + self.scrollbar_size_vertical,
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.max_scroll_y"><code class="name">var <span class="ident">max_scroll_y</span> : int</code></dt>
<dd>
<div class="desc"><p>The maximum value of <code>scroll_y</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_scroll_y(self) -&gt; int:
    &#34;&#34;&#34;The maximum value of `scroll_y`.&#34;&#34;&#34;
    return max(
        0,
        self.virtual_size.height
        - self.container_size.height
        + self.scrollbar_size_horizontal,
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.mouse_over"><code class="name">var <span class="ident">mouse_over</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.outer_size"><code class="name">var <span class="ident">outer_size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"><p>The size of the widget (including padding and border).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outer_size(self) -&gt; Size:
    &#34;&#34;&#34;The size of the widget (including padding and border).&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.region"><code class="name">var <span class="ident">region</span> : <a title="textual.geometry.Region" href="geometry.html#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>The region occupied by this widget, relative to the Screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def region(self) -&gt; Region:
    &#34;&#34;&#34;The region occupied by this widget, relative to the Screen.&#34;&#34;&#34;
    try:
        return self.screen.find_widget(self).region
    except errors.NoWidget:
        return Region()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_offset"><code class="name">var <span class="ident">scroll_offset</span> : <a title="textual.geometry.Offset" href="geometry.html#textual.geometry.Offset">Offset</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scroll_offset(self) -&gt; Offset:
    return Offset(int(self.scroll_x), int(self.scroll_y))</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_target_x"><code class="name">var <span class="ident">scroll_target_x</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_target_y"><code class="name">var <span class="ident">scroll_target_y</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_x"><code class="name">var <span class="ident">scroll_x</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_y"><code class="name">var <span class="ident">scroll_y</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scrollbar_gutter"><code class="name">var <span class="ident">scrollbar_gutter</span> : <a title="textual.geometry.Spacing" href="geometry.html#textual.geometry.Spacing">Spacing</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scrollbar_gutter(self) -&gt; Spacing:
    gutter = Spacing(
        0, self.scrollbar_size_vertical, self.scrollbar_size_horizontal, 0
    )
    return gutter</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scrollbar_size_horizontal"><code class="name">var <span class="ident">scrollbar_size_horizontal</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the height used by the <em>horizontal</em> scrollbar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scrollbar_size_horizontal(self) -&gt; int:
    &#34;&#34;&#34;Get the height used by the *horizontal* scrollbar.&#34;&#34;&#34;
    return (
        self.styles.scrollbar_size_horizontal
        if self.show_horizontal_scrollbar
        else 0
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scrollbar_size_vertical"><code class="name">var <span class="ident">scrollbar_size_vertical</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the width used by the <em>vertical</em> scrollbar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scrollbar_size_vertical(self) -&gt; int:
    &#34;&#34;&#34;Get the width used by the *vertical* scrollbar.&#34;&#34;&#34;
    return (
        self.styles.scrollbar_size_vertical if self.show_vertical_scrollbar else 0
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scrollbars_enabled"><code class="name">var <span class="ident">scrollbars_enabled</span> : tuple[bool, bool]</code></dt>
<dd>
<div class="desc"><p>A tuple of booleans that indicate if scrollbars are enabled.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[bool, bool]</code></dt>
<dd>A tuple of (<vertical scrollbar enabled>, <horizontal scrollbar enabled>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scrollbars_enabled(self) -&gt; tuple[bool, bool]:
    &#34;&#34;&#34;A tuple of booleans that indicate if scrollbars are enabled.

    Returns:
        tuple[bool, bool]: A tuple of (&lt;vertical scrollbar enabled&gt;, &lt;horizontal scrollbar enabled&gt;)

    &#34;&#34;&#34;
    if not self.is_scrollable:
        return False, False

    enabled = self.show_vertical_scrollbar, self.show_horizontal_scrollbar
    return enabled</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.show_horizontal_scrollbar"><code class="name">var <span class="ident">show_horizontal_scrollbar</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.show_vertical_scrollbar"><code class="name">var <span class="ident">show_vertical_scrollbar</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.size"><code class="name">var <span class="ident">size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"><p>The size of the content area.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Size:
    &#34;&#34;&#34;The size of the content area.&#34;&#34;&#34;
    return self.content_region.size</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.vertical_scrollbar"><code class="name">var <span class="ident">vertical_scrollbar</span> : ScrollBar</code></dt>
<dd>
<div class="desc"><p>Get a vertical scrollbar (create if necessary)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrollBar</code></dt>
<dd>ScrollBar Widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vertical_scrollbar(self) -&gt; ScrollBar:
    &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

    Returns:
        ScrollBar: ScrollBar Widget.
    &#34;&#34;&#34;
    from .scrollbar import ScrollBar

    if self._vertical_scrollbar is not None:
        return self._vertical_scrollbar
    self._vertical_scrollbar = scroll_bar = ScrollBar(
        vertical=True, name=&#34;vertical&#34;, thickness=self.scrollbar_size_vertical
    )
    self.app.start_widget(self, scroll_bar)
    return scroll_bar</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.virtual_region"><code class="name">var <span class="ident">virtual_region</span> : <a title="textual.geometry.Region" href="geometry.html#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>The widget region relative to it's container. Which may not be visible,
depending on scroll offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def virtual_region(self) -&gt; Region:
    &#34;&#34;&#34;The widget region relative to it&#39;s container. Which may not be visible,
    depending on scroll offset.
    &#34;&#34;&#34;
    try:
        return self.screen.find_widget(self).virtual_region
    except errors.NoWidget:
        return Region()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.virtual_region_with_margin"><code class="name">var <span class="ident">virtual_region_with_margin</span> : <a title="textual.geometry.Region" href="geometry.html#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>The widget region relative to its container (<em>including margin</em>), which may not be visible,
depending on the scroll offset.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Region</code></dt>
<dd>The virtual region of the Widget, inclusive of its margin.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def virtual_region_with_margin(self) -&gt; Region:
    &#34;&#34;&#34;The widget region relative to its container (*including margin*), which may not be visible,
    depending on the scroll offset.

    Returns:
        Region: The virtual region of the Widget, inclusive of its margin.
    &#34;&#34;&#34;
    return self.virtual_region.grow(self.styles.margin)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.virtual_size"><code class="name">var <span class="ident">virtual_size</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.window_region"><code class="name">var <span class="ident">window_region</span> : <a title="textual.geometry.Region" href="geometry.html#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>The region within the scrollable area that is currently visible.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Region</code></dt>
<dd>New region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def window_region(self) -&gt; Region:
    &#34;&#34;&#34;The region within the scrollable area that is currently visible.

    Returns:
        Region: New region.
    &#34;&#34;&#34;
    window_region = self.region.at_offset(self.scroll_offset)
    return window_region</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.widget.Widget.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, action: str, *params) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self, action: str, *params) -&gt; None:
    await self.app.action(action, self)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.broker_event"><code class="name flex">
<span>async def <span class="ident">broker_event</span></span>(<span>self, event_name: str, event: events.Event) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def broker_event(self, event_name: str, event: events.Event) -&gt; bool:
    return await self.app.broker_event(event_name, event, default_namespace=self)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.capture_mouse"><code class="name flex">
<span>async def <span class="ident">capture_mouse</span></span>(<span>self, capture: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Capture (or release) the mouse.</p>
<p>When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>capture</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to capture or False to release. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def capture_mouse(self, capture: bool = True) -&gt; None:
    &#34;&#34;&#34;Capture (or release) the mouse.

    When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.

    Args:
        capture (bool, optional): True to capture or False to release. Defaults to True.
    &#34;&#34;&#34;
    await self.app.capture_mouse(self if capture else None)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.compose"><code class="name flex">
<span>def <span class="ident">compose</span></span>(<span>self) ‑> ComposeResult</span>
</code></dt>
<dd>
<div class="desc"><p>Yield child widgets for a container.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose(self) -&gt; ComposeResult:
    &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
    return
    yield</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Give input focus to this widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self) -&gt; None:
    &#34;&#34;&#34;Give input focus to this widget.&#34;&#34;&#34;
    self.app.set_focus(self)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.forward_event"><code class="name flex">
<span>async def <span class="ident">forward_event</span></span>(<span>self, event: events.Event) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def forward_event(self, event: events.Event) -&gt; None:
    event.set_forwarded()
    await self.post_message(event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_box_model"><code class="name flex">
<span>def <span class="ident">get_box_model</span></span>(<span>self, container: Size, viewport: Size, fraction_unit: Fraction) ‑> <a title="textual.box_model.BoxModel" href="box_model.html#textual.box_model.BoxModel">BoxModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process the box model for this widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>container</code></strong> :&ensp;<code>Size</code></dt>
<dd>The size of the container widget (with a layout)</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Size</code></dt>
<dd>The viewport size.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BoxModel</code></dt>
<dd>The size and margin for this widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_box_model(
    self, container: Size, viewport: Size, fraction_unit: Fraction
) -&gt; BoxModel:
    &#34;&#34;&#34;Process the box model for this widget.

    Args:
        container (Size): The size of the container widget (with a layout)
        viewport (Size): The viewport size.

    Returns:
        BoxModel: The size and margin for this widget.
    &#34;&#34;&#34;
    box_model = get_box_model(
        self.styles,
        container,
        viewport,
        fraction_unit,
        self.get_content_width,
        self.get_content_height,
    )
    return box_model</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_content_height"><code class="name flex">
<span>def <span class="ident">get_content_height</span></span>(<span>self, container: Size, viewport: Size, width: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the height (number of lines) in the content area.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>container</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the container (immediate parent) widget.</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the viewport.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of renderable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The height of the content.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_height(self, container: Size, viewport: Size, width: int) -&gt; int:
    &#34;&#34;&#34;Gets the height (number of lines) in the content area.

    Args:
        container (Size): Size of the container (immediate parent) widget.
        viewport (Size): Size of the viewport.
        width (int): Width of renderable.

    Returns:
        int: The height of the content.
    &#34;&#34;&#34;
    if self.is_container:
        assert self.layout is not None
        height = (
            self.layout.get_content_height(
                self,
                container,
                viewport,
                width,
            )
            + self.scrollbar_size_horizontal
        )
    else:
        cache_key = width

        if self._content_height_cache[0] == cache_key:
            return self._content_height_cache[1]

        renderable = self.render()
        options = self.console.options.update_width(width).update(highlight=False)
        segments = self.console.render(renderable, options)
        # Cheaper than counting the lines returned from render_lines!
        height = sum(text.count(&#34;\n&#34;) for text, _, _ in segments)
        self._content_height_cache = (cache_key, height)

    return height</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_content_width"><code class="name flex">
<span>def <span class="ident">get_content_width</span></span>(<span>self, container: Size, viewport: Size) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the width of the content area.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>container</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the container (immediate parent) widget.</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the viewport.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The optimal width of the content.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_width(self, container: Size, viewport: Size) -&gt; int:
    &#34;&#34;&#34;Gets the width of the content area.

    Args:
        container (Size): Size of the container (immediate parent) widget.
        viewport (Size): Size of the viewport.

    Returns:
        int: The optimal width of the content.
    &#34;&#34;&#34;
    if self.is_container:
        assert self.layout is not None
        return (
            self.layout.get_content_width(self, container, viewport)
            + self.scrollbar_size_vertical
        )

    cache_key = container.width
    if self._content_width_cache[0] == cache_key:
        return self._content_width_cache[1]

    console = self.app.console
    renderable = self.render()
    measurement = Measurement.get(
        console,
        console.options.update_width(container.width),
        renderable,
    )
    width = measurement.maximum
    self._content_width_cache = (cache_key, width)
    return width</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_pseudo_classes"><code class="name flex">
<span>def <span class="ident">get_pseudo_classes</span></span>(<span>self) ‑> Iterable[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Pseudo classes for a widget</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pseudo_classes(self) -&gt; Iterable[str]:
    &#34;&#34;&#34;Pseudo classes for a widget&#34;&#34;&#34;
    if self.mouse_over:
        yield &#34;hover&#34;
    if self.has_focus:
        yield &#34;focus&#34;
    if self.descendant_has_focus:
        yield &#34;focus-within&#34;</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_style_at"><code class="name flex">
<span>def <span class="ident">get_style_at</span></span>(<span>self, x: int, y: int) ‑> rich.style.Style</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_style_at(self, x: int, y: int) -&gt; Style:
    offset_x, offset_y = self.screen.get_offset(self)
    return self.screen.get_style_at(x + offset_x, y + offset_y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_down"><code class="name flex">
<span>def <span class="ident">handle_scroll_down</span></span>(<span>self, event: ScrollDown) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_down(self, event: ScrollDown) -&gt; None:
    if self.is_scrollable:
        self.scroll_page_down()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_left"><code class="name flex">
<span>def <span class="ident">handle_scroll_left</span></span>(<span>self, event: ScrollLeft) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_left(self, event: ScrollLeft) -&gt; None:
    if self.is_scrollable:
        self.scroll_page_left()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_right"><code class="name flex">
<span>def <span class="ident">handle_scroll_right</span></span>(<span>self, event: ScrollRight) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_right(self, event: ScrollRight) -&gt; None:
    if self.is_scrollable:
        self.scroll_page_right()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_to"><code class="name flex">
<span>def <span class="ident">handle_scroll_to</span></span>(<span>self, message: ScrollTo) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_to(self, message: ScrollTo) -&gt; None:
    if self.is_scrollable:
        self.scroll_to(message.x, message.y, animate=message.animate, duration=0.1)
        message.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_up"><code class="name flex">
<span>def <span class="ident">handle_scroll_up</span></span>(<span>self, event: ScrollUp) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_up(self, event: ScrollUp) -&gt; None:
    if self.is_scrollable:
        self.scroll_page_up()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_down"><code class="name flex">
<span>def <span class="ident">key_down</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_down(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_up()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_end"><code class="name flex">
<span>def <span class="ident">key_end</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_end(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_end()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_home"><code class="name flex">
<span>def <span class="ident">key_home</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_home(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_home()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_left"><code class="name flex">
<span>def <span class="ident">key_left</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_left(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_left()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_pagedown"><code class="name flex">
<span>def <span class="ident">key_pagedown</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_pagedown(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_page_down()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_pageup"><code class="name flex">
<span>def <span class="ident">key_pageup</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_pageup(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_page_up()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_right"><code class="name flex">
<span>def <span class="ident">key_right</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_right(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_right()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_up"><code class="name flex">
<span>def <span class="ident">key_up</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_up(self) -&gt; bool:
    if self.is_scrollable:
        self.scroll_down()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.mount"><code class="name flex">
<span>def <span class="ident">mount</span></span>(<span>self, *anon_widgets: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>, **widgets: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
    self.app.register(self, *anon_widgets, **widgets)
    self.screen.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_blur"><code class="name flex">
<span>def <span class="ident">on_blur</span></span>(<span>self, event: events.Blur) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_blur(self, event: events.Blur) -&gt; None:
    self.emit_no_wait(events.DescendantBlur(self))
    self.has_focus = False
    self.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_click"><code class="name flex">
<span>async def <span class="ident">on_click</span></span>(<span>self, event: events.Click) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_click(self, event: events.Click) -&gt; None:
    await self.broker_event(&#34;click&#34;, event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_descendant_blur"><code class="name flex">
<span>def <span class="ident">on_descendant_blur</span></span>(<span>self, event: events.DescendantBlur) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_descendant_blur(self, event: events.DescendantBlur) -&gt; None:
    self.descendant_has_focus = False
    if &#34;focus-within&#34; in self.pseudo_classes:
        sender = event.sender
        for child in self.walk_children(False):
            child.refresh()
            if child is sender:
                break</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_descendant_focus"><code class="name flex">
<span>def <span class="ident">on_descendant_focus</span></span>(<span>self, event: events.DescendantFocus) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_descendant_focus(self, event: events.DescendantFocus) -&gt; None:
    self.descendant_has_focus = True
    if &#34;focus-within&#34; in self.pseudo_classes:
        sender = event.sender
        for child in self.walk_children(False):
            child.refresh()
            if child is sender:
                break</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_enter"><code class="name flex">
<span>def <span class="ident">on_enter</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_enter(self) -&gt; None:
    self.mouse_over = True</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_focus"><code class="name flex">
<span>def <span class="ident">on_focus</span></span>(<span>self, event: events.Focus) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_focus(self, event: events.Focus) -&gt; None:
    self.emit_no_wait(events.DescendantFocus(self))
    self.has_focus = True
    self.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_idle"><code class="name flex">
<span>def <span class="ident">on_idle</span></span>(<span>self, event: events.Idle) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called when there are no more events on the queue.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>events.Idle</code></dt>
<dd>Idle event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_idle(self, event: events.Idle) -&gt; None:
    &#34;&#34;&#34;Called when there are no more events on the queue.

    Args:
        event (events.Idle): Idle event.
    &#34;&#34;&#34;

    if self._repaint_required:
        self.screen.post_message_no_wait(messages.Update(self, self))
    if self._layout_required:
        self.screen.post_message_no_wait(messages.Layout(self))
    self._layout_required = False
    self._repaint_required = False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_key"><code class="name flex">
<span>async def <span class="ident">on_key</span></span>(<span>self, event: events.Key) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_key(self, event: events.Key) -&gt; None:
    await self.dispatch_key(event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_leave"><code class="name flex">
<span>def <span class="ident">on_leave</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_leave(self) -&gt; None:
    self.mouse_over = False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mount"><code class="name flex">
<span>def <span class="ident">on_mount</span></span>(<span>self, event: events.Mount) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_mount(self, event: events.Mount) -&gt; None:
    widgets = list(self.compose())
    if widgets:
        self.mount(*widgets)
        self.screen.refresh(repaint=False, layout=True)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_down"><code class="name flex">
<span>async def <span class="ident">on_mouse_down</span></span>(<span>self, event: events.MouseUp) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_mouse_down(self, event: events.MouseUp) -&gt; None:
    await self.broker_event(&#34;mouse.down&#34;, event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_scroll_down"><code class="name flex">
<span>def <span class="ident">on_mouse_scroll_down</span></span>(<span>self, event) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_mouse_scroll_down(self, event) -&gt; None:
    if self.is_scrollable:
        if self.scroll_down(animate=False):
            event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_scroll_up"><code class="name flex">
<span>def <span class="ident">on_mouse_scroll_up</span></span>(<span>self, event) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_mouse_scroll_up(self, event) -&gt; None:
    if self.is_scrollable:
        if self.scroll_up(animate=False):
            event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_up"><code class="name flex">
<span>async def <span class="ident">on_mouse_up</span></span>(<span>self, event: events.MouseUp) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_mouse_up(self, event: events.MouseUp) -&gt; None:
    await self.broker_event(&#34;mouse.up&#34;, event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_register"><code class="name flex">
<span>def <span class="ident">on_register</span></span>(<span>self, app: App) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the instance is registered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>App</code></dt>
<dd>App instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_register(self, app: App) -&gt; None:
    &#34;&#34;&#34;Called when the instance is registered.

    Args:
        app (App): App instance.
    &#34;&#34;&#34;
    # Parse the Widget&#39;s CSS
    for path, css in self.css:
        self.app.stylesheet.add_source(css, path=path, is_default_css=True)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.post_message"><code class="name flex">
<span>async def <span class="ident">post_message</span></span>(<span>self, message: Message) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def post_message(self, message: Message) -&gt; bool:
    if not self.check_message_enabled(message):
        return True
    if not self.is_running:
        self.log(self, f&#34;IS NOT RUNNING, {message!r} not sent&#34;)
    return await super().post_message(message)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, *regions: Region, repaint: bool = True, layout: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a refresh of the widget.</p>
<p>This method sets an internal flag to perform a refresh, which will be done on the
next idle event. Only one refresh will be done even if this method is called multiple times.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repaint</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Repaint the widget (will call render() again). Defaults to True.</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Also layout widgets in the view. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(
    self, *regions: Region, repaint: bool = True, layout: bool = False
) -&gt; None:
    &#34;&#34;&#34;Initiate a refresh of the widget.

    This method sets an internal flag to perform a refresh, which will be done on the
    next idle event. Only one refresh will be done even if this method is called multiple times.

    Args:
        repaint (bool, optional): Repaint the widget (will call render() again). Defaults to True.
        layout (bool, optional): Also layout widgets in the view. Defaults to False.
    &#34;&#34;&#34;

    if layout:
        self._layout_required = True
        self._clear_arrangement_cache()
    if repaint:
        self._set_dirty(*regions)
        self._content_width_cache = (None, 0)
        self._content_height_cache = (None, 0)
        self._repaint_required = True
        if isinstance(self.parent, Widget) and self.styles.auto_dimensions:
            self.parent.refresh(layout=True)

    self.check_idle()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.release_mouse"><code class="name flex">
<span>async def <span class="ident">release_mouse</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Release the mouse.</p>
<p>Mouse events will only be sent when the mouse is over the widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def release_mouse(self) -&gt; None:
    &#34;&#34;&#34;Release the mouse.

    Mouse events will only be sent when the mouse is over the widget.
    &#34;&#34;&#34;
    await self.app.capture_mouse(None)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self) ‑> Union[rich.console.ConsoleRenderable, rich.console.RichCast, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get renderable for widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>style</code></strong> :&ensp;<code>Styles</code></dt>
<dd>The Styles object for this Widget.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>RenderableType</code></dt>
<dd>Any renderable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self) -&gt; RenderableType:
    &#34;&#34;&#34;Get renderable for widget.

    Args:
        style (Styles): The Styles object for this Widget.

    Returns:
        RenderableType: Any renderable
    &#34;&#34;&#34;
    return &#34;&#34; if self.is_container else self.css_identifier_styled</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.render_line"><code class="name flex">
<span>def <span class="ident">render_line</span></span>(<span>self, y: int) ‑> list[Segment]</span>
</code></dt>
<dd>
<div class="desc"><p>Render a line of content.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Y Coordinate of line.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[Segment]</code></dt>
<dd>A rendered line.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_line(self, y: int) -&gt; list[Segment]:
    &#34;&#34;&#34;Render a line of content.

    Args:
        y (int): Y Coordinate of line.

    Returns:
        list[Segment]: A rendered line.
    &#34;&#34;&#34;
    if self._dirty_regions:
        self._render_content()
    line = self._render_cache.lines[y]
    return line</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.render_lines"><code class="name flex">
<span>def <span class="ident">render_lines</span></span>(<span>self, crop: Region) ‑> List[List[rich.segment.Segment]]</span>
</code></dt>
<dd>
<div class="desc"><p>Render the widget in to lines.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>crop</code></strong> :&ensp;<code>Region</code></dt>
<dd>Region within visible area to render.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Lines</code></dt>
<dd>A list of list of segments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_lines(self, crop: Region) -&gt; Lines:
    &#34;&#34;&#34;Render the widget in to lines.

    Args:
        crop (Region): Region within visible area to render.

    Returns:
        Lines: A list of list of segments.
    &#34;&#34;&#34;
    lines = self._styles_cache.render_widget(self, crop)
    return lines</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_down"><code class="name flex">
<span>def <span class="ident">scroll_down</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_down(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(y=self.scroll_target_y - 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_end"><code class="name flex">
<span>def <span class="ident">scroll_end</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_end(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(0, self.max_scroll_y, animate=animate, duration=1)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_home"><code class="name flex">
<span>def <span class="ident">scroll_home</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_home(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(0, 0, animate=animate, duration=1)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_left"><code class="name flex">
<span>def <span class="ident">scroll_left</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_left(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(x=self.scroll_target_x - 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_down"><code class="name flex">
<span>def <span class="ident">scroll_page_down</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_down(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        y=self.scroll_target_y + self.container_size.height, animate=animate
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_left"><code class="name flex">
<span>def <span class="ident">scroll_page_left</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_left(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        x=self.scroll_target_x - self.container_size.width,
        animate=animate,
        duration=0.3,
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_right"><code class="name flex">
<span>def <span class="ident">scroll_page_right</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_right(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        x=self.scroll_target_x + self.container_size.width,
        animate=animate,
        duration=0.3,
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_up"><code class="name flex">
<span>def <span class="ident">scroll_page_up</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_up(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        y=self.scroll_target_y - self.container_size.height, animate=animate
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_relative"><code class="name flex">
<span>def <span class="ident">scroll_relative</span></span>(<span>self, x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll relative to current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt>x (int | None, optional): X distance (columns) to scroll, or <code>None</code> for no change. Defaults to None.</dt>
<dt>y (int | None, optional): Y distance (rows) to scroll, or <code>None</code> for no change. Defaults to None.</dt>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Animate to new scroll position. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the scroll position changed, otherwise False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_relative(
    self,
    x: float | None = None,
    y: float | None = None,
    *,
    animate: bool = True,
    speed: float | None = None,
    duration: float | None = None,
) -&gt; bool:
    &#34;&#34;&#34;Scroll relative to current position.

    Args:
        x (int | None, optional): X distance (columns) to scroll, or ``None`` for no change. Defaults to None.
        y (int | None, optional): Y distance (rows) to scroll, or ``None`` for no change. Defaults to None.
        animate (bool, optional): Animate to new scroll position. Defaults to False.

    Returns:
        bool: True if the scroll position changed, otherwise False.
    &#34;&#34;&#34;
    return self.scroll_to(
        None if x is None else (self.scroll_x + x),
        None if y is None else (self.scroll_y + y),
        animate=animate,
        speed=speed,
        duration=duration,
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_right"><code class="name flex">
<span>def <span class="ident">scroll_right</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_right(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(x=self.scroll_target_x + 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_to"><code class="name flex">
<span>def <span class="ident">scroll_to</span></span>(<span>self, x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to a given (absolute) coordinate, optionally animating.</p>
<h2 id="args">Args</h2>
<dl>
<dt>x (int | None, optional): X coordinate (column) to scroll to, or <code>None</code> for no change. Defaults to None.</dt>
<dt>y (int | None, optional): Y coordinate (row) to scroll to, or <code>None</code> for no change. Defaults to None.</dt>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Animate to new scroll position. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the scroll position changed, otherwise False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_to(
    self,
    x: float | None = None,
    y: float | None = None,
    *,
    animate: bool = True,
    speed: float | None = None,
    duration: float | None = None,
) -&gt; bool:
    &#34;&#34;&#34;Scroll to a given (absolute) coordinate, optionally animating.

    Args:
        x (int | None, optional): X coordinate (column) to scroll to, or ``None`` for no change. Defaults to None.
        y (int | None, optional): Y coordinate (row) to scroll to, or ``None`` for no change. Defaults to None.
        animate (bool, optional): Animate to new scroll position. Defaults to False.

    Returns:
        bool: True if the scroll position changed, otherwise False.
    &#34;&#34;&#34;
    scrolled_x = scrolled_y = False
    if animate:
        # TODO: configure animation speed
        if duration is None and speed is None:
            speed = 50
        if x is not None:
            self.scroll_target_x = x
            if x != self.scroll_x:
                self.animate(
                    &#34;scroll_x&#34;,
                    self.scroll_target_x,
                    speed=speed,
                    duration=duration,
                    easing=&#34;out_cubic&#34;,
                )
                scrolled_x = True
        if y is not None:
            self.scroll_target_y = y
            if y != self.scroll_y:
                self.animate(
                    &#34;scroll_y&#34;,
                    self.scroll_target_y,
                    speed=speed,
                    duration=duration,
                    easing=&#34;out_cubic&#34;,
                )
                scrolled_y = True

    else:
        if x is not None:
            scroll_x = self.scroll_x
            self.scroll_target_x = self.scroll_x = x
            scrolled_x = scroll_x != self.scroll_x
        if y is not None:
            scroll_y = self.scroll_y
            self.scroll_target_y = self.scroll_y = y
            scrolled_y = scroll_y != self.scroll_y
        if scrolled_x or scrolled_y:
            self.refresh(repaint=False, layout=True)

    return scrolled_x or scrolled_y</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_to_region"><code class="name flex">
<span>def <span class="ident">scroll_to_region</span></span>(<span>self, region: Region, *, spacing: Spacing | None = None, animate: bool = True) ‑> Offset</span>
</code></dt>
<dd>
<div class="desc"><p>Scrolls a given region in to view, if required.</p>
<p>This method will scroll the least distance required to move <code>region</code> fully within
the scrollable area.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>Region</code></dt>
<dd>A region that should be visible.</dd>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Enable animation. Defaults to True.</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>Spacing</code></dt>
<dd>Space to subtract from the window region.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Offset</code></dt>
<dd>The distance that was scrolled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_to_region(
    self, region: Region, *, spacing: Spacing | None = None, animate: bool = True
) -&gt; Offset:
    &#34;&#34;&#34;Scrolls a given region in to view, if required.

    This method will scroll the least distance required to move `region` fully within
    the scrollable area.

    Args:
        region (Region): A region that should be visible.
        animate (bool, optional): Enable animation. Defaults to True.
        spacing (Spacing): Space to subtract from the window region.

    Returns:
        Offset: The distance that was scrolled.
    &#34;&#34;&#34;

    window = self.content_region.at_offset(self.scroll_offset)
    if spacing is not None:
        window = window.shrink(spacing)
    delta_x, delta_y = Region.get_scroll_to_visible(window, region)
    scroll_x, scroll_y = self.scroll_offset
    delta = Offset(
        clamp(scroll_x + delta_x, 0, self.max_scroll_x) - scroll_x,
        clamp(scroll_y + delta_y, 0, self.max_scroll_y) - scroll_y,
    )
    if delta:
        self.scroll_relative(
            delta.x or None,
            delta.y or None,
            animate=animate,
            duration=0.2,
        )
    return delta</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_to_widget"><code class="name flex">
<span>def <span class="ident">scroll_to_widget</span></span>(<span>self, widget: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll scrolling to bring a widget in to view.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget</code></strong> :&ensp;<code><a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a></code></dt>
<dd>A descendant widget.</dd>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to animate, or False to jump. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if any scrolling has occurred in any descendant, otherwise False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_to_widget(self, widget: Widget, *, animate: bool = True) -&gt; bool:
    &#34;&#34;&#34;Scroll scrolling to bring a widget in to view.

    Args:
        widget (Widget): A descendant widget.
        animate (bool, optional): True to animate, or False to jump. Defaults to True.

    Returns:
        bool: True if any scrolling has occurred in any descendant, otherwise False.
    &#34;&#34;&#34;

    # Grow the region by the margin so to keep the margin in view.
    region = widget.virtual_region_with_margin
    scrolled = False

    while isinstance(widget.parent, Widget) and widget is not self:
        container = widget.parent
        scroll_offset = container.scroll_to_region(region, animate=animate)
        if scroll_offset:
            scrolled = True

        # Adjust the region by the amount we just scrolled it, and convert to
        # it&#39;s parent&#39;s virtual coordinate system.
        region = (
            region.translate(-scroll_offset)
            .translate(-widget.scroll_offset)
            .translate(container.virtual_region.offset)
        ).intersection(container.virtual_region)
        widget = container
    return scrolled</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_up"><code class="name flex">
<span>def <span class="ident">scroll_up</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_up(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(y=self.scroll_target_y + 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.size_updated"><code class="name flex">
<span>def <span class="ident">size_updated</span></span>(<span>self, size: Size, virtual_size: Size, container_size: Size) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_updated(
    self, size: Size, virtual_size: Size, container_size: Size
) -&gt; None:
    if self._size != size or self.virtual_size != virtual_size:
        self._size = size
        self.virtual_size = virtual_size
        self._container_size = container_size
        if self.is_scrollable:
            self._refresh_scrollbars()
            width, height = self.container_size
            if self.show_vertical_scrollbar:
                self.vertical_scrollbar.window_virtual_size = virtual_size.height
                self.vertical_scrollbar.window_size = height
            if self.show_horizontal_scrollbar:
                self.horizontal_scrollbar.window_virtual_size = virtual_size.width
                self.horizontal_scrollbar.window_size = width

            self.scroll_x = self.validate_scroll_x(self.scroll_x)
            self.scroll_y = self.validate_scroll_y(self.scroll_y)
            self.refresh(layout=True)
            self.call_later(self.scroll_to, self.scroll_x, self.scroll_y)
        else:
            self.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_target_x"><code class="name flex">
<span>def <span class="ident">validate_scroll_target_x</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_target_x(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_x)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_target_y"><code class="name flex">
<span>def <span class="ident">validate_scroll_target_y</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_target_y(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_x"><code class="name flex">
<span>def <span class="ident">validate_scroll_x</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_x(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_x)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_y"><code class="name flex">
<span>def <span class="ident">validate_scroll_y</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_y(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch"><code class="name flex">
<span>def <span class="ident">watch</span></span>(<span>self, attribute_name, callback: Callable[[Any], Awaitable[None]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch(self, attribute_name, callback: Callable[[Any], Awaitable[None]]) -&gt; None:
    watch(self, attribute_name, callback)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_has_focus"><code class="name flex">
<span>def <span class="ident">watch_has_focus</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update from CSS if has focus state changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_has_focus(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Update from CSS if has focus state changes.&#34;&#34;&#34;
    self.app.update_styles()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_mouse_over"><code class="name flex">
<span>def <span class="ident">watch_mouse_over</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update from CSS if mouse over state changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_mouse_over(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Update from CSS if mouse over state changes.&#34;&#34;&#34;
    self.app.update_styles()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_scroll_x"><code class="name flex">
<span>def <span class="ident">watch_scroll_x</span></span>(<span>self, new_value: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_scroll_x(self, new_value: float) -&gt; None:
    self.horizontal_scrollbar.position = int(new_value)
    self.refresh(layout=True)
    self.horizontal_scrollbar.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_scroll_y"><code class="name flex">
<span>def <span class="ident">watch_scroll_y</span></span>(<span>self, new_value: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_scroll_y(self, new_value: float) -&gt; None:
    self.vertical_scrollbar.position = int(new_value)
    self.refresh(layout=True)
    self.vertical_scrollbar.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_show_horizontal_scrollbar"><code class="name flex">
<span>def <span class="ident">watch_show_horizontal_scrollbar</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Watch function for show_horizontal_scrollbar attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Show horizontal scrollbar flag.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_show_horizontal_scrollbar(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Watch function for show_horizontal_scrollbar attribute.

    Args:
        value (bool): Show horizontal scrollbar flag.
    &#34;&#34;&#34;
    if not value:
        # reset the scroll position if the scrollbar is hidden.
        self.scroll_to(0, 0, animate=False)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_show_vertical_scrollbar"><code class="name flex">
<span>def <span class="ident">watch_show_vertical_scrollbar</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Watch function for show_vertical_scrollbar attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Show vertical scrollbar flag.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_show_vertical_scrollbar(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Watch function for show_vertical_scrollbar attribute.

    Args:
        value (bool): Show vertical scrollbar flag.
    &#34;&#34;&#34;
    if not value:
        # reset the scroll position if the scrollbar is hidden.
        self.scroll_to(0, 0, animate=False)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></b></code>:
<ul class="hlist">
<li><code><a title="textual.dom.DOMNode.add_child" href="dom.html#textual.dom.DOMNode.add_child">add_child</a></code></li>
<li><code><a title="textual.dom.DOMNode.add_children" href="dom.html#textual.dom.DOMNode.add_children">add_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.add_class" href="dom.html#textual.dom.DOMNode.add_class">add_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.ancestors" href="dom.html#textual.dom.DOMNode.ancestors">ancestors</a></code></li>
<li><code><a title="textual.dom.DOMNode.app" href="message_pump.html#textual.message_pump.MessagePump.app">app</a></code></li>
<li><code><a title="textual.dom.DOMNode.background_colors" href="dom.html#textual.dom.DOMNode.background_colors">background_colors</a></code></li>
<li><code><a title="textual.dom.DOMNode.call_later" href="message_pump.html#textual.message_pump.MessagePump.call_later">call_later</a></code></li>
<li><code><a title="textual.dom.DOMNode.check_idle" href="message_pump.html#textual.message_pump.MessagePump.check_idle">check_idle</a></code></li>
<li><code><a title="textual.dom.DOMNode.close_messages" href="message_pump.html#textual.message_pump.MessagePump.close_messages">close_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.close_messages_no_wait" href="message_pump.html#textual.message_pump.MessagePump.close_messages_no_wait">close_messages_no_wait</a></code></li>
<li><code><a title="textual.dom.DOMNode.colors" href="dom.html#textual.dom.DOMNode.colors">colors</a></code></li>
<li><code><a title="textual.dom.DOMNode.css" href="dom.html#textual.dom.DOMNode.css">css</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier" href="dom.html#textual.dom.DOMNode.css_identifier">css_identifier</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier_styled" href="dom.html#textual.dom.DOMNode.css_identifier_styled">css_identifier_styled</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_path_nodes" href="dom.html#textual.dom.DOMNode.css_path_nodes">css_path_nodes</a></code></li>
<li><code><a title="textual.dom.DOMNode.disable_messages" href="message_pump.html#textual.message_pump.MessagePump.disable_messages">disable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.dispatch_key" href="message_pump.html#textual.message_pump.MessagePump.dispatch_key">dispatch_key</a></code></li>
<li><code><a title="textual.dom.DOMNode.display" href="dom.html#textual.dom.DOMNode.display">display</a></code></li>
<li><code><a title="textual.dom.DOMNode.displayed_children" href="dom.html#textual.dom.DOMNode.displayed_children">displayed_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.enable_messages" href="message_pump.html#textual.message_pump.MessagePump.enable_messages">enable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_child" href="dom.html#textual.dom.DOMNode.get_child">get_child</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_message" href="message_pump.html#textual.message_pump.MessagePump.get_message">get_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_class" href="dom.html#textual.dom.DOMNode.has_class">has_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_pseudo_class" href="dom.html#textual.dom.DOMNode.has_pseudo_class">has_pseudo_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.id" href="dom.html#textual.dom.DOMNode.id">id</a></code></li>
<li><code><a title="textual.dom.DOMNode.parent" href="dom.html#textual.dom.DOMNode.parent">parent</a></code></li>
<li><code><a title="textual.dom.DOMNode.peek_message" href="message_pump.html#textual.message_pump.MessagePump.peek_message">peek_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.post_priority_message" href="message_pump.html#textual.message_pump.MessagePump.post_priority_message">post_priority_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.pseudo_classes" href="dom.html#textual.dom.DOMNode.pseudo_classes">pseudo_classes</a></code></li>
<li><code><a title="textual.dom.DOMNode.query" href="dom.html#textual.dom.DOMNode.query">query</a></code></li>
<li><code><a title="textual.dom.DOMNode.remove_class" href="dom.html#textual.dom.DOMNode.remove_class">remove_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.reset_styles" href="dom.html#textual.dom.DOMNode.reset_styles">reset_styles</a></code></li>
<li><code><a title="textual.dom.DOMNode.rich_style" href="dom.html#textual.dom.DOMNode.rich_style">rich_style</a></code></li>
<li><code><a title="textual.dom.DOMNode.screen" href="dom.html#textual.dom.DOMNode.screen">screen</a></code></li>
<li><code><a title="textual.dom.DOMNode.set_styles" href="dom.html#textual.dom.DOMNode.set_styles">set_styles</a></code></li>
<li><code><a title="textual.dom.DOMNode.text_style" href="dom.html#textual.dom.DOMNode.text_style">text_style</a></code></li>
<li><code><a title="textual.dom.DOMNode.toggle_class" href="dom.html#textual.dom.DOMNode.toggle_class">toggle_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.tree" href="dom.html#textual.dom.DOMNode.tree">tree</a></code></li>
<li><code><a title="textual.dom.DOMNode.walk_children" href="dom.html#textual.dom.DOMNode.walk_children">walk_children</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual" href="index.html">textual</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.widget.RenderCache" href="#textual.widget.RenderCache">RenderCache</a></code></h4>
<ul class="">
<li><code><a title="textual.widget.RenderCache.cursor_line" href="#textual.widget.RenderCache.cursor_line">cursor_line</a></code></li>
<li><code><a title="textual.widget.RenderCache.lines" href="#textual.widget.RenderCache.lines">lines</a></code></li>
<li><code><a title="textual.widget.RenderCache.size" href="#textual.widget.RenderCache.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a></code></h4>
<ul class="">
<li><code><a title="textual.widget.Widget.COMPONENT_CLASSES" href="#textual.widget.Widget.COMPONENT_CLASSES">COMPONENT_CLASSES</a></code></li>
<li><code><a title="textual.widget.Widget.CSS" href="#textual.widget.Widget.CSS">CSS</a></code></li>
<li><code><a title="textual.widget.Widget.action" href="#textual.widget.Widget.action">action</a></code></li>
<li><code><a title="textual.widget.Widget.animate" href="#textual.widget.Widget.animate">animate</a></code></li>
<li><code><a title="textual.widget.Widget.auto_height" href="#textual.widget.Widget.auto_height">auto_height</a></code></li>
<li><code><a title="textual.widget.Widget.auto_width" href="#textual.widget.Widget.auto_width">auto_width</a></code></li>
<li><code><a title="textual.widget.Widget.broker_event" href="#textual.widget.Widget.broker_event">broker_event</a></code></li>
<li><code><a title="textual.widget.Widget.can_focus" href="#textual.widget.Widget.can_focus">can_focus</a></code></li>
<li><code><a title="textual.widget.Widget.can_focus_children" href="#textual.widget.Widget.can_focus_children">can_focus_children</a></code></li>
<li><code><a title="textual.widget.Widget.capture_mouse" href="#textual.widget.Widget.capture_mouse">capture_mouse</a></code></li>
<li><code><a title="textual.widget.Widget.compose" href="#textual.widget.Widget.compose">compose</a></code></li>
<li><code><a title="textual.widget.Widget.console" href="#textual.widget.Widget.console">console</a></code></li>
<li><code><a title="textual.widget.Widget.container_size" href="#textual.widget.Widget.container_size">container_size</a></code></li>
<li><code><a title="textual.widget.Widget.content_offset" href="#textual.widget.Widget.content_offset">content_offset</a></code></li>
<li><code><a title="textual.widget.Widget.content_region" href="#textual.widget.Widget.content_region">content_region</a></code></li>
<li><code><a title="textual.widget.Widget.descendant_has_focus" href="#textual.widget.Widget.descendant_has_focus">descendant_has_focus</a></code></li>
<li><code><a title="textual.widget.Widget.focus" href="#textual.widget.Widget.focus">focus</a></code></li>
<li><code><a title="textual.widget.Widget.focusable_children" href="#textual.widget.Widget.focusable_children">focusable_children</a></code></li>
<li><code><a title="textual.widget.Widget.forward_event" href="#textual.widget.Widget.forward_event">forward_event</a></code></li>
<li><code><a title="textual.widget.Widget.get_box_model" href="#textual.widget.Widget.get_box_model">get_box_model</a></code></li>
<li><code><a title="textual.widget.Widget.get_content_height" href="#textual.widget.Widget.get_content_height">get_content_height</a></code></li>
<li><code><a title="textual.widget.Widget.get_content_width" href="#textual.widget.Widget.get_content_width">get_content_width</a></code></li>
<li><code><a title="textual.widget.Widget.get_pseudo_classes" href="#textual.widget.Widget.get_pseudo_classes">get_pseudo_classes</a></code></li>
<li><code><a title="textual.widget.Widget.get_style_at" href="#textual.widget.Widget.get_style_at">get_style_at</a></code></li>
<li><code><a title="textual.widget.Widget.gutter" href="#textual.widget.Widget.gutter">gutter</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_down" href="#textual.widget.Widget.handle_scroll_down">handle_scroll_down</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_left" href="#textual.widget.Widget.handle_scroll_left">handle_scroll_left</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_right" href="#textual.widget.Widget.handle_scroll_right">handle_scroll_right</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_to" href="#textual.widget.Widget.handle_scroll_to">handle_scroll_to</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_up" href="#textual.widget.Widget.handle_scroll_up">handle_scroll_up</a></code></li>
<li><code><a title="textual.widget.Widget.has_focus" href="#textual.widget.Widget.has_focus">has_focus</a></code></li>
<li><code><a title="textual.widget.Widget.horizontal_scrollbar" href="#textual.widget.Widget.horizontal_scrollbar">horizontal_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.is_container" href="#textual.widget.Widget.is_container">is_container</a></code></li>
<li><code><a title="textual.widget.Widget.is_scrollable" href="#textual.widget.Widget.is_scrollable">is_scrollable</a></code></li>
<li><code><a title="textual.widget.Widget.is_transparent" href="#textual.widget.Widget.is_transparent">is_transparent</a></code></li>
<li><code><a title="textual.widget.Widget.key_down" href="#textual.widget.Widget.key_down">key_down</a></code></li>
<li><code><a title="textual.widget.Widget.key_end" href="#textual.widget.Widget.key_end">key_end</a></code></li>
<li><code><a title="textual.widget.Widget.key_home" href="#textual.widget.Widget.key_home">key_home</a></code></li>
<li><code><a title="textual.widget.Widget.key_left" href="#textual.widget.Widget.key_left">key_left</a></code></li>
<li><code><a title="textual.widget.Widget.key_pagedown" href="#textual.widget.Widget.key_pagedown">key_pagedown</a></code></li>
<li><code><a title="textual.widget.Widget.key_pageup" href="#textual.widget.Widget.key_pageup">key_pageup</a></code></li>
<li><code><a title="textual.widget.Widget.key_right" href="#textual.widget.Widget.key_right">key_right</a></code></li>
<li><code><a title="textual.widget.Widget.key_up" href="#textual.widget.Widget.key_up">key_up</a></code></li>
<li><code><a title="textual.widget.Widget.layer" href="#textual.widget.Widget.layer">layer</a></code></li>
<li><code><a title="textual.widget.Widget.layers" href="#textual.widget.Widget.layers">layers</a></code></li>
<li><code><a title="textual.widget.Widget.layout" href="#textual.widget.Widget.layout">layout</a></code></li>
<li><code><a title="textual.widget.Widget.max_scroll_x" href="#textual.widget.Widget.max_scroll_x">max_scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.max_scroll_y" href="#textual.widget.Widget.max_scroll_y">max_scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.mount" href="#textual.widget.Widget.mount">mount</a></code></li>
<li><code><a title="textual.widget.Widget.mouse_over" href="#textual.widget.Widget.mouse_over">mouse_over</a></code></li>
<li><code><a title="textual.widget.Widget.on_blur" href="#textual.widget.Widget.on_blur">on_blur</a></code></li>
<li><code><a title="textual.widget.Widget.on_click" href="#textual.widget.Widget.on_click">on_click</a></code></li>
<li><code><a title="textual.widget.Widget.on_descendant_blur" href="#textual.widget.Widget.on_descendant_blur">on_descendant_blur</a></code></li>
<li><code><a title="textual.widget.Widget.on_descendant_focus" href="#textual.widget.Widget.on_descendant_focus">on_descendant_focus</a></code></li>
<li><code><a title="textual.widget.Widget.on_enter" href="#textual.widget.Widget.on_enter">on_enter</a></code></li>
<li><code><a title="textual.widget.Widget.on_focus" href="#textual.widget.Widget.on_focus">on_focus</a></code></li>
<li><code><a title="textual.widget.Widget.on_idle" href="#textual.widget.Widget.on_idle">on_idle</a></code></li>
<li><code><a title="textual.widget.Widget.on_key" href="#textual.widget.Widget.on_key">on_key</a></code></li>
<li><code><a title="textual.widget.Widget.on_leave" href="#textual.widget.Widget.on_leave">on_leave</a></code></li>
<li><code><a title="textual.widget.Widget.on_mount" href="#textual.widget.Widget.on_mount">on_mount</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_down" href="#textual.widget.Widget.on_mouse_down">on_mouse_down</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_scroll_down" href="#textual.widget.Widget.on_mouse_scroll_down">on_mouse_scroll_down</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_scroll_up" href="#textual.widget.Widget.on_mouse_scroll_up">on_mouse_scroll_up</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_up" href="#textual.widget.Widget.on_mouse_up">on_mouse_up</a></code></li>
<li><code><a title="textual.widget.Widget.on_register" href="#textual.widget.Widget.on_register">on_register</a></code></li>
<li><code><a title="textual.widget.Widget.outer_size" href="#textual.widget.Widget.outer_size">outer_size</a></code></li>
<li><code><a title="textual.widget.Widget.post_message" href="#textual.widget.Widget.post_message">post_message</a></code></li>
<li><code><a title="textual.widget.Widget.refresh" href="#textual.widget.Widget.refresh">refresh</a></code></li>
<li><code><a title="textual.widget.Widget.region" href="#textual.widget.Widget.region">region</a></code></li>
<li><code><a title="textual.widget.Widget.release_mouse" href="#textual.widget.Widget.release_mouse">release_mouse</a></code></li>
<li><code><a title="textual.widget.Widget.render" href="#textual.widget.Widget.render">render</a></code></li>
<li><code><a title="textual.widget.Widget.render_line" href="#textual.widget.Widget.render_line">render_line</a></code></li>
<li><code><a title="textual.widget.Widget.render_lines" href="#textual.widget.Widget.render_lines">render_lines</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_down" href="#textual.widget.Widget.scroll_down">scroll_down</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_end" href="#textual.widget.Widget.scroll_end">scroll_end</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_home" href="#textual.widget.Widget.scroll_home">scroll_home</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_left" href="#textual.widget.Widget.scroll_left">scroll_left</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_offset" href="#textual.widget.Widget.scroll_offset">scroll_offset</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_down" href="#textual.widget.Widget.scroll_page_down">scroll_page_down</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_left" href="#textual.widget.Widget.scroll_page_left">scroll_page_left</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_right" href="#textual.widget.Widget.scroll_page_right">scroll_page_right</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_up" href="#textual.widget.Widget.scroll_page_up">scroll_page_up</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_relative" href="#textual.widget.Widget.scroll_relative">scroll_relative</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_right" href="#textual.widget.Widget.scroll_right">scroll_right</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_target_x" href="#textual.widget.Widget.scroll_target_x">scroll_target_x</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_target_y" href="#textual.widget.Widget.scroll_target_y">scroll_target_y</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_to" href="#textual.widget.Widget.scroll_to">scroll_to</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_to_region" href="#textual.widget.Widget.scroll_to_region">scroll_to_region</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_to_widget" href="#textual.widget.Widget.scroll_to_widget">scroll_to_widget</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_up" href="#textual.widget.Widget.scroll_up">scroll_up</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_x" href="#textual.widget.Widget.scroll_x">scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_y" href="#textual.widget.Widget.scroll_y">scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.scrollbar_gutter" href="#textual.widget.Widget.scrollbar_gutter">scrollbar_gutter</a></code></li>
<li><code><a title="textual.widget.Widget.scrollbar_size_horizontal" href="#textual.widget.Widget.scrollbar_size_horizontal">scrollbar_size_horizontal</a></code></li>
<li><code><a title="textual.widget.Widget.scrollbar_size_vertical" href="#textual.widget.Widget.scrollbar_size_vertical">scrollbar_size_vertical</a></code></li>
<li><code><a title="textual.widget.Widget.scrollbars_enabled" href="#textual.widget.Widget.scrollbars_enabled">scrollbars_enabled</a></code></li>
<li><code><a title="textual.widget.Widget.show_horizontal_scrollbar" href="#textual.widget.Widget.show_horizontal_scrollbar">show_horizontal_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.show_vertical_scrollbar" href="#textual.widget.Widget.show_vertical_scrollbar">show_vertical_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.size" href="#textual.widget.Widget.size">size</a></code></li>
<li><code><a title="textual.widget.Widget.size_updated" href="#textual.widget.Widget.size_updated">size_updated</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_target_x" href="#textual.widget.Widget.validate_scroll_target_x">validate_scroll_target_x</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_target_y" href="#textual.widget.Widget.validate_scroll_target_y">validate_scroll_target_y</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_x" href="#textual.widget.Widget.validate_scroll_x">validate_scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_y" href="#textual.widget.Widget.validate_scroll_y">validate_scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.vertical_scrollbar" href="#textual.widget.Widget.vertical_scrollbar">vertical_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.virtual_region" href="#textual.widget.Widget.virtual_region">virtual_region</a></code></li>
<li><code><a title="textual.widget.Widget.virtual_region_with_margin" href="#textual.widget.Widget.virtual_region_with_margin">virtual_region_with_margin</a></code></li>
<li><code><a title="textual.widget.Widget.virtual_size" href="#textual.widget.Widget.virtual_size">virtual_size</a></code></li>
<li><code><a title="textual.widget.Widget.watch" href="#textual.widget.Widget.watch">watch</a></code></li>
<li><code><a title="textual.widget.Widget.watch_has_focus" href="#textual.widget.Widget.watch_has_focus">watch_has_focus</a></code></li>
<li><code><a title="textual.widget.Widget.watch_mouse_over" href="#textual.widget.Widget.watch_mouse_over">watch_mouse_over</a></code></li>
<li><code><a title="textual.widget.Widget.watch_scroll_x" href="#textual.widget.Widget.watch_scroll_x">watch_scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.watch_scroll_y" href="#textual.widget.Widget.watch_scroll_y">watch_scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.watch_show_horizontal_scrollbar" href="#textual.widget.Widget.watch_show_horizontal_scrollbar">watch_show_horizontal_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.watch_show_vertical_scrollbar" href="#textual.widget.Widget.watch_show_vertical_scrollbar">watch_show_vertical_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.window_region" href="#textual.widget.Widget.window_region">window_region</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>