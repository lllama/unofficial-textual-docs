<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.widget API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.widget</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

from typing import (
    Any,
    Awaitable,
    TYPE_CHECKING,
    Callable,
    Iterable,
    NamedTuple,
)

import rich.repr
from rich.align import Align
from rich.console import Console, RenderableType
from rich.measure import Measurement
from rich.padding import Padding
from rich.style import Style
from rich.styled import Styled


from . import errors
from . import events
from ._animator import BoundAnimator
from ._border import Border
from .box_model import BoxModel, get_box_model
from ._context import active_app
from ._types import Lines
from .dom import DOMNode
from .geometry import clamp, Offset, Region, Size
from .layouts.vertical import VerticalLayout
from .message import Message
from . import messages
from ._layout import Layout
from .reactive import Reactive, watch
from .renderables.opacity import Opacity
from .renderables.tint import Tint


if TYPE_CHECKING:
    from .app import App, ComposeResult
    from .scrollbar import (
        ScrollBar,
        ScrollTo,
        ScrollUp,
        ScrollDown,
        ScrollLeft,
        ScrollRight,
    )


class RenderCache(NamedTuple):
    size: Size
    lines: Lines

    @property
    def cursor_line(self) -&gt; int | None:
        for index, line in enumerate(self.lines):
            for _text, style, _control in line:
                if style and style._meta and style.meta.get(&#34;cursor&#34;, False):
                    return index
        return None


@rich.repr.auto
class Widget(DOMNode):

    CSS = &#34;&#34;&#34;
    &#34;&#34;&#34;

    can_focus: bool = False
    can_focus_children: bool = True

    def __init__(
        self,
        *children: Widget,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
    ) -&gt; None:

        self._size = Size(0, 0)
        self._virtual_size = Size(0, 0)
        self._container_size = Size(0, 0)
        self._layout_required = False
        self._repaint_required = False
        self._default_layout = VerticalLayout()
        self._animate: BoundAnimator | None = None
        self._reactive_watches: dict[str, Callable] = {}
        self.highlight_style: Style | None = None

        self._vertical_scrollbar: ScrollBar | None = None
        self._horizontal_scrollbar: ScrollBar | None = None

        self._render_cache = RenderCache(Size(0, 0), [])
        self._dirty_regions: list[Region] = []

        # Cache the auto content dimensions
        # TODO: add mechanism to explicitly clear this
        self._content_width_cache: tuple[object, int] = (None, 0)
        self._content_height_cache: tuple[object, int] = (None, 0)

        super().__init__(name=name, id=id, classes=classes)
        self.add_children(*children)

    auto_width = Reactive(True)
    auto_height = Reactive(True)
    has_focus = Reactive(False)
    descendant_has_focus = Reactive(False)
    mouse_over = Reactive(False)
    scroll_x = Reactive(0.0, repaint=False, layout=True)
    scroll_y = Reactive(0.0, repaint=False, layout=True)
    scroll_target_x = Reactive(0.0, repaint=False)
    scroll_target_y = Reactive(0.0, repaint=False)
    show_vertical_scrollbar = Reactive(False, layout=True)
    show_horizontal_scrollbar = Reactive(False, layout=True)

    def watch_show_horizontal_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_horizontal_scrollbar attribute.

        Args:
            value (bool): Show horizontal scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def watch_show_vertical_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_vertical_scrollbar attribute.

        Args:
            value (bool): Show vertical scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
        self.app.register(self, *anon_widgets, **widgets)
        self.screen.refresh()

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def on_register(self, app: App) -&gt; None:
        &#34;&#34;&#34;Called when the instance is registered.

        Args:
            app (App): App instance.
        &#34;&#34;&#34;
        # Parser the Widget&#39;s CSS
        self.app.stylesheet.add_source(
            self.CSS, f&#34;{__file__}:&lt;{self.__class__.__name__}&gt;&#34;
        )

    def get_box_model(self, container: Size, viewport: Size) -&gt; BoxModel:
        &#34;&#34;&#34;Process the box model for this widget.

        Args:
            container (Size): The size of the container widget (with a layout)
            viewport (Size): The viewport size.

        Returns:
            BoxModel: The size and margin for this widget.
        &#34;&#34;&#34;
        box_model = get_box_model(
            self.styles,
            container,
            viewport,
            self.get_content_width,
            self.get_content_height,
        )
        return box_model

    def get_content_width(self, container: Size, viewport: Size) -&gt; int:
        &#34;&#34;&#34;Gets the width of the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.

        Returns:
            int: The optimal width of the content.
        &#34;&#34;&#34;
        if self.is_container:
            return self.layout.get_content_width(self, container, viewport)

        cache_key = container.width
        if self._content_width_cache[0] == cache_key:
            return self._content_width_cache[1]

        console = self.app.console
        renderable = self.render(self.styles.rich_style)
        measurement = Measurement.get(
            console,
            console.options.update_width(container.width),
            renderable,
        )
        width = measurement.maximum
        self._content_width_cache = (cache_key, width)
        return width

    def get_content_height(self, container: Size, viewport: Size, width: int) -&gt; int:
        &#34;&#34;&#34;Gets the height (number of lines) in the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.
            width (int): Width of renderable.

        Returns:
            int: The height of the content.
        &#34;&#34;&#34;
        if self.is_container:
            assert self.layout is not None
            height = self.layout.get_content_height(
                self,
                container,
                viewport,
                width,
            )
        else:
            cache_key = width

            if self._content_height_cache[0] == cache_key:
                return self._content_height_cache[1]

            renderable = self.render(self.styles.rich_style)
            options = self.console.options.update_width(width).update(highlight=False)
            segments = self.console.render(renderable, options)
            # Cheaper than counting the lines returned from render_lines!
            height = sum(text.count(&#34;\n&#34;) for text, _, _ in segments)
            self._content_height_cache = (cache_key, height)

        return height

    async def watch_scroll_x(self, new_value: float) -&gt; None:
        self.horizontal_scrollbar.position = int(new_value)

    async def watch_scroll_y(self, new_value: float) -&gt; None:
        self.vertical_scrollbar.position = int(new_value)

    def validate_scroll_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_target_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    def validate_scroll_target_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    @property
    def max_scroll_x(self) -&gt; float:
        return max(0, self.virtual_size.width - self.container_size.width)

    @property
    def max_scroll_y(self) -&gt; float:
        return max(0, self.virtual_size.height - self.container_size.height)

    @property
    def vertical_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._vertical_scrollbar is not None:
            return self._vertical_scrollbar
        self._vertical_scrollbar = scroll_bar = ScrollBar(
            vertical=True, name=&#34;vertical&#34;
        )
        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    @property
    def horizontal_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._horizontal_scrollbar is not None:
            return self._horizontal_scrollbar
        self._horizontal_scrollbar = scroll_bar = ScrollBar(
            vertical=False, name=&#34;horizontal&#34;
        )

        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    def _refresh_scrollbars(self) -&gt; None:
        &#34;&#34;&#34;Refresh scrollbar visibility.&#34;&#34;&#34;
        if not self.is_container:
            return

        styles = self.styles
        overflow_x = styles.overflow_x
        overflow_y = styles.overflow_y
        width, height = self.container_size

        show_horizontal = self.show_horizontal_scrollbar
        if overflow_x == &#34;hidden&#34;:
            show_horizontal = False
        if overflow_x == &#34;scroll&#34;:
            show_horizontal = True
        elif overflow_x == &#34;auto&#34;:
            show_horizontal = self.virtual_size.width &gt; width

        show_vertical = self.show_vertical_scrollbar
        if overflow_y == &#34;hidden&#34;:
            show_vertical = False
        elif overflow_y == &#34;scroll&#34;:
            show_vertical = True
        elif overflow_y == &#34;auto&#34;:
            show_vertical = self.virtual_size.height &gt; height

        self.show_horizontal_scrollbar = show_horizontal
        self.show_vertical_scrollbar = show_vertical
        self.horizontal_scrollbar.display = show_horizontal
        self.vertical_scrollbar.display = show_vertical

    @property
    def scrollbars_enabled(self) -&gt; tuple[bool, bool]:
        &#34;&#34;&#34;A tuple of booleans that indicate if scrollbars are enabled.

        Returns:
            tuple[bool, bool]: A tuple of (&lt;vertical scrollbar enabled&gt;, &lt;horizontal scrollbar enabled&gt;)

        &#34;&#34;&#34;
        if self.layout is None:
            return False, False

        enabled = self.show_vertical_scrollbar, self.show_horizontal_scrollbar
        return enabled

    def set_dirty(self) -&gt; None:
        &#34;&#34;&#34;Set the Widget as &#39;dirty&#39; (requiring re-render).&#34;&#34;&#34;
        self._dirty_regions.clear()
        self._dirty_regions.append(self.size.region)

    def scroll_to(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll to a given (absolute) coordinate, optionally animating.

        Args:
            x (int | None, optional): X coordinate (column) to scroll to, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y coordinate (row) to scroll to, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        scrolled_x = scrolled_y = False

        if animate:
            # TODO: configure animation speed
            if x is not None:
                self.scroll_target_x = x
                if x != self.scroll_x:
                    self.animate(
                        &#34;scroll_x&#34;,
                        self.scroll_target_x,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_x = True
            if y is not None:
                self.scroll_target_y = y
                if y != self.scroll_y:
                    self.animate(
                        &#34;scroll_y&#34;,
                        self.scroll_target_y,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_y = True

        else:
            if x is not None:
                scroll_x = self.scroll_x
                self.scroll_target_x = self.scroll_x = x
                scrolled_x = scroll_x != self.scroll_x
            if y is not None:
                scroll_y = self.scroll_y
                self.scroll_target_y = self.scroll_y = y
                scrolled_y = scroll_y != self.scroll_y
            if scrolled_x or scrolled_y:
                self.refresh(repaint=False, layout=True)

        return scrolled_x or scrolled_y

    def scroll_relative(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll relative to current position.

        Args:
            x (int | None, optional): X distance (columns) to scroll, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y distance (rows) to scroll, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        return self.scroll_to(
            None if x is None else (self.scroll_x + x),
            None if y is None else (self.scroll_y + y),
            animate=animate,
            speed=speed,
            duration=duration,
        )

    def scroll_home(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, 0, animate=animate)

    def scroll_end(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, self.max_scroll_y, animate=animate)

    def scroll_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x - 1, animate=animate)

    def scroll_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x + 1, animate=animate)

    def scroll_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y + 1, animate=animate)

    def scroll_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y - 1, animate=animate)

    def scroll_page_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y - self.container_size.height, animate=animate
        )

    def scroll_page_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y + self.container_size.height, animate=animate
        )

    def scroll_page_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x - self.container_size.width, animate=animate
        )

    def scroll_page_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x + self.container_size.width, animate=animate
        )

    def scroll_to_widget(self, widget: Widget, *, animate: bool = True) -&gt; bool:
        &#34;&#34;&#34;Scroll so that a child widget is in the visible area.

        Args:
            widget (Widget): A Widget in the children.
            animate (bool, optional): True to animate, or False to jump. Defaults to True.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;

        try:
            widget_region = widget.content_region
            container_region = self.content_region
        except errors.NoWidget:
            return False

        if widget_region in container_region:
            # Widget is visible, nothing to do
            return False

        # We can either scroll so the widget is at the top of the container, or so that
        # it is at the bottom. We want to pick which has the shortest distance
        top_delta = widget_region.origin - container_region.origin

        bottom_delta = widget_region.origin - (
            container_region.origin
            + Offset(0, container_region.height - widget_region.height)
        )

        if widget_region.width &gt; container_region.width:
            delta_x = top_delta.x
        else:
            delta_x = min(top_delta.x, bottom_delta.x, key=abs)

        if widget_region.height &gt; container_region.height:
            delta_y = top_delta.y
        else:
            delta_y = min(top_delta.y, bottom_delta.y, key=abs)

        return self.scroll_relative(
            delta_x or None, delta_y or None, animate=animate, duration=0.2
        )

    def __init_subclass__(
        cls, can_focus: bool = True, can_focus_children: bool = True
    ) -&gt; None:
        super().__init_subclass__()
        cls.can_focus = can_focus
        cls.can_focus_children = can_focus_children

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;id&#34;, self.id, None
        if self.name:
            yield &#34;name&#34;, self.name
        if self.classes:
            yield &#34;classes&#34;, set(self.classes)
        pseudo_classes = self.pseudo_classes
        if pseudo_classes:
            yield &#34;pseudo_classes&#34;, set(pseudo_classes)

    def _arrange_container(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Adjusts the Widget region to accommodate scrollbars.

        Args:
            region (Region): A region for the widget.

        Returns:
            Region: The widget region minus scrollbars.
        &#34;&#34;&#34;
        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled
        if self.styles.scrollbar_gutter == &#34;stable&#34;:
            # Let&#39;s _always_ reserve some space, whether the scrollbar is actually displayed or not:
            show_vertical_scrollbar = True
        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (region, _, _, _) = region.split(-1, -1)
        elif show_vertical_scrollbar:
            region, _ = region.split_vertical(-1)
        elif show_horizontal_scrollbar:
            region, _ = region.split_horizontal(-1)
        return region

    def _arrange_scrollbars(self, size: Size) -&gt; Iterable[tuple[Widget, Region]]:
        &#34;&#34;&#34;Arrange the &#39;chrome&#39; widgets (typically scrollbars) for a layout element.

        Args:
            size (Size): _description_

        Returns:
            Iterable[tuple[Widget, Region]]: _description_

        Yields:
            Iterator[Iterable[tuple[Widget, Region]]]: _description_
        &#34;&#34;&#34;
        region = size.region
        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled

        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (
                region,
                vertical_scrollbar_region,
                horizontal_scrollbar_region,
                _,
            ) = region.split(-1, -1)
            if vertical_scrollbar_region:
                yield self.vertical_scrollbar, vertical_scrollbar_region
            if horizontal_scrollbar_region:
                yield self.horizontal_scrollbar, horizontal_scrollbar_region
        elif show_vertical_scrollbar:
            region, scrollbar_region = region.split_vertical(-1)
            if scrollbar_region:
                yield self.vertical_scrollbar, scrollbar_region
        elif show_horizontal_scrollbar:
            region, scrollbar_region = region.split_horizontal(-1)
            if scrollbar_region:
                yield self.horizontal_scrollbar, scrollbar_region

    def get_pseudo_classes(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;Pseudo classes for a widget&#34;&#34;&#34;
        if self.mouse_over:
            yield &#34;hover&#34;
        if self.has_focus:
            yield &#34;focus&#34;
        if self.descendant_has_focus:
            yield &#34;focus-within&#34;

    def watch(self, attribute_name, callback: Callable[[Any], Awaitable[None]]) -&gt; None:
        watch(self, attribute_name, callback)

    def render_styled(self) -&gt; RenderableType:
        &#34;&#34;&#34;Applies style attributes to the default renderable.

        Returns:
            RenderableType: A new renderable.
        &#34;&#34;&#34;
        renderable = self.render(self.text_style)

        (base_background, base_color), (background, color) = self.colors
        styles = self.styles

        content_align = (styles.content_align_horizontal, styles.content_align_vertical)
        if content_align != (&#34;left&#34;, &#34;top&#34;):
            horizontal, vertical = content_align
            renderable = Align(renderable, horizontal, vertical=vertical)

        renderable = Padding(
            renderable,
            styles.padding,
            style=Style.from_color(color.rich_color, background.rich_color),
        )

        if styles.border:
            renderable = Border(
                renderable,
                styles.border,
                inner_color=background,
                outer_color=base_background,
            )

        if styles.outline:
            renderable = Border(
                renderable,
                styles.outline,
                inner_color=styles.background,
                outer_color=base_background,
                outline=True,
            )

        if styles.tint.a != 0:
            renderable = Tint(renderable, styles.tint)
        if styles.opacity != 1.0:
            renderable = Opacity(renderable, opacity=styles.opacity)

        return renderable

    @property
    def size(self) -&gt; Size:
        return self._size

    @property
    def container_size(self) -&gt; Size:
        return self._container_size

    @property
    def content_region(self) -&gt; Region:
        &#34;&#34;&#34;Gets an absolute region containing the content (minus padding and border).&#34;&#34;&#34;
        return self.region.shrink(self.styles.content_gutter)

    @property
    def content_offset(self) -&gt; Offset:
        &#34;&#34;&#34;An offset from the Widget origin where the content begins.&#34;&#34;&#34;
        x, y = self.styles.content_gutter.top_left
        return Offset(x, y)

    @property
    def virtual_size(self) -&gt; Size:
        return self._virtual_size

    @property
    def region(self) -&gt; Region:
        &#34;&#34;&#34;The region occupied by this widget, relative to the Screen.&#34;&#34;&#34;
        try:
            return self.screen.find_widget(self).region
        except errors.NoWidget:
            return Region()

    @property
    def scroll_offset(self) -&gt; Offset:
        return Offset(int(self.scroll_x), int(self.scroll_y))

    @property
    def is_transparent(self) -&gt; bool:
        &#34;&#34;&#34;Check if the background styles is not set.

        Returns:
            bool: ``True`` if there is background color, otherwise ``False``.
        &#34;&#34;&#34;
        return self.is_container and self.styles.background.is_transparent

    @property
    def console(self) -&gt; Console:
        &#34;&#34;&#34;Get the current console.&#34;&#34;&#34;
        return active_app.get().console

    @property
    def animate(self) -&gt; BoundAnimator:
        if self._animate is None:
            self._animate = self.app.animator.bind(self)
        assert self._animate is not None
        return self._animate

    @property
    def layout(self) -&gt; Layout:
        &#34;&#34;&#34;Get the layout object if set in styles, or a default layout.&#34;&#34;&#34;
        return self.styles.layout or self._default_layout

    @property
    def is_container(self) -&gt; bool:
        &#34;&#34;&#34;Check if this widget is a container (contains other widgets)

        Returns:
            bool: True if this widget is a container.
        &#34;&#34;&#34;
        return self.styles.layout is not None or bool(self.children)

    def watch_mouse_over(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if mouse over state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def watch_has_focus(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if has focus state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def on_style_change(self) -&gt; None:
        self.set_dirty()
        self.check_idle()

    def size_updated(
        self, size: Size, virtual_size: Size, container_size: Size
    ) -&gt; None:
        if self._size != size or self._virtual_size != virtual_size:
            self._size = size
            self._virtual_size = virtual_size
            self._container_size = container_size

            if self.is_container:
                self._refresh_scrollbars()
                width, height = self.container_size
                if self.show_vertical_scrollbar:
                    self.vertical_scrollbar.window_virtual_size = virtual_size.height
                    self.vertical_scrollbar.window_size = height
                if self.show_horizontal_scrollbar:
                    self.horizontal_scrollbar.window_virtual_size = virtual_size.width
                    self.horizontal_scrollbar.window_size = width

                self.scroll_x = self.validate_scroll_x(self.scroll_x)
                self.scroll_y = self.validate_scroll_y(self.scroll_y)
                self.refresh(layout=True)
                self.call_later(self.scroll_to, self.scroll_x, self.scroll_y)
            else:
                self.refresh()

    def _render_lines(self) -&gt; None:
        &#34;&#34;&#34;Render all lines.&#34;&#34;&#34;
        width, height = self.size
        renderable = self.render_styled()
        options = self.console.options.update_dimensions(width, height).update(
            highlight=False
        )
        lines = self.console.render_lines(renderable, options)
        self._render_cache = RenderCache(self.size, lines)
        self._dirty_regions.clear()

    def get_render_lines(
        self, start: int | None = None, end: int | None = None
    ) -&gt; Lines:
        &#34;&#34;&#34;Get segment lines to render the widget.

        Args:
            start (int | None, optional): line start index, or None for first line. Defaults to None.
            end (int | None, optional): line end index, or None for last line. Defaults to None.

        Returns:
            Lines: A list of lists of segments.
        &#34;&#34;&#34;
        if self._dirty_regions:
            self._render_lines()
            if self.is_container:
                if self.show_horizontal_scrollbar:
                    self.horizontal_scrollbar.refresh()
                if self.show_vertical_scrollbar:
                    self.vertical_scrollbar.refresh()
        lines = self._render_cache.lines[start:end]
        return lines

    def check_layout(self) -&gt; bool:
        &#34;&#34;&#34;Check if a layout has been requested.&#34;&#34;&#34;
        return self._layout_required

    def get_style_at(self, x: int, y: int) -&gt; Style:
        offset_x, offset_y = self.screen.get_offset(self)
        return self.screen.get_style_at(x + offset_x, y + offset_y)

    def call_later(self, callback: Callable, *args, **kwargs) -&gt; None:
        self.app.call_later(callback, *args, **kwargs)

    async def forward_event(self, event: events.Event) -&gt; None:
        event.set_forwarded()
        await self.post_message(event)

    def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
        &#34;&#34;&#34;Initiate a refresh of the widget.

        This method sets an internal flag to perform a refresh, which will be done on the
        next idle event. Only one refresh will be done even if this method is called multiple times.

        Args:
            repaint (bool, optional): Repaint the widget (will call render() again). Defaults to True.
            layout (bool, optional): Also layout widgets in the view. Defaults to False.
        &#34;&#34;&#34;
        if layout:
            self._layout_required = True
        if repaint:
            self._content_width_cache = (None, 0)
            self._content_height_cache = (None, 0)
            self.set_dirty()
            self._repaint_required = True
        self.check_idle()

    def render(self, style: Style) -&gt; RenderableType:
        &#34;&#34;&#34;Get renderable for widget.

        Args:
            style (Styles): The Styles object for this Widget.

        Returns:
            RenderableType: Any renderable
        &#34;&#34;&#34;
        return &#34;&#34; if self.is_container else self.css_identifier_styled

    async def action(self, action: str, *params) -&gt; None:
        await self.app.action(action, self)

    async def post_message(self, message: Message) -&gt; bool:
        if not self.check_message_enabled(message):
            return True
        if not self.is_running:
            self.log(self, f&#34;IS NOT RUNNING, {message!r} not sent&#34;)
        return await super().post_message(message)

    def on_idle(self, event: events.Idle) -&gt; None:
        &#34;&#34;&#34;Called when there are no more events on the queue.

        Args:
            event (events.Idle): Idle event.
        &#34;&#34;&#34;

        if self.check_layout():
            self._layout_required = False
            self.screen.post_message_no_wait(messages.Layout(self))
        elif self._repaint_required:
            self.emit_no_wait(messages.Update(self, self))
        self._repaint_required = False

    def focus(self) -&gt; None:
        &#34;&#34;&#34;Give input focus to this widget.&#34;&#34;&#34;
        self.app.set_focus(self)

    async def capture_mouse(self, capture: bool = True) -&gt; None:
        &#34;&#34;&#34;Capture (or release) the mouse.

        When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.

        Args:
            capture (bool, optional): True to capture or False to release. Defaults to True.
        &#34;&#34;&#34;
        await self.app.capture_mouse(self if capture else None)

    async def release_mouse(self) -&gt; None:
        &#34;&#34;&#34;Release the mouse.

        Mouse events will only be sent when the mouse is over the widget.
        &#34;&#34;&#34;
        await self.app.capture_mouse(None)

    async def broker_event(self, event_name: str, event: events.Event) -&gt; bool:
        return await self.app.broker_event(event_name, event, default_namespace=self)

    async def on_mouse_down(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.down&#34;, event)

    async def on_mouse_up(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.up&#34;, event)

    async def on_click(self, event: events.Click) -&gt; None:
        await self.broker_event(&#34;click&#34;, event)

    async def on_key(self, event: events.Key) -&gt; None:
        await self.dispatch_key(event)

    def on_mount(self, event: events.Mount) -&gt; None:
        widgets = list(self.compose())
        if widgets:
            self.mount(*widgets)
            self.screen.refresh(repaint=False, layout=True)

    def on_leave(self) -&gt; None:
        self.mouse_over = False

    def on_enter(self) -&gt; None:
        self.mouse_over = True

    def on_focus(self, event: events.Focus) -&gt; None:
        self.emit_no_wait(events.DescendantFocus(self))
        self.has_focus = True
        self.refresh()

    def on_blur(self, event: events.Blur) -&gt; None:
        self.emit_no_wait(events.DescendantBlur(self))
        self.has_focus = False
        self.refresh()

    def on_descendant_focus(self, event: events.DescendantFocus) -&gt; None:
        self.descendant_has_focus = True
        if self.is_container and isinstance(event.sender, Widget):
            self.scroll_to_widget(event.sender, animate=True)

    def on_descendant_blur(self, event: events.DescendantBlur) -&gt; None:
        self.descendant_has_focus = False

    def on_mouse_scroll_down(self, event) -&gt; None:
        if self.is_container:
            if self.scroll_down(animate=False):
                event.stop()

    def on_mouse_scroll_up(self, event) -&gt; None:
        if self.is_container:
            if self.scroll_up(animate=False):
                event.stop()

    def handle_scroll_to(self, message: ScrollTo) -&gt; None:
        if self.is_container:
            self.scroll_to(message.x, message.y, animate=message.animate)
            message.stop()

    def handle_scroll_up(self, event: ScrollUp) -&gt; None:
        if self.is_container:
            self.scroll_page_up()
            event.stop()

    def handle_scroll_down(self, event: ScrollDown) -&gt; None:
        if self.is_container:
            self.scroll_page_down()
            event.stop()

    def handle_scroll_left(self, event: ScrollLeft) -&gt; None:
        if self.is_container:
            self.scroll_page_left()
            event.stop()

    def handle_scroll_right(self, event: ScrollRight) -&gt; None:
        if self.is_container:
            self.scroll_page_right()
            event.stop()

    def key_home(self) -&gt; bool:
        if self.is_container:
            self.scroll_home()
            return True
        return False

    def key_end(self) -&gt; bool:
        if self.is_container:
            self.scroll_end()
            return True
        return False

    def key_left(self) -&gt; bool:
        if self.is_container:
            self.scroll_left()
            return True
        return False

    def key_right(self) -&gt; bool:
        if self.is_container:
            self.scroll_right()
            return True
        return False

    def key_down(self) -&gt; bool:
        if self.is_container:
            self.scroll_up()
            return True
        return False

    def key_up(self) -&gt; bool:
        if self.is_container:
            self.scroll_down()
            return True
        return False

    def key_pagedown(self) -&gt; bool:
        if self.is_container:
            self.scroll_page_down()
            return True
        return False

    def key_pageup(self) -&gt; bool:
        if self.is_container:
            self.scroll_page_up()
            return True
        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.widget.RenderCache"><code class="flex name class">
<span>class <span class="ident">RenderCache</span></span>
<span>(</span><span>size: Size, lines: Lines)</span>
</code></dt>
<dd>
<div class="desc"><p>RenderCache(size, lines)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RenderCache(NamedTuple):
    size: Size
    lines: Lines

    @property
    def cursor_line(self) -&gt; int | None:
        for index, line in enumerate(self.lines):
            for _text, style, _control in line:
                if style and style._meta and style.meta.get(&#34;cursor&#34;, False):
                    return index
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="textual.widget.RenderCache.cursor_line"><code class="name">var <span class="ident">cursor_line</span> : int | None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cursor_line(self) -&gt; int | None:
    for index, line in enumerate(self.lines):
        for _text, style, _control in line:
            if style and style._meta and style.meta.get(&#34;cursor&#34;, False):
                return index
    return None</code></pre>
</details>
</dd>
<dt id="textual.widget.RenderCache.lines"><code class="name">var <span class="ident">lines</span> : List[List[rich.segment.Segment]]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="textual.widget.RenderCache.size"><code class="name">var <span class="ident">size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="textual.widget.Widget"><code class="flex name class">
<span>class <span class="ident">Widget</span></span>
<span>(</span><span>*children: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>, name: str | None = None, id: str | None = None, classes: str | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A node in a hierarchy of things forming the UI.</p>
<p>Nodes are mountable and may be styled with CSS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Widget(DOMNode):

    CSS = &#34;&#34;&#34;
    &#34;&#34;&#34;

    can_focus: bool = False
    can_focus_children: bool = True

    def __init__(
        self,
        *children: Widget,
        name: str | None = None,
        id: str | None = None,
        classes: str | None = None,
    ) -&gt; None:

        self._size = Size(0, 0)
        self._virtual_size = Size(0, 0)
        self._container_size = Size(0, 0)
        self._layout_required = False
        self._repaint_required = False
        self._default_layout = VerticalLayout()
        self._animate: BoundAnimator | None = None
        self._reactive_watches: dict[str, Callable] = {}
        self.highlight_style: Style | None = None

        self._vertical_scrollbar: ScrollBar | None = None
        self._horizontal_scrollbar: ScrollBar | None = None

        self._render_cache = RenderCache(Size(0, 0), [])
        self._dirty_regions: list[Region] = []

        # Cache the auto content dimensions
        # TODO: add mechanism to explicitly clear this
        self._content_width_cache: tuple[object, int] = (None, 0)
        self._content_height_cache: tuple[object, int] = (None, 0)

        super().__init__(name=name, id=id, classes=classes)
        self.add_children(*children)

    auto_width = Reactive(True)
    auto_height = Reactive(True)
    has_focus = Reactive(False)
    descendant_has_focus = Reactive(False)
    mouse_over = Reactive(False)
    scroll_x = Reactive(0.0, repaint=False, layout=True)
    scroll_y = Reactive(0.0, repaint=False, layout=True)
    scroll_target_x = Reactive(0.0, repaint=False)
    scroll_target_y = Reactive(0.0, repaint=False)
    show_vertical_scrollbar = Reactive(False, layout=True)
    show_horizontal_scrollbar = Reactive(False, layout=True)

    def watch_show_horizontal_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_horizontal_scrollbar attribute.

        Args:
            value (bool): Show horizontal scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def watch_show_vertical_scrollbar(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Watch function for show_vertical_scrollbar attribute.

        Args:
            value (bool): Show vertical scrollbar flag.
        &#34;&#34;&#34;
        if not value:
            # reset the scroll position if the scrollbar is hidden.
            self.scroll_to(0, 0, animate=False)

    def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
        self.app.register(self, *anon_widgets, **widgets)
        self.screen.refresh()

    def compose(self) -&gt; ComposeResult:
        &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
        return
        yield

    def on_register(self, app: App) -&gt; None:
        &#34;&#34;&#34;Called when the instance is registered.

        Args:
            app (App): App instance.
        &#34;&#34;&#34;
        # Parser the Widget&#39;s CSS
        self.app.stylesheet.add_source(
            self.CSS, f&#34;{__file__}:&lt;{self.__class__.__name__}&gt;&#34;
        )

    def get_box_model(self, container: Size, viewport: Size) -&gt; BoxModel:
        &#34;&#34;&#34;Process the box model for this widget.

        Args:
            container (Size): The size of the container widget (with a layout)
            viewport (Size): The viewport size.

        Returns:
            BoxModel: The size and margin for this widget.
        &#34;&#34;&#34;
        box_model = get_box_model(
            self.styles,
            container,
            viewport,
            self.get_content_width,
            self.get_content_height,
        )
        return box_model

    def get_content_width(self, container: Size, viewport: Size) -&gt; int:
        &#34;&#34;&#34;Gets the width of the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.

        Returns:
            int: The optimal width of the content.
        &#34;&#34;&#34;
        if self.is_container:
            return self.layout.get_content_width(self, container, viewport)

        cache_key = container.width
        if self._content_width_cache[0] == cache_key:
            return self._content_width_cache[1]

        console = self.app.console
        renderable = self.render(self.styles.rich_style)
        measurement = Measurement.get(
            console,
            console.options.update_width(container.width),
            renderable,
        )
        width = measurement.maximum
        self._content_width_cache = (cache_key, width)
        return width

    def get_content_height(self, container: Size, viewport: Size, width: int) -&gt; int:
        &#34;&#34;&#34;Gets the height (number of lines) in the content area.

        Args:
            container (Size): Size of the container (immediate parent) widget.
            viewport (Size): Size of the viewport.
            width (int): Width of renderable.

        Returns:
            int: The height of the content.
        &#34;&#34;&#34;
        if self.is_container:
            assert self.layout is not None
            height = self.layout.get_content_height(
                self,
                container,
                viewport,
                width,
            )
        else:
            cache_key = width

            if self._content_height_cache[0] == cache_key:
                return self._content_height_cache[1]

            renderable = self.render(self.styles.rich_style)
            options = self.console.options.update_width(width).update(highlight=False)
            segments = self.console.render(renderable, options)
            # Cheaper than counting the lines returned from render_lines!
            height = sum(text.count(&#34;\n&#34;) for text, _, _ in segments)
            self._content_height_cache = (cache_key, height)

        return height

    async def watch_scroll_x(self, new_value: float) -&gt; None:
        self.horizontal_scrollbar.position = int(new_value)

    async def watch_scroll_y(self, new_value: float) -&gt; None:
        self.vertical_scrollbar.position = int(new_value)

    def validate_scroll_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_target_x(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_x)

    def validate_scroll_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    def validate_scroll_target_y(self, value: float) -&gt; float:
        return clamp(value, 0, self.max_scroll_y)

    @property
    def max_scroll_x(self) -&gt; float:
        return max(0, self.virtual_size.width - self.container_size.width)

    @property
    def max_scroll_y(self) -&gt; float:
        return max(0, self.virtual_size.height - self.container_size.height)

    @property
    def vertical_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._vertical_scrollbar is not None:
            return self._vertical_scrollbar
        self._vertical_scrollbar = scroll_bar = ScrollBar(
            vertical=True, name=&#34;vertical&#34;
        )
        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    @property
    def horizontal_scrollbar(self) -&gt; ScrollBar:
        &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

        Returns:
            ScrollBar: ScrollBar Widget.
        &#34;&#34;&#34;
        from .scrollbar import ScrollBar

        if self._horizontal_scrollbar is not None:
            return self._horizontal_scrollbar
        self._horizontal_scrollbar = scroll_bar = ScrollBar(
            vertical=False, name=&#34;horizontal&#34;
        )

        self.app.start_widget(self, scroll_bar)
        return scroll_bar

    def _refresh_scrollbars(self) -&gt; None:
        &#34;&#34;&#34;Refresh scrollbar visibility.&#34;&#34;&#34;
        if not self.is_container:
            return

        styles = self.styles
        overflow_x = styles.overflow_x
        overflow_y = styles.overflow_y
        width, height = self.container_size

        show_horizontal = self.show_horizontal_scrollbar
        if overflow_x == &#34;hidden&#34;:
            show_horizontal = False
        if overflow_x == &#34;scroll&#34;:
            show_horizontal = True
        elif overflow_x == &#34;auto&#34;:
            show_horizontal = self.virtual_size.width &gt; width

        show_vertical = self.show_vertical_scrollbar
        if overflow_y == &#34;hidden&#34;:
            show_vertical = False
        elif overflow_y == &#34;scroll&#34;:
            show_vertical = True
        elif overflow_y == &#34;auto&#34;:
            show_vertical = self.virtual_size.height &gt; height

        self.show_horizontal_scrollbar = show_horizontal
        self.show_vertical_scrollbar = show_vertical
        self.horizontal_scrollbar.display = show_horizontal
        self.vertical_scrollbar.display = show_vertical

    @property
    def scrollbars_enabled(self) -&gt; tuple[bool, bool]:
        &#34;&#34;&#34;A tuple of booleans that indicate if scrollbars are enabled.

        Returns:
            tuple[bool, bool]: A tuple of (&lt;vertical scrollbar enabled&gt;, &lt;horizontal scrollbar enabled&gt;)

        &#34;&#34;&#34;
        if self.layout is None:
            return False, False

        enabled = self.show_vertical_scrollbar, self.show_horizontal_scrollbar
        return enabled

    def set_dirty(self) -&gt; None:
        &#34;&#34;&#34;Set the Widget as &#39;dirty&#39; (requiring re-render).&#34;&#34;&#34;
        self._dirty_regions.clear()
        self._dirty_regions.append(self.size.region)

    def scroll_to(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll to a given (absolute) coordinate, optionally animating.

        Args:
            x (int | None, optional): X coordinate (column) to scroll to, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y coordinate (row) to scroll to, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        scrolled_x = scrolled_y = False

        if animate:
            # TODO: configure animation speed
            if x is not None:
                self.scroll_target_x = x
                if x != self.scroll_x:
                    self.animate(
                        &#34;scroll_x&#34;,
                        self.scroll_target_x,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_x = True
            if y is not None:
                self.scroll_target_y = y
                if y != self.scroll_y:
                    self.animate(
                        &#34;scroll_y&#34;,
                        self.scroll_target_y,
                        speed=speed,
                        duration=duration,
                        easing=&#34;out_cubic&#34;,
                    )
                    scrolled_y = True

        else:
            if x is not None:
                scroll_x = self.scroll_x
                self.scroll_target_x = self.scroll_x = x
                scrolled_x = scroll_x != self.scroll_x
            if y is not None:
                scroll_y = self.scroll_y
                self.scroll_target_y = self.scroll_y = y
                scrolled_y = scroll_y != self.scroll_y
            if scrolled_x or scrolled_y:
                self.refresh(repaint=False, layout=True)

        return scrolled_x or scrolled_y

    def scroll_relative(
        self,
        x: float | None = None,
        y: float | None = None,
        *,
        animate: bool = True,
        speed: float | None = None,
        duration: float | None = None,
    ) -&gt; bool:
        &#34;&#34;&#34;Scroll relative to current position.

        Args:
            x (int | None, optional): X distance (columns) to scroll, or ``None`` for no change. Defaults to None.
            y (int | None, optional): Y distance (rows) to scroll, or ``None`` for no change. Defaults to None.
            animate (bool, optional): Animate to new scroll position. Defaults to False.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;
        return self.scroll_to(
            None if x is None else (self.scroll_x + x),
            None if y is None else (self.scroll_y + y),
            animate=animate,
            speed=speed,
            duration=duration,
        )

    def scroll_home(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, 0, animate=animate)

    def scroll_end(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(0, self.max_scroll_y, animate=animate)

    def scroll_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x - 1, animate=animate)

    def scroll_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(x=self.scroll_target_x + 1, animate=animate)

    def scroll_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y + 1, animate=animate)

    def scroll_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(y=self.scroll_target_y - 1, animate=animate)

    def scroll_page_up(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y - self.container_size.height, animate=animate
        )

    def scroll_page_down(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            y=self.scroll_target_y + self.container_size.height, animate=animate
        )

    def scroll_page_left(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x - self.container_size.width, animate=animate
        )

    def scroll_page_right(self, *, animate: bool = True) -&gt; bool:
        return self.scroll_to(
            x=self.scroll_target_x + self.container_size.width, animate=animate
        )

    def scroll_to_widget(self, widget: Widget, *, animate: bool = True) -&gt; bool:
        &#34;&#34;&#34;Scroll so that a child widget is in the visible area.

        Args:
            widget (Widget): A Widget in the children.
            animate (bool, optional): True to animate, or False to jump. Defaults to True.

        Returns:
            bool: True if the scroll position changed, otherwise False.
        &#34;&#34;&#34;

        try:
            widget_region = widget.content_region
            container_region = self.content_region
        except errors.NoWidget:
            return False

        if widget_region in container_region:
            # Widget is visible, nothing to do
            return False

        # We can either scroll so the widget is at the top of the container, or so that
        # it is at the bottom. We want to pick which has the shortest distance
        top_delta = widget_region.origin - container_region.origin

        bottom_delta = widget_region.origin - (
            container_region.origin
            + Offset(0, container_region.height - widget_region.height)
        )

        if widget_region.width &gt; container_region.width:
            delta_x = top_delta.x
        else:
            delta_x = min(top_delta.x, bottom_delta.x, key=abs)

        if widget_region.height &gt; container_region.height:
            delta_y = top_delta.y
        else:
            delta_y = min(top_delta.y, bottom_delta.y, key=abs)

        return self.scroll_relative(
            delta_x or None, delta_y or None, animate=animate, duration=0.2
        )

    def __init_subclass__(
        cls, can_focus: bool = True, can_focus_children: bool = True
    ) -&gt; None:
        super().__init_subclass__()
        cls.can_focus = can_focus
        cls.can_focus_children = can_focus_children

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;id&#34;, self.id, None
        if self.name:
            yield &#34;name&#34;, self.name
        if self.classes:
            yield &#34;classes&#34;, set(self.classes)
        pseudo_classes = self.pseudo_classes
        if pseudo_classes:
            yield &#34;pseudo_classes&#34;, set(pseudo_classes)

    def _arrange_container(self, region: Region) -&gt; Region:
        &#34;&#34;&#34;Adjusts the Widget region to accommodate scrollbars.

        Args:
            region (Region): A region for the widget.

        Returns:
            Region: The widget region minus scrollbars.
        &#34;&#34;&#34;
        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled
        if self.styles.scrollbar_gutter == &#34;stable&#34;:
            # Let&#39;s _always_ reserve some space, whether the scrollbar is actually displayed or not:
            show_vertical_scrollbar = True
        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (region, _, _, _) = region.split(-1, -1)
        elif show_vertical_scrollbar:
            region, _ = region.split_vertical(-1)
        elif show_horizontal_scrollbar:
            region, _ = region.split_horizontal(-1)
        return region

    def _arrange_scrollbars(self, size: Size) -&gt; Iterable[tuple[Widget, Region]]:
        &#34;&#34;&#34;Arrange the &#39;chrome&#39; widgets (typically scrollbars) for a layout element.

        Args:
            size (Size): _description_

        Returns:
            Iterable[tuple[Widget, Region]]: _description_

        Yields:
            Iterator[Iterable[tuple[Widget, Region]]]: _description_
        &#34;&#34;&#34;
        region = size.region
        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled

        if show_horizontal_scrollbar and show_vertical_scrollbar:
            (
                region,
                vertical_scrollbar_region,
                horizontal_scrollbar_region,
                _,
            ) = region.split(-1, -1)
            if vertical_scrollbar_region:
                yield self.vertical_scrollbar, vertical_scrollbar_region
            if horizontal_scrollbar_region:
                yield self.horizontal_scrollbar, horizontal_scrollbar_region
        elif show_vertical_scrollbar:
            region, scrollbar_region = region.split_vertical(-1)
            if scrollbar_region:
                yield self.vertical_scrollbar, scrollbar_region
        elif show_horizontal_scrollbar:
            region, scrollbar_region = region.split_horizontal(-1)
            if scrollbar_region:
                yield self.horizontal_scrollbar, scrollbar_region

    def get_pseudo_classes(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;Pseudo classes for a widget&#34;&#34;&#34;
        if self.mouse_over:
            yield &#34;hover&#34;
        if self.has_focus:
            yield &#34;focus&#34;
        if self.descendant_has_focus:
            yield &#34;focus-within&#34;

    def watch(self, attribute_name, callback: Callable[[Any], Awaitable[None]]) -&gt; None:
        watch(self, attribute_name, callback)

    def render_styled(self) -&gt; RenderableType:
        &#34;&#34;&#34;Applies style attributes to the default renderable.

        Returns:
            RenderableType: A new renderable.
        &#34;&#34;&#34;
        renderable = self.render(self.text_style)

        (base_background, base_color), (background, color) = self.colors
        styles = self.styles

        content_align = (styles.content_align_horizontal, styles.content_align_vertical)
        if content_align != (&#34;left&#34;, &#34;top&#34;):
            horizontal, vertical = content_align
            renderable = Align(renderable, horizontal, vertical=vertical)

        renderable = Padding(
            renderable,
            styles.padding,
            style=Style.from_color(color.rich_color, background.rich_color),
        )

        if styles.border:
            renderable = Border(
                renderable,
                styles.border,
                inner_color=background,
                outer_color=base_background,
            )

        if styles.outline:
            renderable = Border(
                renderable,
                styles.outline,
                inner_color=styles.background,
                outer_color=base_background,
                outline=True,
            )

        if styles.tint.a != 0:
            renderable = Tint(renderable, styles.tint)
        if styles.opacity != 1.0:
            renderable = Opacity(renderable, opacity=styles.opacity)

        return renderable

    @property
    def size(self) -&gt; Size:
        return self._size

    @property
    def container_size(self) -&gt; Size:
        return self._container_size

    @property
    def content_region(self) -&gt; Region:
        &#34;&#34;&#34;Gets an absolute region containing the content (minus padding and border).&#34;&#34;&#34;
        return self.region.shrink(self.styles.content_gutter)

    @property
    def content_offset(self) -&gt; Offset:
        &#34;&#34;&#34;An offset from the Widget origin where the content begins.&#34;&#34;&#34;
        x, y = self.styles.content_gutter.top_left
        return Offset(x, y)

    @property
    def virtual_size(self) -&gt; Size:
        return self._virtual_size

    @property
    def region(self) -&gt; Region:
        &#34;&#34;&#34;The region occupied by this widget, relative to the Screen.&#34;&#34;&#34;
        try:
            return self.screen.find_widget(self).region
        except errors.NoWidget:
            return Region()

    @property
    def scroll_offset(self) -&gt; Offset:
        return Offset(int(self.scroll_x), int(self.scroll_y))

    @property
    def is_transparent(self) -&gt; bool:
        &#34;&#34;&#34;Check if the background styles is not set.

        Returns:
            bool: ``True`` if there is background color, otherwise ``False``.
        &#34;&#34;&#34;
        return self.is_container and self.styles.background.is_transparent

    @property
    def console(self) -&gt; Console:
        &#34;&#34;&#34;Get the current console.&#34;&#34;&#34;
        return active_app.get().console

    @property
    def animate(self) -&gt; BoundAnimator:
        if self._animate is None:
            self._animate = self.app.animator.bind(self)
        assert self._animate is not None
        return self._animate

    @property
    def layout(self) -&gt; Layout:
        &#34;&#34;&#34;Get the layout object if set in styles, or a default layout.&#34;&#34;&#34;
        return self.styles.layout or self._default_layout

    @property
    def is_container(self) -&gt; bool:
        &#34;&#34;&#34;Check if this widget is a container (contains other widgets)

        Returns:
            bool: True if this widget is a container.
        &#34;&#34;&#34;
        return self.styles.layout is not None or bool(self.children)

    def watch_mouse_over(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if mouse over state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def watch_has_focus(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Update from CSS if has focus state changes.&#34;&#34;&#34;
        self.app.update_styles()

    def on_style_change(self) -&gt; None:
        self.set_dirty()
        self.check_idle()

    def size_updated(
        self, size: Size, virtual_size: Size, container_size: Size
    ) -&gt; None:
        if self._size != size or self._virtual_size != virtual_size:
            self._size = size
            self._virtual_size = virtual_size
            self._container_size = container_size

            if self.is_container:
                self._refresh_scrollbars()
                width, height = self.container_size
                if self.show_vertical_scrollbar:
                    self.vertical_scrollbar.window_virtual_size = virtual_size.height
                    self.vertical_scrollbar.window_size = height
                if self.show_horizontal_scrollbar:
                    self.horizontal_scrollbar.window_virtual_size = virtual_size.width
                    self.horizontal_scrollbar.window_size = width

                self.scroll_x = self.validate_scroll_x(self.scroll_x)
                self.scroll_y = self.validate_scroll_y(self.scroll_y)
                self.refresh(layout=True)
                self.call_later(self.scroll_to, self.scroll_x, self.scroll_y)
            else:
                self.refresh()

    def _render_lines(self) -&gt; None:
        &#34;&#34;&#34;Render all lines.&#34;&#34;&#34;
        width, height = self.size
        renderable = self.render_styled()
        options = self.console.options.update_dimensions(width, height).update(
            highlight=False
        )
        lines = self.console.render_lines(renderable, options)
        self._render_cache = RenderCache(self.size, lines)
        self._dirty_regions.clear()

    def get_render_lines(
        self, start: int | None = None, end: int | None = None
    ) -&gt; Lines:
        &#34;&#34;&#34;Get segment lines to render the widget.

        Args:
            start (int | None, optional): line start index, or None for first line. Defaults to None.
            end (int | None, optional): line end index, or None for last line. Defaults to None.

        Returns:
            Lines: A list of lists of segments.
        &#34;&#34;&#34;
        if self._dirty_regions:
            self._render_lines()
            if self.is_container:
                if self.show_horizontal_scrollbar:
                    self.horizontal_scrollbar.refresh()
                if self.show_vertical_scrollbar:
                    self.vertical_scrollbar.refresh()
        lines = self._render_cache.lines[start:end]
        return lines

    def check_layout(self) -&gt; bool:
        &#34;&#34;&#34;Check if a layout has been requested.&#34;&#34;&#34;
        return self._layout_required

    def get_style_at(self, x: int, y: int) -&gt; Style:
        offset_x, offset_y = self.screen.get_offset(self)
        return self.screen.get_style_at(x + offset_x, y + offset_y)

    def call_later(self, callback: Callable, *args, **kwargs) -&gt; None:
        self.app.call_later(callback, *args, **kwargs)

    async def forward_event(self, event: events.Event) -&gt; None:
        event.set_forwarded()
        await self.post_message(event)

    def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
        &#34;&#34;&#34;Initiate a refresh of the widget.

        This method sets an internal flag to perform a refresh, which will be done on the
        next idle event. Only one refresh will be done even if this method is called multiple times.

        Args:
            repaint (bool, optional): Repaint the widget (will call render() again). Defaults to True.
            layout (bool, optional): Also layout widgets in the view. Defaults to False.
        &#34;&#34;&#34;
        if layout:
            self._layout_required = True
        if repaint:
            self._content_width_cache = (None, 0)
            self._content_height_cache = (None, 0)
            self.set_dirty()
            self._repaint_required = True
        self.check_idle()

    def render(self, style: Style) -&gt; RenderableType:
        &#34;&#34;&#34;Get renderable for widget.

        Args:
            style (Styles): The Styles object for this Widget.

        Returns:
            RenderableType: Any renderable
        &#34;&#34;&#34;
        return &#34;&#34; if self.is_container else self.css_identifier_styled

    async def action(self, action: str, *params) -&gt; None:
        await self.app.action(action, self)

    async def post_message(self, message: Message) -&gt; bool:
        if not self.check_message_enabled(message):
            return True
        if not self.is_running:
            self.log(self, f&#34;IS NOT RUNNING, {message!r} not sent&#34;)
        return await super().post_message(message)

    def on_idle(self, event: events.Idle) -&gt; None:
        &#34;&#34;&#34;Called when there are no more events on the queue.

        Args:
            event (events.Idle): Idle event.
        &#34;&#34;&#34;

        if self.check_layout():
            self._layout_required = False
            self.screen.post_message_no_wait(messages.Layout(self))
        elif self._repaint_required:
            self.emit_no_wait(messages.Update(self, self))
        self._repaint_required = False

    def focus(self) -&gt; None:
        &#34;&#34;&#34;Give input focus to this widget.&#34;&#34;&#34;
        self.app.set_focus(self)

    async def capture_mouse(self, capture: bool = True) -&gt; None:
        &#34;&#34;&#34;Capture (or release) the mouse.

        When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.

        Args:
            capture (bool, optional): True to capture or False to release. Defaults to True.
        &#34;&#34;&#34;
        await self.app.capture_mouse(self if capture else None)

    async def release_mouse(self) -&gt; None:
        &#34;&#34;&#34;Release the mouse.

        Mouse events will only be sent when the mouse is over the widget.
        &#34;&#34;&#34;
        await self.app.capture_mouse(None)

    async def broker_event(self, event_name: str, event: events.Event) -&gt; bool:
        return await self.app.broker_event(event_name, event, default_namespace=self)

    async def on_mouse_down(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.down&#34;, event)

    async def on_mouse_up(self, event: events.MouseUp) -&gt; None:
        await self.broker_event(&#34;mouse.up&#34;, event)

    async def on_click(self, event: events.Click) -&gt; None:
        await self.broker_event(&#34;click&#34;, event)

    async def on_key(self, event: events.Key) -&gt; None:
        await self.dispatch_key(event)

    def on_mount(self, event: events.Mount) -&gt; None:
        widgets = list(self.compose())
        if widgets:
            self.mount(*widgets)
            self.screen.refresh(repaint=False, layout=True)

    def on_leave(self) -&gt; None:
        self.mouse_over = False

    def on_enter(self) -&gt; None:
        self.mouse_over = True

    def on_focus(self, event: events.Focus) -&gt; None:
        self.emit_no_wait(events.DescendantFocus(self))
        self.has_focus = True
        self.refresh()

    def on_blur(self, event: events.Blur) -&gt; None:
        self.emit_no_wait(events.DescendantBlur(self))
        self.has_focus = False
        self.refresh()

    def on_descendant_focus(self, event: events.DescendantFocus) -&gt; None:
        self.descendant_has_focus = True
        if self.is_container and isinstance(event.sender, Widget):
            self.scroll_to_widget(event.sender, animate=True)

    def on_descendant_blur(self, event: events.DescendantBlur) -&gt; None:
        self.descendant_has_focus = False

    def on_mouse_scroll_down(self, event) -&gt; None:
        if self.is_container:
            if self.scroll_down(animate=False):
                event.stop()

    def on_mouse_scroll_up(self, event) -&gt; None:
        if self.is_container:
            if self.scroll_up(animate=False):
                event.stop()

    def handle_scroll_to(self, message: ScrollTo) -&gt; None:
        if self.is_container:
            self.scroll_to(message.x, message.y, animate=message.animate)
            message.stop()

    def handle_scroll_up(self, event: ScrollUp) -&gt; None:
        if self.is_container:
            self.scroll_page_up()
            event.stop()

    def handle_scroll_down(self, event: ScrollDown) -&gt; None:
        if self.is_container:
            self.scroll_page_down()
            event.stop()

    def handle_scroll_left(self, event: ScrollLeft) -&gt; None:
        if self.is_container:
            self.scroll_page_left()
            event.stop()

    def handle_scroll_right(self, event: ScrollRight) -&gt; None:
        if self.is_container:
            self.scroll_page_right()
            event.stop()

    def key_home(self) -&gt; bool:
        if self.is_container:
            self.scroll_home()
            return True
        return False

    def key_end(self) -&gt; bool:
        if self.is_container:
            self.scroll_end()
            return True
        return False

    def key_left(self) -&gt; bool:
        if self.is_container:
            self.scroll_left()
            return True
        return False

    def key_right(self) -&gt; bool:
        if self.is_container:
            self.scroll_right()
            return True
        return False

    def key_down(self) -&gt; bool:
        if self.is_container:
            self.scroll_up()
            return True
        return False

    def key_up(self) -&gt; bool:
        if self.is_container:
            self.scroll_down()
            return True
        return False

    def key_pagedown(self) -&gt; bool:
        if self.is_container:
            self.scroll_page_down()
            return True
        return False

    def key_pageup(self) -&gt; bool:
        if self.is_container:
            self.scroll_page_up()
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></li>
<li><a title="textual.message_pump.MessagePump" href="message_pump.html#textual.message_pump.MessagePump">MessagePump</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textual.layout.Horizontal" href="layout.html#textual.layout.Horizontal">Horizontal</a></li>
<li><a title="textual.layout.Vertical" href="layout.html#textual.layout.Vertical">Vertical</a></li>
<li><a title="textual.screen.Screen" href="screen.html#textual.screen.Screen">Screen</a></li>
<li><a title="textual.scrollbar.ScrollBar" href="scrollbar.html#textual.scrollbar.ScrollBar">ScrollBar</a></li>
<li>textual.widgets._button.Button</li>
<li>textual.widgets._footer.Footer</li>
<li>textual.widgets._header.Header</li>
<li>textual.widgets._placeholder.Placeholder</li>
<li>textual.widgets._static.Static</li>
<li>textual.widgets._tree_control.TreeControl</li>
<li><a title="textual.widgets.tabs.Tabs" href="widgets/tabs.html#textual.widgets.tabs.Tabs">Tabs</a></li>
<li><a title="textual.widgets.text_input.TextArea" href="widgets/text_input.html#textual.widgets.text_input.TextArea">TextArea</a></li>
<li><a title="textual.widgets.text_input.TextWidgetBase" href="widgets/text_input.html#textual.widgets.text_input.TextWidgetBase">TextWidgetBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="textual.widget.Widget.CSS"><code class="name">var <span class="ident">CSS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.widget.Widget.can_focus"><code class="name">var <span class="ident">can_focus</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="textual.widget.Widget.can_focus_children"><code class="name">var <span class="ident">can_focus_children</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="textual.widget.Widget.animate"><code class="name">var <span class="ident">animate</span> : textual._animator.BoundAnimator</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def animate(self) -&gt; BoundAnimator:
    if self._animate is None:
        self._animate = self.app.animator.bind(self)
    assert self._animate is not None
    return self._animate</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.auto_height"><code class="name">var <span class="ident">auto_height</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.auto_width"><code class="name">var <span class="ident">auto_width</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.console"><code class="name">var <span class="ident">console</span> : rich.console.Console</code></dt>
<dd>
<div class="desc"><p>Get the current console.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def console(self) -&gt; Console:
    &#34;&#34;&#34;Get the current console.&#34;&#34;&#34;
    return active_app.get().console</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.container_size"><code class="name">var <span class="ident">container_size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def container_size(self) -&gt; Size:
    return self._container_size</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.content_offset"><code class="name">var <span class="ident">content_offset</span> : <a title="textual.geometry.Offset" href="geometry.html#textual.geometry.Offset">Offset</a></code></dt>
<dd>
<div class="desc"><p>An offset from the Widget origin where the content begins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content_offset(self) -&gt; Offset:
    &#34;&#34;&#34;An offset from the Widget origin where the content begins.&#34;&#34;&#34;
    x, y = self.styles.content_gutter.top_left
    return Offset(x, y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.content_region"><code class="name">var <span class="ident">content_region</span> : <a title="textual.geometry.Region" href="geometry.html#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>Gets an absolute region containing the content (minus padding and border).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content_region(self) -&gt; Region:
    &#34;&#34;&#34;Gets an absolute region containing the content (minus padding and border).&#34;&#34;&#34;
    return self.region.shrink(self.styles.content_gutter)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.descendant_has_focus"><code class="name">var <span class="ident">descendant_has_focus</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.has_focus"><code class="name">var <span class="ident">has_focus</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.horizontal_scrollbar"><code class="name">var <span class="ident">horizontal_scrollbar</span> : ScrollBar</code></dt>
<dd>
<div class="desc"><p>Get a vertical scrollbar (create if necessary)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrollBar</code></dt>
<dd>ScrollBar Widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def horizontal_scrollbar(self) -&gt; ScrollBar:
    &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

    Returns:
        ScrollBar: ScrollBar Widget.
    &#34;&#34;&#34;
    from .scrollbar import ScrollBar

    if self._horizontal_scrollbar is not None:
        return self._horizontal_scrollbar
    self._horizontal_scrollbar = scroll_bar = ScrollBar(
        vertical=False, name=&#34;horizontal&#34;
    )

    self.app.start_widget(self, scroll_bar)
    return scroll_bar</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.is_container"><code class="name">var <span class="ident">is_container</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if this widget is a container (contains other widgets)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if this widget is a container.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_container(self) -&gt; bool:
    &#34;&#34;&#34;Check if this widget is a container (contains other widgets)

    Returns:
        bool: True if this widget is a container.
    &#34;&#34;&#34;
    return self.styles.layout is not None or bool(self.children)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.is_transparent"><code class="name">var <span class="ident">is_transparent</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if the background styles is not set.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if there is background color, otherwise <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_transparent(self) -&gt; bool:
    &#34;&#34;&#34;Check if the background styles is not set.

    Returns:
        bool: ``True`` if there is background color, otherwise ``False``.
    &#34;&#34;&#34;
    return self.is_container and self.styles.background.is_transparent</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.layout"><code class="name">var <span class="ident">layout</span> : textual._layout.Layout</code></dt>
<dd>
<div class="desc"><p>Get the layout object if set in styles, or a default layout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layout(self) -&gt; Layout:
    &#34;&#34;&#34;Get the layout object if set in styles, or a default layout.&#34;&#34;&#34;
    return self.styles.layout or self._default_layout</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.max_scroll_x"><code class="name">var <span class="ident">max_scroll_x</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_scroll_x(self) -&gt; float:
    return max(0, self.virtual_size.width - self.container_size.width)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.max_scroll_y"><code class="name">var <span class="ident">max_scroll_y</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_scroll_y(self) -&gt; float:
    return max(0, self.virtual_size.height - self.container_size.height)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.mouse_over"><code class="name">var <span class="ident">mouse_over</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.region"><code class="name">var <span class="ident">region</span> : <a title="textual.geometry.Region" href="geometry.html#textual.geometry.Region">Region</a></code></dt>
<dd>
<div class="desc"><p>The region occupied by this widget, relative to the Screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def region(self) -&gt; Region:
    &#34;&#34;&#34;The region occupied by this widget, relative to the Screen.&#34;&#34;&#34;
    try:
        return self.screen.find_widget(self).region
    except errors.NoWidget:
        return Region()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_offset"><code class="name">var <span class="ident">scroll_offset</span> : <a title="textual.geometry.Offset" href="geometry.html#textual.geometry.Offset">Offset</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scroll_offset(self) -&gt; Offset:
    return Offset(int(self.scroll_x), int(self.scroll_y))</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_target_x"><code class="name">var <span class="ident">scroll_target_x</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_target_y"><code class="name">var <span class="ident">scroll_target_y</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_x"><code class="name">var <span class="ident">scroll_x</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_y"><code class="name">var <span class="ident">scroll_y</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scrollbars_enabled"><code class="name">var <span class="ident">scrollbars_enabled</span> : tuple[bool, bool]</code></dt>
<dd>
<div class="desc"><p>A tuple of booleans that indicate if scrollbars are enabled.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[bool, bool]</code></dt>
<dd>A tuple of (<vertical scrollbar enabled>, <horizontal scrollbar enabled>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scrollbars_enabled(self) -&gt; tuple[bool, bool]:
    &#34;&#34;&#34;A tuple of booleans that indicate if scrollbars are enabled.

    Returns:
        tuple[bool, bool]: A tuple of (&lt;vertical scrollbar enabled&gt;, &lt;horizontal scrollbar enabled&gt;)

    &#34;&#34;&#34;
    if self.layout is None:
        return False, False

    enabled = self.show_vertical_scrollbar, self.show_horizontal_scrollbar
    return enabled</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.show_horizontal_scrollbar"><code class="name">var <span class="ident">show_horizontal_scrollbar</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.show_vertical_scrollbar"><code class="name">var <span class="ident">show_vertical_scrollbar</span> : ReactiveType</code></dt>
<dd>
<div class="desc"><p>Reactive descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj: Reactable, obj_type: type[object]) -&gt; ReactiveType:
    return getattr(obj, self.internal_name)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.size"><code class="name">var <span class="ident">size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Size:
    return self._size</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.vertical_scrollbar"><code class="name">var <span class="ident">vertical_scrollbar</span> : ScrollBar</code></dt>
<dd>
<div class="desc"><p>Get a vertical scrollbar (create if necessary)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrollBar</code></dt>
<dd>ScrollBar Widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vertical_scrollbar(self) -&gt; ScrollBar:
    &#34;&#34;&#34;Get a vertical scrollbar (create if necessary)

    Returns:
        ScrollBar: ScrollBar Widget.
    &#34;&#34;&#34;
    from .scrollbar import ScrollBar

    if self._vertical_scrollbar is not None:
        return self._vertical_scrollbar
    self._vertical_scrollbar = scroll_bar = ScrollBar(
        vertical=True, name=&#34;vertical&#34;
    )
    self.app.start_widget(self, scroll_bar)
    return scroll_bar</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.virtual_size"><code class="name">var <span class="ident">virtual_size</span> : <a title="textual.geometry.Size" href="geometry.html#textual.geometry.Size">Size</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def virtual_size(self) -&gt; Size:
    return self._virtual_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.widget.Widget.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, action: str, *params) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self, action: str, *params) -&gt; None:
    await self.app.action(action, self)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.broker_event"><code class="name flex">
<span>async def <span class="ident">broker_event</span></span>(<span>self, event_name: str, event: events.Event) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def broker_event(self, event_name: str, event: events.Event) -&gt; bool:
    return await self.app.broker_event(event_name, event, default_namespace=self)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.capture_mouse"><code class="name flex">
<span>async def <span class="ident">capture_mouse</span></span>(<span>self, capture: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Capture (or release) the mouse.</p>
<p>When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>capture</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to capture or False to release. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def capture_mouse(self, capture: bool = True) -&gt; None:
    &#34;&#34;&#34;Capture (or release) the mouse.

    When captured, all mouse coordinates will go to this widget even when the pointer is not directly over the widget.

    Args:
        capture (bool, optional): True to capture or False to release. Defaults to True.
    &#34;&#34;&#34;
    await self.app.capture_mouse(self if capture else None)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.check_layout"><code class="name flex">
<span>def <span class="ident">check_layout</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a layout has been requested.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_layout(self) -&gt; bool:
    &#34;&#34;&#34;Check if a layout has been requested.&#34;&#34;&#34;
    return self._layout_required</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.compose"><code class="name flex">
<span>def <span class="ident">compose</span></span>(<span>self) ‑> ComposeResult</span>
</code></dt>
<dd>
<div class="desc"><p>Yield child widgets for a container.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose(self) -&gt; ComposeResult:
    &#34;&#34;&#34;Yield child widgets for a container.&#34;&#34;&#34;
    return
    yield</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Give input focus to this widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self) -&gt; None:
    &#34;&#34;&#34;Give input focus to this widget.&#34;&#34;&#34;
    self.app.set_focus(self)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.forward_event"><code class="name flex">
<span>async def <span class="ident">forward_event</span></span>(<span>self, event: events.Event) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def forward_event(self, event: events.Event) -&gt; None:
    event.set_forwarded()
    await self.post_message(event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_box_model"><code class="name flex">
<span>def <span class="ident">get_box_model</span></span>(<span>self, container: Size, viewport: Size) ‑> <a title="textual.box_model.BoxModel" href="box_model.html#textual.box_model.BoxModel">BoxModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process the box model for this widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>container</code></strong> :&ensp;<code>Size</code></dt>
<dd>The size of the container widget (with a layout)</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Size</code></dt>
<dd>The viewport size.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BoxModel</code></dt>
<dd>The size and margin for this widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_box_model(self, container: Size, viewport: Size) -&gt; BoxModel:
    &#34;&#34;&#34;Process the box model for this widget.

    Args:
        container (Size): The size of the container widget (with a layout)
        viewport (Size): The viewport size.

    Returns:
        BoxModel: The size and margin for this widget.
    &#34;&#34;&#34;
    box_model = get_box_model(
        self.styles,
        container,
        viewport,
        self.get_content_width,
        self.get_content_height,
    )
    return box_model</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_content_height"><code class="name flex">
<span>def <span class="ident">get_content_height</span></span>(<span>self, container: Size, viewport: Size, width: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the height (number of lines) in the content area.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>container</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the container (immediate parent) widget.</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the viewport.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of renderable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The height of the content.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_height(self, container: Size, viewport: Size, width: int) -&gt; int:
    &#34;&#34;&#34;Gets the height (number of lines) in the content area.

    Args:
        container (Size): Size of the container (immediate parent) widget.
        viewport (Size): Size of the viewport.
        width (int): Width of renderable.

    Returns:
        int: The height of the content.
    &#34;&#34;&#34;
    if self.is_container:
        assert self.layout is not None
        height = self.layout.get_content_height(
            self,
            container,
            viewport,
            width,
        )
    else:
        cache_key = width

        if self._content_height_cache[0] == cache_key:
            return self._content_height_cache[1]

        renderable = self.render(self.styles.rich_style)
        options = self.console.options.update_width(width).update(highlight=False)
        segments = self.console.render(renderable, options)
        # Cheaper than counting the lines returned from render_lines!
        height = sum(text.count(&#34;\n&#34;) for text, _, _ in segments)
        self._content_height_cache = (cache_key, height)

    return height</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_content_width"><code class="name flex">
<span>def <span class="ident">get_content_width</span></span>(<span>self, container: Size, viewport: Size) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the width of the content area.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>container</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the container (immediate parent) widget.</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Size</code></dt>
<dd>Size of the viewport.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The optimal width of the content.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_width(self, container: Size, viewport: Size) -&gt; int:
    &#34;&#34;&#34;Gets the width of the content area.

    Args:
        container (Size): Size of the container (immediate parent) widget.
        viewport (Size): Size of the viewport.

    Returns:
        int: The optimal width of the content.
    &#34;&#34;&#34;
    if self.is_container:
        return self.layout.get_content_width(self, container, viewport)

    cache_key = container.width
    if self._content_width_cache[0] == cache_key:
        return self._content_width_cache[1]

    console = self.app.console
    renderable = self.render(self.styles.rich_style)
    measurement = Measurement.get(
        console,
        console.options.update_width(container.width),
        renderable,
    )
    width = measurement.maximum
    self._content_width_cache = (cache_key, width)
    return width</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_pseudo_classes"><code class="name flex">
<span>def <span class="ident">get_pseudo_classes</span></span>(<span>self) ‑> Iterable[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Pseudo classes for a widget</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pseudo_classes(self) -&gt; Iterable[str]:
    &#34;&#34;&#34;Pseudo classes for a widget&#34;&#34;&#34;
    if self.mouse_over:
        yield &#34;hover&#34;
    if self.has_focus:
        yield &#34;focus&#34;
    if self.descendant_has_focus:
        yield &#34;focus-within&#34;</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_render_lines"><code class="name flex">
<span>def <span class="ident">get_render_lines</span></span>(<span>self, start: int | None = None, end: int | None = None) ‑> Lines</span>
</code></dt>
<dd>
<div class="desc"><p>Get segment lines to render the widget.</p>
<h2 id="args">Args</h2>
<p>start (int | None, optional): line start index, or None for first line. Defaults to None.
end (int | None, optional): line end index, or None for last line. Defaults to None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Lines</code></dt>
<dd>A list of lists of segments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_render_lines(
    self, start: int | None = None, end: int | None = None
) -&gt; Lines:
    &#34;&#34;&#34;Get segment lines to render the widget.

    Args:
        start (int | None, optional): line start index, or None for first line. Defaults to None.
        end (int | None, optional): line end index, or None for last line. Defaults to None.

    Returns:
        Lines: A list of lists of segments.
    &#34;&#34;&#34;
    if self._dirty_regions:
        self._render_lines()
        if self.is_container:
            if self.show_horizontal_scrollbar:
                self.horizontal_scrollbar.refresh()
            if self.show_vertical_scrollbar:
                self.vertical_scrollbar.refresh()
    lines = self._render_cache.lines[start:end]
    return lines</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.get_style_at"><code class="name flex">
<span>def <span class="ident">get_style_at</span></span>(<span>self, x: int, y: int) ‑> rich.style.Style</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_style_at(self, x: int, y: int) -&gt; Style:
    offset_x, offset_y = self.screen.get_offset(self)
    return self.screen.get_style_at(x + offset_x, y + offset_y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_down"><code class="name flex">
<span>def <span class="ident">handle_scroll_down</span></span>(<span>self, event: ScrollDown) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_down(self, event: ScrollDown) -&gt; None:
    if self.is_container:
        self.scroll_page_down()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_left"><code class="name flex">
<span>def <span class="ident">handle_scroll_left</span></span>(<span>self, event: ScrollLeft) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_left(self, event: ScrollLeft) -&gt; None:
    if self.is_container:
        self.scroll_page_left()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_right"><code class="name flex">
<span>def <span class="ident">handle_scroll_right</span></span>(<span>self, event: ScrollRight) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_right(self, event: ScrollRight) -&gt; None:
    if self.is_container:
        self.scroll_page_right()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_to"><code class="name flex">
<span>def <span class="ident">handle_scroll_to</span></span>(<span>self, message: ScrollTo) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_to(self, message: ScrollTo) -&gt; None:
    if self.is_container:
        self.scroll_to(message.x, message.y, animate=message.animate)
        message.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.handle_scroll_up"><code class="name flex">
<span>def <span class="ident">handle_scroll_up</span></span>(<span>self, event: ScrollUp) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_scroll_up(self, event: ScrollUp) -&gt; None:
    if self.is_container:
        self.scroll_page_up()
        event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_down"><code class="name flex">
<span>def <span class="ident">key_down</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_down(self) -&gt; bool:
    if self.is_container:
        self.scroll_up()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_end"><code class="name flex">
<span>def <span class="ident">key_end</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_end(self) -&gt; bool:
    if self.is_container:
        self.scroll_end()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_home"><code class="name flex">
<span>def <span class="ident">key_home</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_home(self) -&gt; bool:
    if self.is_container:
        self.scroll_home()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_left"><code class="name flex">
<span>def <span class="ident">key_left</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_left(self) -&gt; bool:
    if self.is_container:
        self.scroll_left()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_pagedown"><code class="name flex">
<span>def <span class="ident">key_pagedown</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_pagedown(self) -&gt; bool:
    if self.is_container:
        self.scroll_page_down()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_pageup"><code class="name flex">
<span>def <span class="ident">key_pageup</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_pageup(self) -&gt; bool:
    if self.is_container:
        self.scroll_page_up()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_right"><code class="name flex">
<span>def <span class="ident">key_right</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_right(self) -&gt; bool:
    if self.is_container:
        self.scroll_right()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.key_up"><code class="name flex">
<span>def <span class="ident">key_up</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_up(self) -&gt; bool:
    if self.is_container:
        self.scroll_down()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.mount"><code class="name flex">
<span>def <span class="ident">mount</span></span>(<span>self, *anon_widgets: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>, **widgets: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount(self, *anon_widgets: Widget, **widgets: Widget) -&gt; None:
    self.app.register(self, *anon_widgets, **widgets)
    self.screen.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_blur"><code class="name flex">
<span>def <span class="ident">on_blur</span></span>(<span>self, event: events.Blur) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_blur(self, event: events.Blur) -&gt; None:
    self.emit_no_wait(events.DescendantBlur(self))
    self.has_focus = False
    self.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_click"><code class="name flex">
<span>async def <span class="ident">on_click</span></span>(<span>self, event: events.Click) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_click(self, event: events.Click) -&gt; None:
    await self.broker_event(&#34;click&#34;, event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_descendant_blur"><code class="name flex">
<span>def <span class="ident">on_descendant_blur</span></span>(<span>self, event: events.DescendantBlur) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_descendant_blur(self, event: events.DescendantBlur) -&gt; None:
    self.descendant_has_focus = False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_descendant_focus"><code class="name flex">
<span>def <span class="ident">on_descendant_focus</span></span>(<span>self, event: events.DescendantFocus) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_descendant_focus(self, event: events.DescendantFocus) -&gt; None:
    self.descendant_has_focus = True
    if self.is_container and isinstance(event.sender, Widget):
        self.scroll_to_widget(event.sender, animate=True)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_enter"><code class="name flex">
<span>def <span class="ident">on_enter</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_enter(self) -&gt; None:
    self.mouse_over = True</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_focus"><code class="name flex">
<span>def <span class="ident">on_focus</span></span>(<span>self, event: events.Focus) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_focus(self, event: events.Focus) -&gt; None:
    self.emit_no_wait(events.DescendantFocus(self))
    self.has_focus = True
    self.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_idle"><code class="name flex">
<span>def <span class="ident">on_idle</span></span>(<span>self, event: events.Idle) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called when there are no more events on the queue.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>events.Idle</code></dt>
<dd>Idle event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_idle(self, event: events.Idle) -&gt; None:
    &#34;&#34;&#34;Called when there are no more events on the queue.

    Args:
        event (events.Idle): Idle event.
    &#34;&#34;&#34;

    if self.check_layout():
        self._layout_required = False
        self.screen.post_message_no_wait(messages.Layout(self))
    elif self._repaint_required:
        self.emit_no_wait(messages.Update(self, self))
    self._repaint_required = False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_key"><code class="name flex">
<span>async def <span class="ident">on_key</span></span>(<span>self, event: events.Key) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_key(self, event: events.Key) -&gt; None:
    await self.dispatch_key(event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_leave"><code class="name flex">
<span>def <span class="ident">on_leave</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_leave(self) -&gt; None:
    self.mouse_over = False</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mount"><code class="name flex">
<span>def <span class="ident">on_mount</span></span>(<span>self, event: events.Mount) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_mount(self, event: events.Mount) -&gt; None:
    widgets = list(self.compose())
    if widgets:
        self.mount(*widgets)
        self.screen.refresh(repaint=False, layout=True)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_down"><code class="name flex">
<span>async def <span class="ident">on_mouse_down</span></span>(<span>self, event: events.MouseUp) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_mouse_down(self, event: events.MouseUp) -&gt; None:
    await self.broker_event(&#34;mouse.down&#34;, event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_scroll_down"><code class="name flex">
<span>def <span class="ident">on_mouse_scroll_down</span></span>(<span>self, event) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_mouse_scroll_down(self, event) -&gt; None:
    if self.is_container:
        if self.scroll_down(animate=False):
            event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_scroll_up"><code class="name flex">
<span>def <span class="ident">on_mouse_scroll_up</span></span>(<span>self, event) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_mouse_scroll_up(self, event) -&gt; None:
    if self.is_container:
        if self.scroll_up(animate=False):
            event.stop()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_mouse_up"><code class="name flex">
<span>async def <span class="ident">on_mouse_up</span></span>(<span>self, event: events.MouseUp) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_mouse_up(self, event: events.MouseUp) -&gt; None:
    await self.broker_event(&#34;mouse.up&#34;, event)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_register"><code class="name flex">
<span>def <span class="ident">on_register</span></span>(<span>self, app: App) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the instance is registered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>App</code></dt>
<dd>App instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_register(self, app: App) -&gt; None:
    &#34;&#34;&#34;Called when the instance is registered.

    Args:
        app (App): App instance.
    &#34;&#34;&#34;
    # Parser the Widget&#39;s CSS
    self.app.stylesheet.add_source(
        self.CSS, f&#34;{__file__}:&lt;{self.__class__.__name__}&gt;&#34;
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.on_style_change"><code class="name flex">
<span>def <span class="ident">on_style_change</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_style_change(self) -&gt; None:
    self.set_dirty()
    self.check_idle()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.post_message"><code class="name flex">
<span>async def <span class="ident">post_message</span></span>(<span>self, message: Message) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def post_message(self, message: Message) -&gt; bool:
    if not self.check_message_enabled(message):
        return True
    if not self.is_running:
        self.log(self, f&#34;IS NOT RUNNING, {message!r} not sent&#34;)
    return await super().post_message(message)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, *, repaint: bool = True, layout: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a refresh of the widget.</p>
<p>This method sets an internal flag to perform a refresh, which will be done on the
next idle event. Only one refresh will be done even if this method is called multiple times.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repaint</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Repaint the widget (will call render() again). Defaults to True.</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Also layout widgets in the view. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self, *, repaint: bool = True, layout: bool = False) -&gt; None:
    &#34;&#34;&#34;Initiate a refresh of the widget.

    This method sets an internal flag to perform a refresh, which will be done on the
    next idle event. Only one refresh will be done even if this method is called multiple times.

    Args:
        repaint (bool, optional): Repaint the widget (will call render() again). Defaults to True.
        layout (bool, optional): Also layout widgets in the view. Defaults to False.
    &#34;&#34;&#34;
    if layout:
        self._layout_required = True
    if repaint:
        self._content_width_cache = (None, 0)
        self._content_height_cache = (None, 0)
        self.set_dirty()
        self._repaint_required = True
    self.check_idle()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.release_mouse"><code class="name flex">
<span>async def <span class="ident">release_mouse</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Release the mouse.</p>
<p>Mouse events will only be sent when the mouse is over the widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def release_mouse(self) -&gt; None:
    &#34;&#34;&#34;Release the mouse.

    Mouse events will only be sent when the mouse is over the widget.
    &#34;&#34;&#34;
    await self.app.capture_mouse(None)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, style: Style) ‑> Union[rich.console.ConsoleRenderable, rich.console.RichCast, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get renderable for widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>style</code></strong> :&ensp;<code>Styles</code></dt>
<dd>The Styles object for this Widget.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>RenderableType</code></dt>
<dd>Any renderable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, style: Style) -&gt; RenderableType:
    &#34;&#34;&#34;Get renderable for widget.

    Args:
        style (Styles): The Styles object for this Widget.

    Returns:
        RenderableType: Any renderable
    &#34;&#34;&#34;
    return &#34;&#34; if self.is_container else self.css_identifier_styled</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.render_styled"><code class="name flex">
<span>def <span class="ident">render_styled</span></span>(<span>self) ‑> Union[rich.console.ConsoleRenderable, rich.console.RichCast, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies style attributes to the default renderable.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>RenderableType</code></dt>
<dd>A new renderable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_styled(self) -&gt; RenderableType:
    &#34;&#34;&#34;Applies style attributes to the default renderable.

    Returns:
        RenderableType: A new renderable.
    &#34;&#34;&#34;
    renderable = self.render(self.text_style)

    (base_background, base_color), (background, color) = self.colors
    styles = self.styles

    content_align = (styles.content_align_horizontal, styles.content_align_vertical)
    if content_align != (&#34;left&#34;, &#34;top&#34;):
        horizontal, vertical = content_align
        renderable = Align(renderable, horizontal, vertical=vertical)

    renderable = Padding(
        renderable,
        styles.padding,
        style=Style.from_color(color.rich_color, background.rich_color),
    )

    if styles.border:
        renderable = Border(
            renderable,
            styles.border,
            inner_color=background,
            outer_color=base_background,
        )

    if styles.outline:
        renderable = Border(
            renderable,
            styles.outline,
            inner_color=styles.background,
            outer_color=base_background,
            outline=True,
        )

    if styles.tint.a != 0:
        renderable = Tint(renderable, styles.tint)
    if styles.opacity != 1.0:
        renderable = Opacity(renderable, opacity=styles.opacity)

    return renderable</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_down"><code class="name flex">
<span>def <span class="ident">scroll_down</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_down(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(y=self.scroll_target_y - 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_end"><code class="name flex">
<span>def <span class="ident">scroll_end</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_end(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(0, self.max_scroll_y, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_home"><code class="name flex">
<span>def <span class="ident">scroll_home</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_home(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(0, 0, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_left"><code class="name flex">
<span>def <span class="ident">scroll_left</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_left(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(x=self.scroll_target_x - 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_down"><code class="name flex">
<span>def <span class="ident">scroll_page_down</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_down(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        y=self.scroll_target_y + self.container_size.height, animate=animate
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_left"><code class="name flex">
<span>def <span class="ident">scroll_page_left</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_left(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        x=self.scroll_target_x - self.container_size.width, animate=animate
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_right"><code class="name flex">
<span>def <span class="ident">scroll_page_right</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_right(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        x=self.scroll_target_x + self.container_size.width, animate=animate
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_page_up"><code class="name flex">
<span>def <span class="ident">scroll_page_up</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_page_up(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(
        y=self.scroll_target_y - self.container_size.height, animate=animate
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_relative"><code class="name flex">
<span>def <span class="ident">scroll_relative</span></span>(<span>self, x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll relative to current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt>x (int | None, optional): X distance (columns) to scroll, or <code>None</code> for no change. Defaults to None.</dt>
<dt>y (int | None, optional): Y distance (rows) to scroll, or <code>None</code> for no change. Defaults to None.</dt>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Animate to new scroll position. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the scroll position changed, otherwise False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_relative(
    self,
    x: float | None = None,
    y: float | None = None,
    *,
    animate: bool = True,
    speed: float | None = None,
    duration: float | None = None,
) -&gt; bool:
    &#34;&#34;&#34;Scroll relative to current position.

    Args:
        x (int | None, optional): X distance (columns) to scroll, or ``None`` for no change. Defaults to None.
        y (int | None, optional): Y distance (rows) to scroll, or ``None`` for no change. Defaults to None.
        animate (bool, optional): Animate to new scroll position. Defaults to False.

    Returns:
        bool: True if the scroll position changed, otherwise False.
    &#34;&#34;&#34;
    return self.scroll_to(
        None if x is None else (self.scroll_x + x),
        None if y is None else (self.scroll_y + y),
        animate=animate,
        speed=speed,
        duration=duration,
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_right"><code class="name flex">
<span>def <span class="ident">scroll_right</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_right(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(x=self.scroll_target_x + 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_to"><code class="name flex">
<span>def <span class="ident">scroll_to</span></span>(<span>self, x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to a given (absolute) coordinate, optionally animating.</p>
<h2 id="args">Args</h2>
<dl>
<dt>x (int | None, optional): X coordinate (column) to scroll to, or <code>None</code> for no change. Defaults to None.</dt>
<dt>y (int | None, optional): Y coordinate (row) to scroll to, or <code>None</code> for no change. Defaults to None.</dt>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Animate to new scroll position. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the scroll position changed, otherwise False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_to(
    self,
    x: float | None = None,
    y: float | None = None,
    *,
    animate: bool = True,
    speed: float | None = None,
    duration: float | None = None,
) -&gt; bool:
    &#34;&#34;&#34;Scroll to a given (absolute) coordinate, optionally animating.

    Args:
        x (int | None, optional): X coordinate (column) to scroll to, or ``None`` for no change. Defaults to None.
        y (int | None, optional): Y coordinate (row) to scroll to, or ``None`` for no change. Defaults to None.
        animate (bool, optional): Animate to new scroll position. Defaults to False.

    Returns:
        bool: True if the scroll position changed, otherwise False.
    &#34;&#34;&#34;
    scrolled_x = scrolled_y = False

    if animate:
        # TODO: configure animation speed
        if x is not None:
            self.scroll_target_x = x
            if x != self.scroll_x:
                self.animate(
                    &#34;scroll_x&#34;,
                    self.scroll_target_x,
                    speed=speed,
                    duration=duration,
                    easing=&#34;out_cubic&#34;,
                )
                scrolled_x = True
        if y is not None:
            self.scroll_target_y = y
            if y != self.scroll_y:
                self.animate(
                    &#34;scroll_y&#34;,
                    self.scroll_target_y,
                    speed=speed,
                    duration=duration,
                    easing=&#34;out_cubic&#34;,
                )
                scrolled_y = True

    else:
        if x is not None:
            scroll_x = self.scroll_x
            self.scroll_target_x = self.scroll_x = x
            scrolled_x = scroll_x != self.scroll_x
        if y is not None:
            scroll_y = self.scroll_y
            self.scroll_target_y = self.scroll_y = y
            scrolled_y = scroll_y != self.scroll_y
        if scrolled_x or scrolled_y:
            self.refresh(repaint=False, layout=True)

    return scrolled_x or scrolled_y</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_to_widget"><code class="name flex">
<span>def <span class="ident">scroll_to_widget</span></span>(<span>self, widget: <a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a>, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll so that a child widget is in the visible area.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widget</code></strong> :&ensp;<code><a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a></code></dt>
<dd>A Widget in the children.</dd>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to animate, or False to jump. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the scroll position changed, otherwise False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_to_widget(self, widget: Widget, *, animate: bool = True) -&gt; bool:
    &#34;&#34;&#34;Scroll so that a child widget is in the visible area.

    Args:
        widget (Widget): A Widget in the children.
        animate (bool, optional): True to animate, or False to jump. Defaults to True.

    Returns:
        bool: True if the scroll position changed, otherwise False.
    &#34;&#34;&#34;

    try:
        widget_region = widget.content_region
        container_region = self.content_region
    except errors.NoWidget:
        return False

    if widget_region in container_region:
        # Widget is visible, nothing to do
        return False

    # We can either scroll so the widget is at the top of the container, or so that
    # it is at the bottom. We want to pick which has the shortest distance
    top_delta = widget_region.origin - container_region.origin

    bottom_delta = widget_region.origin - (
        container_region.origin
        + Offset(0, container_region.height - widget_region.height)
    )

    if widget_region.width &gt; container_region.width:
        delta_x = top_delta.x
    else:
        delta_x = min(top_delta.x, bottom_delta.x, key=abs)

    if widget_region.height &gt; container_region.height:
        delta_y = top_delta.y
    else:
        delta_y = min(top_delta.y, bottom_delta.y, key=abs)

    return self.scroll_relative(
        delta_x or None, delta_y or None, animate=animate, duration=0.2
    )</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.scroll_up"><code class="name flex">
<span>def <span class="ident">scroll_up</span></span>(<span>self, *, animate: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_up(self, *, animate: bool = True) -&gt; bool:
    return self.scroll_to(y=self.scroll_target_y + 1, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.set_dirty"><code class="name flex">
<span>def <span class="ident">set_dirty</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the Widget as 'dirty' (requiring re-render).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dirty(self) -&gt; None:
    &#34;&#34;&#34;Set the Widget as &#39;dirty&#39; (requiring re-render).&#34;&#34;&#34;
    self._dirty_regions.clear()
    self._dirty_regions.append(self.size.region)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.size_updated"><code class="name flex">
<span>def <span class="ident">size_updated</span></span>(<span>self, size: Size, virtual_size: Size, container_size: Size) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_updated(
    self, size: Size, virtual_size: Size, container_size: Size
) -&gt; None:
    if self._size != size or self._virtual_size != virtual_size:
        self._size = size
        self._virtual_size = virtual_size
        self._container_size = container_size

        if self.is_container:
            self._refresh_scrollbars()
            width, height = self.container_size
            if self.show_vertical_scrollbar:
                self.vertical_scrollbar.window_virtual_size = virtual_size.height
                self.vertical_scrollbar.window_size = height
            if self.show_horizontal_scrollbar:
                self.horizontal_scrollbar.window_virtual_size = virtual_size.width
                self.horizontal_scrollbar.window_size = width

            self.scroll_x = self.validate_scroll_x(self.scroll_x)
            self.scroll_y = self.validate_scroll_y(self.scroll_y)
            self.refresh(layout=True)
            self.call_later(self.scroll_to, self.scroll_x, self.scroll_y)
        else:
            self.refresh()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_target_x"><code class="name flex">
<span>def <span class="ident">validate_scroll_target_x</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_target_x(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_x)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_target_y"><code class="name flex">
<span>def <span class="ident">validate_scroll_target_y</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_target_y(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_x"><code class="name flex">
<span>def <span class="ident">validate_scroll_x</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_x(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_x)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.validate_scroll_y"><code class="name flex">
<span>def <span class="ident">validate_scroll_y</span></span>(<span>self, value: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_scroll_y(self, value: float) -&gt; float:
    return clamp(value, 0, self.max_scroll_y)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch"><code class="name flex">
<span>def <span class="ident">watch</span></span>(<span>self, attribute_name, callback: Callable[[Any], Awaitable[None]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch(self, attribute_name, callback: Callable[[Any], Awaitable[None]]) -&gt; None:
    watch(self, attribute_name, callback)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_has_focus"><code class="name flex">
<span>def <span class="ident">watch_has_focus</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update from CSS if has focus state changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_has_focus(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Update from CSS if has focus state changes.&#34;&#34;&#34;
    self.app.update_styles()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_mouse_over"><code class="name flex">
<span>def <span class="ident">watch_mouse_over</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update from CSS if mouse over state changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_mouse_over(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Update from CSS if mouse over state changes.&#34;&#34;&#34;
    self.app.update_styles()</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_scroll_x"><code class="name flex">
<span>async def <span class="ident">watch_scroll_x</span></span>(<span>self, new_value: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def watch_scroll_x(self, new_value: float) -&gt; None:
    self.horizontal_scrollbar.position = int(new_value)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_scroll_y"><code class="name flex">
<span>async def <span class="ident">watch_scroll_y</span></span>(<span>self, new_value: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def watch_scroll_y(self, new_value: float) -&gt; None:
    self.vertical_scrollbar.position = int(new_value)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_show_horizontal_scrollbar"><code class="name flex">
<span>def <span class="ident">watch_show_horizontal_scrollbar</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Watch function for show_horizontal_scrollbar attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Show horizontal scrollbar flag.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_show_horizontal_scrollbar(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Watch function for show_horizontal_scrollbar attribute.

    Args:
        value (bool): Show horizontal scrollbar flag.
    &#34;&#34;&#34;
    if not value:
        # reset the scroll position if the scrollbar is hidden.
        self.scroll_to(0, 0, animate=False)</code></pre>
</details>
</dd>
<dt id="textual.widget.Widget.watch_show_vertical_scrollbar"><code class="name flex">
<span>def <span class="ident">watch_show_vertical_scrollbar</span></span>(<span>self, value: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Watch function for show_vertical_scrollbar attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Show vertical scrollbar flag.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch_show_vertical_scrollbar(self, value: bool) -&gt; None:
    &#34;&#34;&#34;Watch function for show_vertical_scrollbar attribute.

    Args:
        value (bool): Show vertical scrollbar flag.
    &#34;&#34;&#34;
    if not value:
        # reset the scroll position if the scrollbar is hidden.
        self.scroll_to(0, 0, animate=False)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="textual.dom.DOMNode" href="dom.html#textual.dom.DOMNode">DOMNode</a></b></code>:
<ul class="hlist">
<li><code><a title="textual.dom.DOMNode.add_child" href="dom.html#textual.dom.DOMNode.add_child">add_child</a></code></li>
<li><code><a title="textual.dom.DOMNode.add_children" href="dom.html#textual.dom.DOMNode.add_children">add_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.add_class" href="dom.html#textual.dom.DOMNode.add_class">add_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.ancestors" href="dom.html#textual.dom.DOMNode.ancestors">ancestors</a></code></li>
<li><code><a title="textual.dom.DOMNode.app" href="message_pump.html#textual.message_pump.MessagePump.app">app</a></code></li>
<li><code><a title="textual.dom.DOMNode.call_later" href="message_pump.html#textual.message_pump.MessagePump.call_later">call_later</a></code></li>
<li><code><a title="textual.dom.DOMNode.check_idle" href="message_pump.html#textual.message_pump.MessagePump.check_idle">check_idle</a></code></li>
<li><code><a title="textual.dom.DOMNode.close_messages" href="message_pump.html#textual.message_pump.MessagePump.close_messages">close_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.close_messages_no_wait" href="message_pump.html#textual.message_pump.MessagePump.close_messages_no_wait">close_messages_no_wait</a></code></li>
<li><code><a title="textual.dom.DOMNode.colors" href="dom.html#textual.dom.DOMNode.colors">colors</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier" href="dom.html#textual.dom.DOMNode.css_identifier">css_identifier</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_identifier_styled" href="dom.html#textual.dom.DOMNode.css_identifier_styled">css_identifier_styled</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_path_nodes" href="dom.html#textual.dom.DOMNode.css_path_nodes">css_path_nodes</a></code></li>
<li><code><a title="textual.dom.DOMNode.css_type" href="dom.html#textual.dom.DOMNode.css_type">css_type</a></code></li>
<li><code><a title="textual.dom.DOMNode.disable_messages" href="message_pump.html#textual.message_pump.MessagePump.disable_messages">disable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.dispatch_key" href="message_pump.html#textual.message_pump.MessagePump.dispatch_key">dispatch_key</a></code></li>
<li><code><a title="textual.dom.DOMNode.display" href="dom.html#textual.dom.DOMNode.display">display</a></code></li>
<li><code><a title="textual.dom.DOMNode.displayed_children" href="dom.html#textual.dom.DOMNode.displayed_children">displayed_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.enable_messages" href="message_pump.html#textual.message_pump.MessagePump.enable_messages">enable_messages</a></code></li>
<li><code><a title="textual.dom.DOMNode.focusable_children" href="dom.html#textual.dom.DOMNode.focusable_children">focusable_children</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_child" href="dom.html#textual.dom.DOMNode.get_child">get_child</a></code></li>
<li><code><a title="textual.dom.DOMNode.get_message" href="message_pump.html#textual.message_pump.MessagePump.get_message">get_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_class" href="dom.html#textual.dom.DOMNode.has_class">has_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.has_pseudo_class" href="dom.html#textual.dom.DOMNode.has_pseudo_class">has_pseudo_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.id" href="dom.html#textual.dom.DOMNode.id">id</a></code></li>
<li><code><a title="textual.dom.DOMNode.parent" href="dom.html#textual.dom.DOMNode.parent">parent</a></code></li>
<li><code><a title="textual.dom.DOMNode.peek_message" href="message_pump.html#textual.message_pump.MessagePump.peek_message">peek_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.post_priority_message" href="message_pump.html#textual.message_pump.MessagePump.post_priority_message">post_priority_message</a></code></li>
<li><code><a title="textual.dom.DOMNode.pseudo_classes" href="dom.html#textual.dom.DOMNode.pseudo_classes">pseudo_classes</a></code></li>
<li><code><a title="textual.dom.DOMNode.query" href="dom.html#textual.dom.DOMNode.query">query</a></code></li>
<li><code><a title="textual.dom.DOMNode.remove_class" href="dom.html#textual.dom.DOMNode.remove_class">remove_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.screen" href="dom.html#textual.dom.DOMNode.screen">screen</a></code></li>
<li><code><a title="textual.dom.DOMNode.set_styles" href="dom.html#textual.dom.DOMNode.set_styles">set_styles</a></code></li>
<li><code><a title="textual.dom.DOMNode.text_style" href="dom.html#textual.dom.DOMNode.text_style">text_style</a></code></li>
<li><code><a title="textual.dom.DOMNode.toggle_class" href="dom.html#textual.dom.DOMNode.toggle_class">toggle_class</a></code></li>
<li><code><a title="textual.dom.DOMNode.tree" href="dom.html#textual.dom.DOMNode.tree">tree</a></code></li>
<li><code><a title="textual.dom.DOMNode.walk_children" href="dom.html#textual.dom.DOMNode.walk_children">walk_children</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual" href="index.html">textual</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.widget.RenderCache" href="#textual.widget.RenderCache">RenderCache</a></code></h4>
<ul class="">
<li><code><a title="textual.widget.RenderCache.cursor_line" href="#textual.widget.RenderCache.cursor_line">cursor_line</a></code></li>
<li><code><a title="textual.widget.RenderCache.lines" href="#textual.widget.RenderCache.lines">lines</a></code></li>
<li><code><a title="textual.widget.RenderCache.size" href="#textual.widget.RenderCache.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.widget.Widget" href="#textual.widget.Widget">Widget</a></code></h4>
<ul class="">
<li><code><a title="textual.widget.Widget.CSS" href="#textual.widget.Widget.CSS">CSS</a></code></li>
<li><code><a title="textual.widget.Widget.action" href="#textual.widget.Widget.action">action</a></code></li>
<li><code><a title="textual.widget.Widget.animate" href="#textual.widget.Widget.animate">animate</a></code></li>
<li><code><a title="textual.widget.Widget.auto_height" href="#textual.widget.Widget.auto_height">auto_height</a></code></li>
<li><code><a title="textual.widget.Widget.auto_width" href="#textual.widget.Widget.auto_width">auto_width</a></code></li>
<li><code><a title="textual.widget.Widget.broker_event" href="#textual.widget.Widget.broker_event">broker_event</a></code></li>
<li><code><a title="textual.widget.Widget.can_focus" href="#textual.widget.Widget.can_focus">can_focus</a></code></li>
<li><code><a title="textual.widget.Widget.can_focus_children" href="#textual.widget.Widget.can_focus_children">can_focus_children</a></code></li>
<li><code><a title="textual.widget.Widget.capture_mouse" href="#textual.widget.Widget.capture_mouse">capture_mouse</a></code></li>
<li><code><a title="textual.widget.Widget.check_layout" href="#textual.widget.Widget.check_layout">check_layout</a></code></li>
<li><code><a title="textual.widget.Widget.compose" href="#textual.widget.Widget.compose">compose</a></code></li>
<li><code><a title="textual.widget.Widget.console" href="#textual.widget.Widget.console">console</a></code></li>
<li><code><a title="textual.widget.Widget.container_size" href="#textual.widget.Widget.container_size">container_size</a></code></li>
<li><code><a title="textual.widget.Widget.content_offset" href="#textual.widget.Widget.content_offset">content_offset</a></code></li>
<li><code><a title="textual.widget.Widget.content_region" href="#textual.widget.Widget.content_region">content_region</a></code></li>
<li><code><a title="textual.widget.Widget.descendant_has_focus" href="#textual.widget.Widget.descendant_has_focus">descendant_has_focus</a></code></li>
<li><code><a title="textual.widget.Widget.focus" href="#textual.widget.Widget.focus">focus</a></code></li>
<li><code><a title="textual.widget.Widget.forward_event" href="#textual.widget.Widget.forward_event">forward_event</a></code></li>
<li><code><a title="textual.widget.Widget.get_box_model" href="#textual.widget.Widget.get_box_model">get_box_model</a></code></li>
<li><code><a title="textual.widget.Widget.get_content_height" href="#textual.widget.Widget.get_content_height">get_content_height</a></code></li>
<li><code><a title="textual.widget.Widget.get_content_width" href="#textual.widget.Widget.get_content_width">get_content_width</a></code></li>
<li><code><a title="textual.widget.Widget.get_pseudo_classes" href="#textual.widget.Widget.get_pseudo_classes">get_pseudo_classes</a></code></li>
<li><code><a title="textual.widget.Widget.get_render_lines" href="#textual.widget.Widget.get_render_lines">get_render_lines</a></code></li>
<li><code><a title="textual.widget.Widget.get_style_at" href="#textual.widget.Widget.get_style_at">get_style_at</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_down" href="#textual.widget.Widget.handle_scroll_down">handle_scroll_down</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_left" href="#textual.widget.Widget.handle_scroll_left">handle_scroll_left</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_right" href="#textual.widget.Widget.handle_scroll_right">handle_scroll_right</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_to" href="#textual.widget.Widget.handle_scroll_to">handle_scroll_to</a></code></li>
<li><code><a title="textual.widget.Widget.handle_scroll_up" href="#textual.widget.Widget.handle_scroll_up">handle_scroll_up</a></code></li>
<li><code><a title="textual.widget.Widget.has_focus" href="#textual.widget.Widget.has_focus">has_focus</a></code></li>
<li><code><a title="textual.widget.Widget.horizontal_scrollbar" href="#textual.widget.Widget.horizontal_scrollbar">horizontal_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.is_container" href="#textual.widget.Widget.is_container">is_container</a></code></li>
<li><code><a title="textual.widget.Widget.is_transparent" href="#textual.widget.Widget.is_transparent">is_transparent</a></code></li>
<li><code><a title="textual.widget.Widget.key_down" href="#textual.widget.Widget.key_down">key_down</a></code></li>
<li><code><a title="textual.widget.Widget.key_end" href="#textual.widget.Widget.key_end">key_end</a></code></li>
<li><code><a title="textual.widget.Widget.key_home" href="#textual.widget.Widget.key_home">key_home</a></code></li>
<li><code><a title="textual.widget.Widget.key_left" href="#textual.widget.Widget.key_left">key_left</a></code></li>
<li><code><a title="textual.widget.Widget.key_pagedown" href="#textual.widget.Widget.key_pagedown">key_pagedown</a></code></li>
<li><code><a title="textual.widget.Widget.key_pageup" href="#textual.widget.Widget.key_pageup">key_pageup</a></code></li>
<li><code><a title="textual.widget.Widget.key_right" href="#textual.widget.Widget.key_right">key_right</a></code></li>
<li><code><a title="textual.widget.Widget.key_up" href="#textual.widget.Widget.key_up">key_up</a></code></li>
<li><code><a title="textual.widget.Widget.layout" href="#textual.widget.Widget.layout">layout</a></code></li>
<li><code><a title="textual.widget.Widget.max_scroll_x" href="#textual.widget.Widget.max_scroll_x">max_scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.max_scroll_y" href="#textual.widget.Widget.max_scroll_y">max_scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.mount" href="#textual.widget.Widget.mount">mount</a></code></li>
<li><code><a title="textual.widget.Widget.mouse_over" href="#textual.widget.Widget.mouse_over">mouse_over</a></code></li>
<li><code><a title="textual.widget.Widget.on_blur" href="#textual.widget.Widget.on_blur">on_blur</a></code></li>
<li><code><a title="textual.widget.Widget.on_click" href="#textual.widget.Widget.on_click">on_click</a></code></li>
<li><code><a title="textual.widget.Widget.on_descendant_blur" href="#textual.widget.Widget.on_descendant_blur">on_descendant_blur</a></code></li>
<li><code><a title="textual.widget.Widget.on_descendant_focus" href="#textual.widget.Widget.on_descendant_focus">on_descendant_focus</a></code></li>
<li><code><a title="textual.widget.Widget.on_enter" href="#textual.widget.Widget.on_enter">on_enter</a></code></li>
<li><code><a title="textual.widget.Widget.on_focus" href="#textual.widget.Widget.on_focus">on_focus</a></code></li>
<li><code><a title="textual.widget.Widget.on_idle" href="#textual.widget.Widget.on_idle">on_idle</a></code></li>
<li><code><a title="textual.widget.Widget.on_key" href="#textual.widget.Widget.on_key">on_key</a></code></li>
<li><code><a title="textual.widget.Widget.on_leave" href="#textual.widget.Widget.on_leave">on_leave</a></code></li>
<li><code><a title="textual.widget.Widget.on_mount" href="#textual.widget.Widget.on_mount">on_mount</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_down" href="#textual.widget.Widget.on_mouse_down">on_mouse_down</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_scroll_down" href="#textual.widget.Widget.on_mouse_scroll_down">on_mouse_scroll_down</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_scroll_up" href="#textual.widget.Widget.on_mouse_scroll_up">on_mouse_scroll_up</a></code></li>
<li><code><a title="textual.widget.Widget.on_mouse_up" href="#textual.widget.Widget.on_mouse_up">on_mouse_up</a></code></li>
<li><code><a title="textual.widget.Widget.on_register" href="#textual.widget.Widget.on_register">on_register</a></code></li>
<li><code><a title="textual.widget.Widget.on_style_change" href="#textual.widget.Widget.on_style_change">on_style_change</a></code></li>
<li><code><a title="textual.widget.Widget.post_message" href="#textual.widget.Widget.post_message">post_message</a></code></li>
<li><code><a title="textual.widget.Widget.refresh" href="#textual.widget.Widget.refresh">refresh</a></code></li>
<li><code><a title="textual.widget.Widget.region" href="#textual.widget.Widget.region">region</a></code></li>
<li><code><a title="textual.widget.Widget.release_mouse" href="#textual.widget.Widget.release_mouse">release_mouse</a></code></li>
<li><code><a title="textual.widget.Widget.render" href="#textual.widget.Widget.render">render</a></code></li>
<li><code><a title="textual.widget.Widget.render_styled" href="#textual.widget.Widget.render_styled">render_styled</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_down" href="#textual.widget.Widget.scroll_down">scroll_down</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_end" href="#textual.widget.Widget.scroll_end">scroll_end</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_home" href="#textual.widget.Widget.scroll_home">scroll_home</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_left" href="#textual.widget.Widget.scroll_left">scroll_left</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_offset" href="#textual.widget.Widget.scroll_offset">scroll_offset</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_down" href="#textual.widget.Widget.scroll_page_down">scroll_page_down</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_left" href="#textual.widget.Widget.scroll_page_left">scroll_page_left</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_right" href="#textual.widget.Widget.scroll_page_right">scroll_page_right</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_page_up" href="#textual.widget.Widget.scroll_page_up">scroll_page_up</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_relative" href="#textual.widget.Widget.scroll_relative">scroll_relative</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_right" href="#textual.widget.Widget.scroll_right">scroll_right</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_target_x" href="#textual.widget.Widget.scroll_target_x">scroll_target_x</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_target_y" href="#textual.widget.Widget.scroll_target_y">scroll_target_y</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_to" href="#textual.widget.Widget.scroll_to">scroll_to</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_to_widget" href="#textual.widget.Widget.scroll_to_widget">scroll_to_widget</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_up" href="#textual.widget.Widget.scroll_up">scroll_up</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_x" href="#textual.widget.Widget.scroll_x">scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.scroll_y" href="#textual.widget.Widget.scroll_y">scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.scrollbars_enabled" href="#textual.widget.Widget.scrollbars_enabled">scrollbars_enabled</a></code></li>
<li><code><a title="textual.widget.Widget.set_dirty" href="#textual.widget.Widget.set_dirty">set_dirty</a></code></li>
<li><code><a title="textual.widget.Widget.show_horizontal_scrollbar" href="#textual.widget.Widget.show_horizontal_scrollbar">show_horizontal_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.show_vertical_scrollbar" href="#textual.widget.Widget.show_vertical_scrollbar">show_vertical_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.size" href="#textual.widget.Widget.size">size</a></code></li>
<li><code><a title="textual.widget.Widget.size_updated" href="#textual.widget.Widget.size_updated">size_updated</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_target_x" href="#textual.widget.Widget.validate_scroll_target_x">validate_scroll_target_x</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_target_y" href="#textual.widget.Widget.validate_scroll_target_y">validate_scroll_target_y</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_x" href="#textual.widget.Widget.validate_scroll_x">validate_scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.validate_scroll_y" href="#textual.widget.Widget.validate_scroll_y">validate_scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.vertical_scrollbar" href="#textual.widget.Widget.vertical_scrollbar">vertical_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.virtual_size" href="#textual.widget.Widget.virtual_size">virtual_size</a></code></li>
<li><code><a title="textual.widget.Widget.watch" href="#textual.widget.Widget.watch">watch</a></code></li>
<li><code><a title="textual.widget.Widget.watch_has_focus" href="#textual.widget.Widget.watch_has_focus">watch_has_focus</a></code></li>
<li><code><a title="textual.widget.Widget.watch_mouse_over" href="#textual.widget.Widget.watch_mouse_over">watch_mouse_over</a></code></li>
<li><code><a title="textual.widget.Widget.watch_scroll_x" href="#textual.widget.Widget.watch_scroll_x">watch_scroll_x</a></code></li>
<li><code><a title="textual.widget.Widget.watch_scroll_y" href="#textual.widget.Widget.watch_scroll_y">watch_scroll_y</a></code></li>
<li><code><a title="textual.widget.Widget.watch_show_horizontal_scrollbar" href="#textual.widget.Widget.watch_show_horizontal_scrollbar">watch_show_horizontal_scrollbar</a></code></li>
<li><code><a title="textual.widget.Widget.watch_show_vertical_scrollbar" href="#textual.widget.Widget.watch_show_vertical_scrollbar">watch_show_vertical_scrollbar</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>