<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.css.parse API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.css.parse</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

from functools import lru_cache
from typing import Iterator, Iterable

from rich import print

from textual.css.errors import UnresolvedVariableError
from ._styles_builder import StylesBuilder, DeclarationError
from .model import (
    Declaration,
    RuleSet,
    Selector,
    CombinatorType,
    SelectorSet,
    SelectorType,
)
from .styles import Styles
from .tokenize import tokenize, tokenize_declarations, Token, tokenize_values
from .tokenizer import EOFError, ReferencedBy

SELECTOR_MAP: dict[str, tuple[SelectorType, tuple[int, int, int]]] = {
    &#34;selector&#34;: (SelectorType.TYPE, (0, 0, 1)),
    &#34;selector_start&#34;: (SelectorType.TYPE, (0, 0, 1)),
    &#34;selector_class&#34;: (SelectorType.CLASS, (0, 1, 0)),
    &#34;selector_start_class&#34;: (SelectorType.CLASS, (0, 1, 0)),
    &#34;selector_id&#34;: (SelectorType.ID, (1, 0, 0)),
    &#34;selector_start_id&#34;: (SelectorType.ID, (1, 0, 0)),
    &#34;selector_universal&#34;: (SelectorType.UNIVERSAL, (0, 0, 0)),
    &#34;selector_start_universal&#34;: (SelectorType.UNIVERSAL, (0, 0, 0)),
}


@lru_cache(maxsize=1024)
def parse_selectors(css_selectors: str) -&gt; tuple[SelectorSet, ...]:
    tokens = iter(tokenize(css_selectors, &#34;&#34;))

    get_selector = SELECTOR_MAP.get
    combinator: CombinatorType | None = CombinatorType.DESCENDENT
    selectors: list[Selector] = []
    rule_selectors: list[list[Selector]] = []

    while True:
        try:
            token = next(tokens)
        except EOFError:
            break
        if token.name == &#34;pseudo_class&#34;:
            selectors[-1]._add_pseudo_class(token.value.lstrip(&#34;:&#34;))
        elif token.name == &#34;whitespace&#34;:
            if combinator is None or combinator == CombinatorType.SAME:
                combinator = CombinatorType.DESCENDENT
        elif token.name == &#34;new_selector&#34;:
            rule_selectors.append(selectors[:])
            selectors.clear()
            combinator = None
        elif token.name == &#34;declaration_set_start&#34;:
            break
        elif token.name == &#34;combinator_child&#34;:
            combinator = CombinatorType.CHILD
        else:
            _selector, specificity = get_selector(
                token.name, (SelectorType.TYPE, (0, 0, 0))
            )
            selectors.append(
                Selector(
                    name=token.value.lstrip(&#34;.#&#34;),
                    combinator=combinator or CombinatorType.DESCENDENT,
                    type=_selector,
                    specificity=specificity,
                )
            )
            combinator = CombinatorType.SAME
    if selectors:
        rule_selectors.append(selectors[:])

    selector_set = tuple(SelectorSet.from_selectors(rule_selectors))
    return selector_set


def parse_rule_set(tokens: Iterator[Token], token: Token) -&gt; Iterable[RuleSet]:
    get_selector = SELECTOR_MAP.get
    combinator: CombinatorType | None = CombinatorType.DESCENDENT
    selectors: list[Selector] = []
    rule_selectors: list[list[Selector]] = []
    styles_builder = StylesBuilder()

    while True:
        if token.name == &#34;pseudo_class&#34;:
            selectors[-1]._add_pseudo_class(token.value.lstrip(&#34;:&#34;))
        elif token.name == &#34;whitespace&#34;:
            if combinator is None or combinator == CombinatorType.SAME:
                combinator = CombinatorType.DESCENDENT
        elif token.name == &#34;new_selector&#34;:
            rule_selectors.append(selectors[:])
            selectors.clear()
            combinator = None
        elif token.name == &#34;declaration_set_start&#34;:
            break
        elif token.name == &#34;combinator_child&#34;:
            combinator = CombinatorType.CHILD
        else:
            _selector, specificity = get_selector(
                token.name, (SelectorType.TYPE, (0, 0, 0))
            )
            selectors.append(
                Selector(
                    name=token.value.lstrip(&#34;.#&#34;),
                    combinator=combinator or CombinatorType.DESCENDENT,
                    type=_selector,
                    specificity=specificity,
                )
            )
            combinator = CombinatorType.SAME

        token = next(tokens)

    if selectors:
        rule_selectors.append(selectors[:])

    declaration = Declaration(token, &#34;&#34;)

    errors: list[tuple[Token, str]] = []

    while True:
        token = next(tokens)
        token_name = token.name
        if token_name in (&#34;whitespace&#34;, &#34;declaration_end&#34;):
            continue
        if token_name == &#34;declaration_name&#34;:
            if declaration.tokens:
                try:
                    styles_builder.add_declaration(declaration)
                except DeclarationError as error:
                    errors.append((error.token, error.message))
            declaration = Declaration(token, &#34;&#34;)
            declaration.name = token.value.rstrip(&#34;:&#34;)
        elif token_name == &#34;declaration_set_end&#34;:
            break
        else:
            declaration.tokens.append(token)

    if declaration.tokens:
        try:
            styles_builder.add_declaration(declaration)
        except DeclarationError as error:
            errors.append((error.token, error.message))

    rule_set = RuleSet(
        list(SelectorSet.from_selectors(rule_selectors)), styles_builder.styles, errors
    )
    rule_set._post_parse()
    yield rule_set


def parse_declarations(css: str, path: str) -&gt; Styles:
    &#34;&#34;&#34;Parse declarations and return a Styles object.

    Args:
        css (str): String containing CSS.
        path (str): Path to the CSS, or something else to identify the location.

    Returns:
        Styles: A styles object.
    &#34;&#34;&#34;

    tokens = iter(tokenize_declarations(css, path))
    styles_builder = StylesBuilder()

    declaration: Declaration | None = None
    errors: list[tuple[Token, str]] = []

    while True:
        token = next(tokens, None)
        if token is None:
            break
        token_name = token.name
        if token_name in (&#34;whitespace&#34;, &#34;declaration_end&#34;, &#34;eof&#34;):
            continue
        if token_name == &#34;declaration_name&#34;:
            if declaration and declaration.tokens:
                try:
                    styles_builder.add_declaration(declaration)
                except DeclarationError as error:
                    errors.append((error.token, error.message))
                    raise
            declaration = Declaration(token, &#34;&#34;)
            declaration.name = token.value.rstrip(&#34;:&#34;)
        elif token_name == &#34;declaration_set_end&#34;:
            break
        else:
            if declaration:
                declaration.tokens.append(token)

    if declaration and declaration.tokens:
        try:
            styles_builder.add_declaration(declaration)
        except DeclarationError as error:
            errors.append((error.token, error.message))
            raise

    return styles_builder.styles


def _unresolved(
    variable_name: str, location: tuple[int, int]
) -&gt; UnresolvedVariableError:
    line_idx, col_idx = location
    return UnresolvedVariableError(
        f&#34;reference to undefined variable &#39;${variable_name}&#39; at line {line_idx + 1}, column {col_idx + 1}.&#34;
    )


def substitute_references(
    tokens: Iterable[Token], css_variables: dict[str, list[Token]] | None = None
) -&gt; Iterable[Token]:
    &#34;&#34;&#34;Replace variable references with values by substituting variable reference
    tokens with the tokens representing their values.

    Args:
        tokens (Iterable[Token]): Iterator of Tokens which may contain tokens
            with the name &#34;variable_ref&#34;.

    Returns:
        Iterable[Token]: Yields Tokens such that any variable references (tokens where
            token.name == &#34;variable_ref&#34;) have been replaced with the tokens representing
            the value. In other words, an Iterable of Tokens similar to the original input,
            but with variables resolved. Substituted tokens will have their referenced_by
            attribute populated with information about where the tokens are being substituted to.
    &#34;&#34;&#34;
    variables: dict[str, list[Token]] = css_variables.copy() if css_variables else {}

    iter_tokens = iter(tokens)

    while tokens:
        token = next(iter_tokens, None)
        if token is None:
            break
        if token.name == &#34;variable_name&#34;:
            variable_name = token.value[1:-1]  # Trim the $ and the :, i.e. &#34;$x:&#34; -&gt; &#34;x&#34;
            yield token

            while True:
                token = next(iter_tokens, None)
                # TODO: Mypy error looks legit
                if token.name == &#34;whitespace&#34;:
                    yield token
                else:
                    break

            # Store the tokens for any variable definitions, and substitute
            # any variable references we encounter with them.
            while True:
                if not token:
                    break
                elif token.name == &#34;whitespace&#34;:
                    variables.setdefault(variable_name, []).append(token)
                    yield token
                elif token.name == &#34;variable_value_end&#34;:
                    yield token
                    break
                # For variables referring to other variables
                elif token.name == &#34;variable_ref&#34;:
                    ref_name = token.value[1:]
                    if ref_name in variables:
                        variable_tokens = variables.setdefault(variable_name, [])
                        reference_tokens = variables[ref_name]
                        variable_tokens.extend(reference_tokens)
                        ref_location = token.location
                        ref_length = len(token.value)
                        for _token in reference_tokens:
                            yield _token.with_reference(
                                ReferencedBy(
                                    name=ref_name,
                                    location=ref_location,
                                    length=ref_length,
                                )
                            )
                    else:
                        raise _unresolved(
                            variable_name=ref_name, location=token.location
                        )
                else:
                    variables.setdefault(variable_name, []).append(token)
                    yield token
                token = next(iter_tokens, None)
        elif token.name == &#34;variable_ref&#34;:
            variable_name = token.value[1:]  # Trim the $, so $x -&gt; x
            if variable_name in variables:
                variable_tokens = variables[variable_name]
                ref_location = token.location
                ref_length = len(token.value)
                for token in variable_tokens:
                    yield token.with_reference(
                        ReferencedBy(
                            name=variable_name,
                            location=ref_location,
                            length=ref_length,
                        )
                    )
            else:
                raise _unresolved(variable_name=variable_name, location=token.location)
        else:
            yield token


def parse(
    css: str, path: str, variables: dict[str, str] | None = None
) -&gt; Iterable[RuleSet]:
    &#34;&#34;&#34;Parse CSS by tokenizing it, performing variable substitution,
    and generating rule sets from it.

    Args:
        css (str): The input CSS
        path (str): Path to the CSS
    &#34;&#34;&#34;
    variable_tokens = tokenize_values(variables or {})
    tokens = iter(substitute_references(tokenize(css, path), variable_tokens))
    while True:
        token = next(tokens, None)
        if token is None:
            break
        if token.name.startswith(&#34;selector_start&#34;):
            yield from parse_rule_set(tokens, token)


if __name__ == &#34;__main__&#34;:
    print(parse_selectors(&#34;Foo &gt; Bar.baz { foo: bar&#34;))

    css = &#34;&#34;&#34;#something {
    text: on red;
    transition: offset 5.51s in_out_cubic;
    offset-x: 100%;
}
&#34;&#34;&#34;

    from textual.css.stylesheet import Stylesheet, StylesheetParseError
    from rich.console import Console

    console = Console()
    stylesheet = Stylesheet()
    try:
        stylesheet.parse(css)
    except StylesheetParseError as e:
        console.print(e.errors)
    print(stylesheet)
    print(stylesheet.css)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="textual.css.parse.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>css: str, path: str, variables: dict[str, str] | None = None) ‑> Iterable[RuleSet]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse CSS by tokenizing it, performing variable substitution,
and generating rule sets from it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>css</code></strong> :&ensp;<code>str</code></dt>
<dd>The input CSS</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the CSS</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(
    css: str, path: str, variables: dict[str, str] | None = None
) -&gt; Iterable[RuleSet]:
    &#34;&#34;&#34;Parse CSS by tokenizing it, performing variable substitution,
    and generating rule sets from it.

    Args:
        css (str): The input CSS
        path (str): Path to the CSS
    &#34;&#34;&#34;
    variable_tokens = tokenize_values(variables or {})
    tokens = iter(substitute_references(tokenize(css, path), variable_tokens))
    while True:
        token = next(tokens, None)
        if token is None:
            break
        if token.name.startswith(&#34;selector_start&#34;):
            yield from parse_rule_set(tokens, token)</code></pre>
</details>
</dd>
<dt id="textual.css.parse.parse_declarations"><code class="name flex">
<span>def <span class="ident">parse_declarations</span></span>(<span>css: str, path: str) ‑> textual.css.styles.Styles</span>
</code></dt>
<dd>
<div class="desc"><p>Parse declarations and return a Styles object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>css</code></strong> :&ensp;<code>str</code></dt>
<dd>String containing CSS.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the CSS, or something else to identify the location.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Styles</code></dt>
<dd>A styles object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_declarations(css: str, path: str) -&gt; Styles:
    &#34;&#34;&#34;Parse declarations and return a Styles object.

    Args:
        css (str): String containing CSS.
        path (str): Path to the CSS, or something else to identify the location.

    Returns:
        Styles: A styles object.
    &#34;&#34;&#34;

    tokens = iter(tokenize_declarations(css, path))
    styles_builder = StylesBuilder()

    declaration: Declaration | None = None
    errors: list[tuple[Token, str]] = []

    while True:
        token = next(tokens, None)
        if token is None:
            break
        token_name = token.name
        if token_name in (&#34;whitespace&#34;, &#34;declaration_end&#34;, &#34;eof&#34;):
            continue
        if token_name == &#34;declaration_name&#34;:
            if declaration and declaration.tokens:
                try:
                    styles_builder.add_declaration(declaration)
                except DeclarationError as error:
                    errors.append((error.token, error.message))
                    raise
            declaration = Declaration(token, &#34;&#34;)
            declaration.name = token.value.rstrip(&#34;:&#34;)
        elif token_name == &#34;declaration_set_end&#34;:
            break
        else:
            if declaration:
                declaration.tokens.append(token)

    if declaration and declaration.tokens:
        try:
            styles_builder.add_declaration(declaration)
        except DeclarationError as error:
            errors.append((error.token, error.message))
            raise

    return styles_builder.styles</code></pre>
</details>
</dd>
<dt id="textual.css.parse.parse_rule_set"><code class="name flex">
<span>def <span class="ident">parse_rule_set</span></span>(<span>tokens: Iterator[Token], token: Token) ‑> Iterable[<a title="textual.css.model.RuleSet" href="model.html#textual.css.model.RuleSet">RuleSet</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_rule_set(tokens: Iterator[Token], token: Token) -&gt; Iterable[RuleSet]:
    get_selector = SELECTOR_MAP.get
    combinator: CombinatorType | None = CombinatorType.DESCENDENT
    selectors: list[Selector] = []
    rule_selectors: list[list[Selector]] = []
    styles_builder = StylesBuilder()

    while True:
        if token.name == &#34;pseudo_class&#34;:
            selectors[-1]._add_pseudo_class(token.value.lstrip(&#34;:&#34;))
        elif token.name == &#34;whitespace&#34;:
            if combinator is None or combinator == CombinatorType.SAME:
                combinator = CombinatorType.DESCENDENT
        elif token.name == &#34;new_selector&#34;:
            rule_selectors.append(selectors[:])
            selectors.clear()
            combinator = None
        elif token.name == &#34;declaration_set_start&#34;:
            break
        elif token.name == &#34;combinator_child&#34;:
            combinator = CombinatorType.CHILD
        else:
            _selector, specificity = get_selector(
                token.name, (SelectorType.TYPE, (0, 0, 0))
            )
            selectors.append(
                Selector(
                    name=token.value.lstrip(&#34;.#&#34;),
                    combinator=combinator or CombinatorType.DESCENDENT,
                    type=_selector,
                    specificity=specificity,
                )
            )
            combinator = CombinatorType.SAME

        token = next(tokens)

    if selectors:
        rule_selectors.append(selectors[:])

    declaration = Declaration(token, &#34;&#34;)

    errors: list[tuple[Token, str]] = []

    while True:
        token = next(tokens)
        token_name = token.name
        if token_name in (&#34;whitespace&#34;, &#34;declaration_end&#34;):
            continue
        if token_name == &#34;declaration_name&#34;:
            if declaration.tokens:
                try:
                    styles_builder.add_declaration(declaration)
                except DeclarationError as error:
                    errors.append((error.token, error.message))
            declaration = Declaration(token, &#34;&#34;)
            declaration.name = token.value.rstrip(&#34;:&#34;)
        elif token_name == &#34;declaration_set_end&#34;:
            break
        else:
            declaration.tokens.append(token)

    if declaration.tokens:
        try:
            styles_builder.add_declaration(declaration)
        except DeclarationError as error:
            errors.append((error.token, error.message))

    rule_set = RuleSet(
        list(SelectorSet.from_selectors(rule_selectors)), styles_builder.styles, errors
    )
    rule_set._post_parse()
    yield rule_set</code></pre>
</details>
</dd>
<dt id="textual.css.parse.parse_selectors"><code class="name flex">
<span>def <span class="ident">parse_selectors</span></span>(<span>css_selectors: str) ‑> tuple[SelectorSet, ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lru_cache(maxsize=1024)
def parse_selectors(css_selectors: str) -&gt; tuple[SelectorSet, ...]:
    tokens = iter(tokenize(css_selectors, &#34;&#34;))

    get_selector = SELECTOR_MAP.get
    combinator: CombinatorType | None = CombinatorType.DESCENDENT
    selectors: list[Selector] = []
    rule_selectors: list[list[Selector]] = []

    while True:
        try:
            token = next(tokens)
        except EOFError:
            break
        if token.name == &#34;pseudo_class&#34;:
            selectors[-1]._add_pseudo_class(token.value.lstrip(&#34;:&#34;))
        elif token.name == &#34;whitespace&#34;:
            if combinator is None or combinator == CombinatorType.SAME:
                combinator = CombinatorType.DESCENDENT
        elif token.name == &#34;new_selector&#34;:
            rule_selectors.append(selectors[:])
            selectors.clear()
            combinator = None
        elif token.name == &#34;declaration_set_start&#34;:
            break
        elif token.name == &#34;combinator_child&#34;:
            combinator = CombinatorType.CHILD
        else:
            _selector, specificity = get_selector(
                token.name, (SelectorType.TYPE, (0, 0, 0))
            )
            selectors.append(
                Selector(
                    name=token.value.lstrip(&#34;.#&#34;),
                    combinator=combinator or CombinatorType.DESCENDENT,
                    type=_selector,
                    specificity=specificity,
                )
            )
            combinator = CombinatorType.SAME
    if selectors:
        rule_selectors.append(selectors[:])

    selector_set = tuple(SelectorSet.from_selectors(rule_selectors))
    return selector_set</code></pre>
</details>
</dd>
<dt id="textual.css.parse.substitute_references"><code class="name flex">
<span>def <span class="ident">substitute_references</span></span>(<span>tokens: Iterable[Token], css_variables: dict[str, list[Token]] | None = None) ‑> Iterable[Token]</span>
</code></dt>
<dd>
<div class="desc"><p>Replace variable references with values by substituting variable reference
tokens with the tokens representing their values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tokens</code></strong> :&ensp;<code>Iterable[Token]</code></dt>
<dd>Iterator of Tokens which may contain tokens
with the name "variable_ref".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[Token]</code></dt>
<dd>Yields Tokens such that any variable references (tokens where
token.name == "variable_ref") have been replaced with the tokens representing
the value. In other words, an Iterable of Tokens similar to the original input,
but with variables resolved. Substituted tokens will have their referenced_by
attribute populated with information about where the tokens are being substituted to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def substitute_references(
    tokens: Iterable[Token], css_variables: dict[str, list[Token]] | None = None
) -&gt; Iterable[Token]:
    &#34;&#34;&#34;Replace variable references with values by substituting variable reference
    tokens with the tokens representing their values.

    Args:
        tokens (Iterable[Token]): Iterator of Tokens which may contain tokens
            with the name &#34;variable_ref&#34;.

    Returns:
        Iterable[Token]: Yields Tokens such that any variable references (tokens where
            token.name == &#34;variable_ref&#34;) have been replaced with the tokens representing
            the value. In other words, an Iterable of Tokens similar to the original input,
            but with variables resolved. Substituted tokens will have their referenced_by
            attribute populated with information about where the tokens are being substituted to.
    &#34;&#34;&#34;
    variables: dict[str, list[Token]] = css_variables.copy() if css_variables else {}

    iter_tokens = iter(tokens)

    while tokens:
        token = next(iter_tokens, None)
        if token is None:
            break
        if token.name == &#34;variable_name&#34;:
            variable_name = token.value[1:-1]  # Trim the $ and the :, i.e. &#34;$x:&#34; -&gt; &#34;x&#34;
            yield token

            while True:
                token = next(iter_tokens, None)
                # TODO: Mypy error looks legit
                if token.name == &#34;whitespace&#34;:
                    yield token
                else:
                    break

            # Store the tokens for any variable definitions, and substitute
            # any variable references we encounter with them.
            while True:
                if not token:
                    break
                elif token.name == &#34;whitespace&#34;:
                    variables.setdefault(variable_name, []).append(token)
                    yield token
                elif token.name == &#34;variable_value_end&#34;:
                    yield token
                    break
                # For variables referring to other variables
                elif token.name == &#34;variable_ref&#34;:
                    ref_name = token.value[1:]
                    if ref_name in variables:
                        variable_tokens = variables.setdefault(variable_name, [])
                        reference_tokens = variables[ref_name]
                        variable_tokens.extend(reference_tokens)
                        ref_location = token.location
                        ref_length = len(token.value)
                        for _token in reference_tokens:
                            yield _token.with_reference(
                                ReferencedBy(
                                    name=ref_name,
                                    location=ref_location,
                                    length=ref_length,
                                )
                            )
                    else:
                        raise _unresolved(
                            variable_name=ref_name, location=token.location
                        )
                else:
                    variables.setdefault(variable_name, []).append(token)
                    yield token
                token = next(iter_tokens, None)
        elif token.name == &#34;variable_ref&#34;:
            variable_name = token.value[1:]  # Trim the $, so $x -&gt; x
            if variable_name in variables:
                variable_tokens = variables[variable_name]
                ref_location = token.location
                ref_length = len(token.value)
                for token in variable_tokens:
                    yield token.with_reference(
                        ReferencedBy(
                            name=variable_name,
                            location=ref_location,
                            length=ref_length,
                        )
                    )
            else:
                raise _unresolved(variable_name=variable_name, location=token.location)
        else:
            yield token</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual.css" href="index.html">textual.css</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="textual.css.parse.parse" href="#textual.css.parse.parse">parse</a></code></li>
<li><code><a title="textual.css.parse.parse_declarations" href="#textual.css.parse.parse_declarations">parse_declarations</a></code></li>
<li><code><a title="textual.css.parse.parse_rule_set" href="#textual.css.parse.parse_rule_set">parse_rule_set</a></code></li>
<li><code><a title="textual.css.parse.parse_selectors" href="#textual.css.parse.parse_selectors">parse_selectors</a></code></li>
<li><code><a title="textual.css.parse.substitute_references" href="#textual.css.parse.substitute_references">substitute_references</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>