<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.css.stylesheet API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.css.stylesheet</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import os
from collections import defaultdict
from operator import itemgetter
from pathlib import Path, PurePath
from typing import cast, Iterable

import rich.repr
from rich.console import RenderableType, RenderResult, Console, ConsoleOptions
from rich.highlighter import ReprHighlighter
from rich.markup import render
from rich.padding import Padding
from rich.panel import Panel
from rich.rule import Rule
from rich.style import Style
from rich.syntax import Syntax
from rich.text import Text

from .._loop import loop_last
from .. import log
from .errors import StylesheetError
from .match import _check_selectors
from .model import RuleSet
from .parse import parse
from .styles import RulesMap
from .tokenize import tokenize_values, Token
from .tokenizer import TokenizeError
from .types import Specificity3, Specificity4
from ..dom import DOMNode


class StylesheetParseError(StylesheetError):
    def __init__(self, errors: StylesheetErrors) -&gt; None:
        self.errors = errors

    def __rich__(self) -&gt; RenderableType:
        return self.errors


class StylesheetErrors:
    def __init__(
        self, rules: list[RuleSet], variables: dict[str, str] | None = None
    ) -&gt; None:
        self.rules = rules
        self.variables: dict[str, str] = {}
        self._css_variables: dict[str, list[Token]] = {}
        if variables:
            self.set_variables(variables)

    @classmethod
    def _get_snippet(cls, code: str, line_no: int) -&gt; RenderableType:
        syntax = Syntax(
            code,
            lexer=&#34;scss&#34;,
            theme=&#34;ansi_light&#34;,
            line_numbers=True,
            indent_guides=True,
            line_range=(max(0, line_no - 2), line_no + 2),
            highlight_lines={line_no},
        )
        return syntax

    def set_variables(self, variable_map: dict[str, str]) -&gt; None:
        &#34;&#34;&#34;Pre-populate CSS variables.&#34;&#34;&#34;
        self.variables.update(variable_map)
        self._css_variables = tokenize_values(self.variables)

    def __rich_console__(
        self, console: Console, options: ConsoleOptions
    ) -&gt; RenderResult:
        error_count = 0
        for rule in self.rules:
            for token, message in rule.errors:
                error_count += 1

                if token.path:
                    path = Path(token.path)
                    filename = path.name
                else:
                    path = None
                    filename = &#34;&lt;unknown&gt;&#34;

                if token.referenced_by:
                    line_idx, col_idx = token.referenced_by.location
                    line_no, col_no = line_idx + 1, col_idx + 1
                    path_string = (
                        f&#34;{path.absolute() if path else filename}:{line_no}:{col_no}&#34;
                    )
                else:
                    line_idx, col_idx = token.location
                    line_no, col_no = line_idx + 1, col_idx + 1
                    path_string = (
                        f&#34;{path.absolute() if path else filename}:{line_no}:{col_no}&#34;
                    )

                link_style = Style(
                    link=f&#34;file://{path.absolute()}&#34;,
                    color=&#34;red&#34;,
                    bold=True,
                    italic=True,
                )

                path_text = Text(path_string, style=link_style)
                title = Text.assemble(Text(&#34;Error at &#34;, style=&#34;bold red&#34;), path_text)
                yield &#34;&#34;
                yield Panel(
                    self._get_snippet(token.code, line_no),
                    title=title,
                    title_align=&#34;left&#34;,
                    border_style=&#34;red&#34;,
                )
                yield Padding(message, pad=(0, 0, 1, 3))

        yield &#34;&#34;
        yield render(
            f&#34; [b][red]CSS parsing failed:[/] {error_count} error{&#39;s&#39; if error_count != 1 else &#39;&#39;}[/] found in stylesheet&#34;
        )


@rich.repr.auto
class Stylesheet:
    def __init__(self, *, variables: dict[str, str] | None = None) -&gt; None:
        self._rules: list[RuleSet] = []
        self.variables = variables or {}
        self.source: dict[str, str] = {}
        self._require_parse = False

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield self.rules

    @property
    def rules(self) -&gt; list[RuleSet]:
        if self._require_parse:
            self.parse()
            self._require_parse = False
        assert self._rules is not None
        return self._rules

    @property
    def css(self) -&gt; str:
        return &#34;\n\n&#34;.join(rule_set.css for rule_set in self.rules)

    def set_variables(self, variables: dict[str, str]) -&gt; None:
        &#34;&#34;&#34;Set CSS variables.

        Args:
            variables (dict[str, str]): A mapping of name to variable.
        &#34;&#34;&#34;
        self.variables = variables

    def _parse_rules(self, css: str, path: str | PurePath) -&gt; list[RuleSet]:
        &#34;&#34;&#34;Parse CSS and return rules.


        Args:
            css (str): String containing Textual CSS.
            path (str | PurePath): Path to CSS or unique identifier

        Raises:
            StylesheetError: If the CSS is invalid.

        Returns:
            list[RuleSet]: List of RuleSets.
        &#34;&#34;&#34;
        try:
            rules = list(parse(css, path, variables=self.variables))
        except TokenizeError:
            raise
        except Exception as error:
            raise StylesheetError(f&#34;failed to parse css; {error}&#34;)
        return rules

    def read(self, filename: str | PurePath) -&gt; None:
        &#34;&#34;&#34;Read Textual CSS file.

        Args:
            filename (str | PurePath): filename of CSS.

        Raises:
            StylesheetError: If the CSS could not be read.
            StylesheetParseError: If the CSS is invalid.
        &#34;&#34;&#34;
        filename = os.path.expanduser(filename)
        try:
            with open(filename, &#34;rt&#34;) as css_file:
                css = css_file.read()
            path = os.path.abspath(filename)
        except Exception as error:
            raise StylesheetError(f&#34;unable to read {filename!r}; {error}&#34;)
        self.source[str(path)] = css
        self._require_parse = True

    def add_source(self, css: str, path: str | PurePath | None = None) -&gt; None:
        &#34;&#34;&#34;Parse CSS from a string.

        Args:
            css (str): String with CSS source.
            path (str | PurePath, optional): The path of the source if a file, or some other identifier.
                Defaults to None.

        Raises:
            StylesheetError: If the CSS could not be read.
            StylesheetParseError: If the CSS is invalid.
        &#34;&#34;&#34;

        if path is None:
            path = str(hash(css))
        elif isinstance(path, PurePath):
            path = str(css)
        if path in self.source and self.source[path] == css:
            # Path already in source, and CSS is identical
            return

        self.source[path] = css
        self._require_parse = True

    def parse(self) -&gt; None:
        &#34;&#34;&#34;Parse the source in the stylesheet.

        Raises:
            StylesheetParseError: If there are any CSS related errors.
        &#34;&#34;&#34;
        rules: list[RuleSet] = []
        add_rules = rules.extend
        for path, css in self.source.items():
            css_rules = self._parse_rules(css, path)
            if any(rule.errors for rule in css_rules):
                error_renderable = StylesheetErrors(css_rules)
                raise StylesheetParseError(error_renderable)
            add_rules(css_rules)
        self._rules = rules
        self._require_parse = False

    def reparse(self) -&gt; None:
        &#34;&#34;&#34;Re-parse source, applying new variables.

        Raises:
            StylesheetError: If the CSS could not be read.
            StylesheetParseError: If the CSS is invalid.

        &#34;&#34;&#34;
        # Do this in a fresh Stylesheet so if there are errors we don&#39;t break self.
        stylesheet = Stylesheet(variables=self.variables)
        for path, css in self.source.items():
            stylesheet.add_source(css, path)
        stylesheet.parse()
        self._rules = stylesheet.rules
        self.source = stylesheet.source

    @classmethod
    def _check_rule(cls, rule: RuleSet, node: DOMNode) -&gt; Iterable[Specificity3]:
        for selector_set in rule.selector_set:
            if _check_selectors(selector_set.selectors, node):
                yield selector_set.specificity

    def apply(self, node: DOMNode, animate: bool = False) -&gt; None:
        &#34;&#34;&#34;Apply the stylesheet to a DOM node.

        Args:
            node (DOMNode): The ``DOMNode`` to apply the stylesheet to.
                Applies the styles defined in this ``Stylesheet`` to the node.
                If the same rule is defined multiple times for the node (e.g. multiple
                classes modifying the same CSS property), then only the most specific
                rule will be applied.
            animate (bool, optional): Animate changed rules. Defaults to ``False``.
        &#34;&#34;&#34;

        # Dictionary of rule attribute names e.g. &#34;text_background&#34; to list of tuples.
        # The tuples contain the rule specificity, and the value for that rule.
        # We can use this to determine, for a given rule, whether we should apply it
        # or not by examining the specificity. If we have two rules for the
        # same attribute, then we can choose the most specific rule and use that.
        rule_attributes: dict[str, list[tuple[Specificity4, object]]]
        rule_attributes = defaultdict(list)

        _check_rule = self._check_rule

        # Collect default node CSS rules
        for key, default_specificity, value in node._default_rules:
            rule_attributes[key].append((default_specificity, value))

        # Collect the rules defined in the stylesheet
        for rule in self.rules:
            for specificity in _check_rule(rule, node):
                for key, rule_specificity, value in rule.styles.extract_rules(
                    specificity
                ):
                    rule_attributes[key].append((rule_specificity, value))

        # For each rule declared for this node, keep only the most specific one
        get_first_item = itemgetter(0)
        node_rules: RulesMap = cast(
            RulesMap,
            {
                name: max(specificity_rules, key=get_first_item)[1]
                for name, specificity_rules in rule_attributes.items()
            },
        )
        self.replace_rules(node, node_rules, animate=animate)

    @classmethod
    def replace_rules(
        cls, node: DOMNode, rules: RulesMap, animate: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Replace style rules on a node, animating as required.

        Args:
            node (DOMNode): A DOM node.
            rules (RulesMap): Mapping of rules.
            animate (bool, optional): Enable animation. Defaults to False.
        &#34;&#34;&#34;

        # Alias styles and base styles
        styles = node.styles
        base_styles = styles.base

        # Styles currently used an new rules
        modified_rule_keys = {*base_styles.get_rules().keys(), *rules.keys()}
        # Current render rules (missing rules are filled with default)
        current_render_rules = styles.get_render_rules()

        # Calculate replacement rules (defaults + new rules)
        new_styles = node._default_styles.copy()
        new_styles.merge_rules(rules)

        if new_styles == base_styles:
            # Nothing to change, return early
            return

        # New render rules
        new_render_rules = new_styles.get_render_rules()

        # Some aliases
        is_animatable = styles.is_animatable
        get_current_render_rule = current_render_rules.get
        get_new_render_rule = new_render_rules.get

        if animate:
            for key in modified_rule_keys:
                # Get old and new render rules
                old_render_value = get_current_render_rule(key)
                new_render_value = get_new_render_rule(key)
                # Get new rule value (may be None)
                new_value = rules.get(key)

                # Check if this can / should be animated
                if is_animatable(key) and new_render_value != old_render_value:
                    transition = new_styles.get_transition(key)
                    if transition is not None:
                        duration, easing, _delay = transition
                        node.app.animator.animate(
                            node.styles.base,
                            key,
                            new_render_value,
                            final_value=new_value,
                            duration=duration,
                            easing=easing,
                        )
                        continue
                # Default is to set value (if new_value is None, rule will be removed)
                setattr(base_styles, key, new_value)
        else:
            # Not animated, so we apply the rules directly
            get_rule = rules.get
            for key in modified_rule_keys:
                setattr(base_styles, key, get_rule(key))

    def update(self, root: DOMNode, animate: bool = False) -&gt; None:
        &#34;&#34;&#34;Update a node and its children.&#34;&#34;&#34;
        apply = self.apply
        for node in root.walk_children():
            apply(node, animate=animate)


if __name__ == &#34;__main__&#34;:
    from rich.traceback import install

    install(show_locals=True)

    class Widget(DOMNode):
        pass

    class View(DOMNode):
        pass

    class App(DOMNode):
        pass

    app = App()
    main_view = View(id=&#34;main&#34;)
    help_view = View(id=&#34;help&#34;)
    app.add_child(main_view)
    app.add_child(help_view)

    widget1 = Widget(id=&#34;widget1&#34;)
    widget2 = Widget(id=&#34;widget2&#34;)
    sidebar = Widget(id=&#34;sidebar&#34;)
    sidebar.add_class(&#34;float&#34;)

    helpbar = Widget(id=&#34;helpbar&#34;)
    helpbar.add_class(&#34;float&#34;)

    main_view.add_child(widget1)
    main_view.add_child(widget2)
    main_view.add_child(sidebar)

    sub_view = View(id=&#34;sub&#34;)
    sub_view.add_class(&#34;-subview&#34;)
    main_view.add_child(sub_view)

    tooltip = Widget(id=&#34;tooltip&#34;)
    tooltip.add_class(&#34;float&#34;, &#34;transient&#34;)
    sub_view.add_child(tooltip)

    help = Widget(id=&#34;markdown&#34;)
    help_view.add_child(help)
    help_view.add_child(helpbar)

    from rich import print

    print(app.tree)
    print()

    CSS = &#34;&#34;&#34;
    App &gt; View {
        layout: dock;
        docks: sidebar=left | widgets=top;
    }

    #sidebar {
        dock-group: sidebar;
    }

    #widget1 {
        text: on blue;
        dock-group: widgets;
    }

    #widget2 {
        text: on red;
        dock-group: widgets;
    }

    &#34;&#34;&#34;

    stylesheet = Stylesheet()
    stylesheet.add_source(CSS)

    print(stylesheet.css)

    # print(stylesheet.error_renderable)

    # print(widget1.styles)

    # stylesheet.apply(widget1)

    # print(widget1.styles)

    # print(stylesheet.css)

    # from .query import DOMQuery

    # tests = [&#34;View&#34;, &#34;App &gt; View&#34;, &#34;Widget.float&#34;, &#34;.float.transient&#34;, &#34;*&#34;]

    # for test in tests:
    #     print(&#34;&#34;)
    #     print(f&#34;[b]{test}&#34;)
    #     print(app.query(test))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.css.stylesheet.Stylesheet"><code class="flex name class">
<span>class <span class="ident">Stylesheet</span></span>
<span>(</span><span>*, variables: dict[str, str] | None = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stylesheet:
    def __init__(self, *, variables: dict[str, str] | None = None) -&gt; None:
        self._rules: list[RuleSet] = []
        self.variables = variables or {}
        self.source: dict[str, str] = {}
        self._require_parse = False

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield self.rules

    @property
    def rules(self) -&gt; list[RuleSet]:
        if self._require_parse:
            self.parse()
            self._require_parse = False
        assert self._rules is not None
        return self._rules

    @property
    def css(self) -&gt; str:
        return &#34;\n\n&#34;.join(rule_set.css for rule_set in self.rules)

    def set_variables(self, variables: dict[str, str]) -&gt; None:
        &#34;&#34;&#34;Set CSS variables.

        Args:
            variables (dict[str, str]): A mapping of name to variable.
        &#34;&#34;&#34;
        self.variables = variables

    def _parse_rules(self, css: str, path: str | PurePath) -&gt; list[RuleSet]:
        &#34;&#34;&#34;Parse CSS and return rules.


        Args:
            css (str): String containing Textual CSS.
            path (str | PurePath): Path to CSS or unique identifier

        Raises:
            StylesheetError: If the CSS is invalid.

        Returns:
            list[RuleSet]: List of RuleSets.
        &#34;&#34;&#34;
        try:
            rules = list(parse(css, path, variables=self.variables))
        except TokenizeError:
            raise
        except Exception as error:
            raise StylesheetError(f&#34;failed to parse css; {error}&#34;)
        return rules

    def read(self, filename: str | PurePath) -&gt; None:
        &#34;&#34;&#34;Read Textual CSS file.

        Args:
            filename (str | PurePath): filename of CSS.

        Raises:
            StylesheetError: If the CSS could not be read.
            StylesheetParseError: If the CSS is invalid.
        &#34;&#34;&#34;
        filename = os.path.expanduser(filename)
        try:
            with open(filename, &#34;rt&#34;) as css_file:
                css = css_file.read()
            path = os.path.abspath(filename)
        except Exception as error:
            raise StylesheetError(f&#34;unable to read {filename!r}; {error}&#34;)
        self.source[str(path)] = css
        self._require_parse = True

    def add_source(self, css: str, path: str | PurePath | None = None) -&gt; None:
        &#34;&#34;&#34;Parse CSS from a string.

        Args:
            css (str): String with CSS source.
            path (str | PurePath, optional): The path of the source if a file, or some other identifier.
                Defaults to None.

        Raises:
            StylesheetError: If the CSS could not be read.
            StylesheetParseError: If the CSS is invalid.
        &#34;&#34;&#34;

        if path is None:
            path = str(hash(css))
        elif isinstance(path, PurePath):
            path = str(css)
        if path in self.source and self.source[path] == css:
            # Path already in source, and CSS is identical
            return

        self.source[path] = css
        self._require_parse = True

    def parse(self) -&gt; None:
        &#34;&#34;&#34;Parse the source in the stylesheet.

        Raises:
            StylesheetParseError: If there are any CSS related errors.
        &#34;&#34;&#34;
        rules: list[RuleSet] = []
        add_rules = rules.extend
        for path, css in self.source.items():
            css_rules = self._parse_rules(css, path)
            if any(rule.errors for rule in css_rules):
                error_renderable = StylesheetErrors(css_rules)
                raise StylesheetParseError(error_renderable)
            add_rules(css_rules)
        self._rules = rules
        self._require_parse = False

    def reparse(self) -&gt; None:
        &#34;&#34;&#34;Re-parse source, applying new variables.

        Raises:
            StylesheetError: If the CSS could not be read.
            StylesheetParseError: If the CSS is invalid.

        &#34;&#34;&#34;
        # Do this in a fresh Stylesheet so if there are errors we don&#39;t break self.
        stylesheet = Stylesheet(variables=self.variables)
        for path, css in self.source.items():
            stylesheet.add_source(css, path)
        stylesheet.parse()
        self._rules = stylesheet.rules
        self.source = stylesheet.source

    @classmethod
    def _check_rule(cls, rule: RuleSet, node: DOMNode) -&gt; Iterable[Specificity3]:
        for selector_set in rule.selector_set:
            if _check_selectors(selector_set.selectors, node):
                yield selector_set.specificity

    def apply(self, node: DOMNode, animate: bool = False) -&gt; None:
        &#34;&#34;&#34;Apply the stylesheet to a DOM node.

        Args:
            node (DOMNode): The ``DOMNode`` to apply the stylesheet to.
                Applies the styles defined in this ``Stylesheet`` to the node.
                If the same rule is defined multiple times for the node (e.g. multiple
                classes modifying the same CSS property), then only the most specific
                rule will be applied.
            animate (bool, optional): Animate changed rules. Defaults to ``False``.
        &#34;&#34;&#34;

        # Dictionary of rule attribute names e.g. &#34;text_background&#34; to list of tuples.
        # The tuples contain the rule specificity, and the value for that rule.
        # We can use this to determine, for a given rule, whether we should apply it
        # or not by examining the specificity. If we have two rules for the
        # same attribute, then we can choose the most specific rule and use that.
        rule_attributes: dict[str, list[tuple[Specificity4, object]]]
        rule_attributes = defaultdict(list)

        _check_rule = self._check_rule

        # Collect default node CSS rules
        for key, default_specificity, value in node._default_rules:
            rule_attributes[key].append((default_specificity, value))

        # Collect the rules defined in the stylesheet
        for rule in self.rules:
            for specificity in _check_rule(rule, node):
                for key, rule_specificity, value in rule.styles.extract_rules(
                    specificity
                ):
                    rule_attributes[key].append((rule_specificity, value))

        # For each rule declared for this node, keep only the most specific one
        get_first_item = itemgetter(0)
        node_rules: RulesMap = cast(
            RulesMap,
            {
                name: max(specificity_rules, key=get_first_item)[1]
                for name, specificity_rules in rule_attributes.items()
            },
        )
        self.replace_rules(node, node_rules, animate=animate)

    @classmethod
    def replace_rules(
        cls, node: DOMNode, rules: RulesMap, animate: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Replace style rules on a node, animating as required.

        Args:
            node (DOMNode): A DOM node.
            rules (RulesMap): Mapping of rules.
            animate (bool, optional): Enable animation. Defaults to False.
        &#34;&#34;&#34;

        # Alias styles and base styles
        styles = node.styles
        base_styles = styles.base

        # Styles currently used an new rules
        modified_rule_keys = {*base_styles.get_rules().keys(), *rules.keys()}
        # Current render rules (missing rules are filled with default)
        current_render_rules = styles.get_render_rules()

        # Calculate replacement rules (defaults + new rules)
        new_styles = node._default_styles.copy()
        new_styles.merge_rules(rules)

        if new_styles == base_styles:
            # Nothing to change, return early
            return

        # New render rules
        new_render_rules = new_styles.get_render_rules()

        # Some aliases
        is_animatable = styles.is_animatable
        get_current_render_rule = current_render_rules.get
        get_new_render_rule = new_render_rules.get

        if animate:
            for key in modified_rule_keys:
                # Get old and new render rules
                old_render_value = get_current_render_rule(key)
                new_render_value = get_new_render_rule(key)
                # Get new rule value (may be None)
                new_value = rules.get(key)

                # Check if this can / should be animated
                if is_animatable(key) and new_render_value != old_render_value:
                    transition = new_styles.get_transition(key)
                    if transition is not None:
                        duration, easing, _delay = transition
                        node.app.animator.animate(
                            node.styles.base,
                            key,
                            new_render_value,
                            final_value=new_value,
                            duration=duration,
                            easing=easing,
                        )
                        continue
                # Default is to set value (if new_value is None, rule will be removed)
                setattr(base_styles, key, new_value)
        else:
            # Not animated, so we apply the rules directly
            get_rule = rules.get
            for key in modified_rule_keys:
                setattr(base_styles, key, get_rule(key))

    def update(self, root: DOMNode, animate: bool = False) -&gt; None:
        &#34;&#34;&#34;Update a node and its children.&#34;&#34;&#34;
        apply = self.apply
        for node in root.walk_children():
            apply(node, animate=animate)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="textual.css.stylesheet.Stylesheet.replace_rules"><code class="name flex">
<span>def <span class="ident">replace_rules</span></span>(<span>node: DOMNode, rules: RulesMap, animate: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Replace style rules on a node, animating as required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>DOMNode</code></dt>
<dd>A DOM node.</dd>
<dt><strong><code>rules</code></strong> :&ensp;<code>RulesMap</code></dt>
<dd>Mapping of rules.</dd>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Enable animation. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def replace_rules(
    cls, node: DOMNode, rules: RulesMap, animate: bool = False
) -&gt; None:
    &#34;&#34;&#34;Replace style rules on a node, animating as required.

    Args:
        node (DOMNode): A DOM node.
        rules (RulesMap): Mapping of rules.
        animate (bool, optional): Enable animation. Defaults to False.
    &#34;&#34;&#34;

    # Alias styles and base styles
    styles = node.styles
    base_styles = styles.base

    # Styles currently used an new rules
    modified_rule_keys = {*base_styles.get_rules().keys(), *rules.keys()}
    # Current render rules (missing rules are filled with default)
    current_render_rules = styles.get_render_rules()

    # Calculate replacement rules (defaults + new rules)
    new_styles = node._default_styles.copy()
    new_styles.merge_rules(rules)

    if new_styles == base_styles:
        # Nothing to change, return early
        return

    # New render rules
    new_render_rules = new_styles.get_render_rules()

    # Some aliases
    is_animatable = styles.is_animatable
    get_current_render_rule = current_render_rules.get
    get_new_render_rule = new_render_rules.get

    if animate:
        for key in modified_rule_keys:
            # Get old and new render rules
            old_render_value = get_current_render_rule(key)
            new_render_value = get_new_render_rule(key)
            # Get new rule value (may be None)
            new_value = rules.get(key)

            # Check if this can / should be animated
            if is_animatable(key) and new_render_value != old_render_value:
                transition = new_styles.get_transition(key)
                if transition is not None:
                    duration, easing, _delay = transition
                    node.app.animator.animate(
                        node.styles.base,
                        key,
                        new_render_value,
                        final_value=new_value,
                        duration=duration,
                        easing=easing,
                    )
                    continue
            # Default is to set value (if new_value is None, rule will be removed)
            setattr(base_styles, key, new_value)
    else:
        # Not animated, so we apply the rules directly
        get_rule = rules.get
        for key in modified_rule_keys:
            setattr(base_styles, key, get_rule(key))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="textual.css.stylesheet.Stylesheet.css"><code class="name">var <span class="ident">css</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def css(self) -&gt; str:
    return &#34;\n\n&#34;.join(rule_set.css for rule_set in self.rules)</code></pre>
</details>
</dd>
<dt id="textual.css.stylesheet.Stylesheet.rules"><code class="name">var <span class="ident">rules</span> : list[RuleSet]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rules(self) -&gt; list[RuleSet]:
    if self._require_parse:
        self.parse()
        self._require_parse = False
    assert self._rules is not None
    return self._rules</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.css.stylesheet.Stylesheet.add_source"><code class="name flex">
<span>def <span class="ident">add_source</span></span>(<span>self, css: str, path: str | PurePath | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Parse CSS from a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>css</code></strong> :&ensp;<code>str</code></dt>
<dd>String with CSS source.</dd>
</dl>
<p>path (str | PurePath, optional): The path of the source if a file, or some other identifier.
Defaults to None.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StylesheetError</code></dt>
<dd>If the CSS could not be read.</dd>
<dt><code><a title="textual.css.stylesheet.StylesheetParseError" href="#textual.css.stylesheet.StylesheetParseError">StylesheetParseError</a></code></dt>
<dd>If the CSS is invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_source(self, css: str, path: str | PurePath | None = None) -&gt; None:
    &#34;&#34;&#34;Parse CSS from a string.

    Args:
        css (str): String with CSS source.
        path (str | PurePath, optional): The path of the source if a file, or some other identifier.
            Defaults to None.

    Raises:
        StylesheetError: If the CSS could not be read.
        StylesheetParseError: If the CSS is invalid.
    &#34;&#34;&#34;

    if path is None:
        path = str(hash(css))
    elif isinstance(path, PurePath):
        path = str(css)
    if path in self.source and self.source[path] == css:
        # Path already in source, and CSS is identical
        return

    self.source[path] = css
    self._require_parse = True</code></pre>
</details>
</dd>
<dt id="textual.css.stylesheet.Stylesheet.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, node: DOMNode, animate: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the stylesheet to a DOM node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>DOMNode</code></dt>
<dd>The <code>DOMNode</code> to apply the stylesheet to.
Applies the styles defined in this <code><a title="textual.css.stylesheet.Stylesheet" href="#textual.css.stylesheet.Stylesheet">Stylesheet</a></code> to the node.
If the same rule is defined multiple times for the node (e.g. multiple
classes modifying the same CSS property), then only the most specific
rule will be applied.</dd>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Animate changed rules. Defaults to <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, node: DOMNode, animate: bool = False) -&gt; None:
    &#34;&#34;&#34;Apply the stylesheet to a DOM node.

    Args:
        node (DOMNode): The ``DOMNode`` to apply the stylesheet to.
            Applies the styles defined in this ``Stylesheet`` to the node.
            If the same rule is defined multiple times for the node (e.g. multiple
            classes modifying the same CSS property), then only the most specific
            rule will be applied.
        animate (bool, optional): Animate changed rules. Defaults to ``False``.
    &#34;&#34;&#34;

    # Dictionary of rule attribute names e.g. &#34;text_background&#34; to list of tuples.
    # The tuples contain the rule specificity, and the value for that rule.
    # We can use this to determine, for a given rule, whether we should apply it
    # or not by examining the specificity. If we have two rules for the
    # same attribute, then we can choose the most specific rule and use that.
    rule_attributes: dict[str, list[tuple[Specificity4, object]]]
    rule_attributes = defaultdict(list)

    _check_rule = self._check_rule

    # Collect default node CSS rules
    for key, default_specificity, value in node._default_rules:
        rule_attributes[key].append((default_specificity, value))

    # Collect the rules defined in the stylesheet
    for rule in self.rules:
        for specificity in _check_rule(rule, node):
            for key, rule_specificity, value in rule.styles.extract_rules(
                specificity
            ):
                rule_attributes[key].append((rule_specificity, value))

    # For each rule declared for this node, keep only the most specific one
    get_first_item = itemgetter(0)
    node_rules: RulesMap = cast(
        RulesMap,
        {
            name: max(specificity_rules, key=get_first_item)[1]
            for name, specificity_rules in rule_attributes.items()
        },
    )
    self.replace_rules(node, node_rules, animate=animate)</code></pre>
</details>
</dd>
<dt id="textual.css.stylesheet.Stylesheet.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the source in the stylesheet.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="textual.css.stylesheet.StylesheetParseError" href="#textual.css.stylesheet.StylesheetParseError">StylesheetParseError</a></code></dt>
<dd>If there are any CSS related errors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self) -&gt; None:
    &#34;&#34;&#34;Parse the source in the stylesheet.

    Raises:
        StylesheetParseError: If there are any CSS related errors.
    &#34;&#34;&#34;
    rules: list[RuleSet] = []
    add_rules = rules.extend
    for path, css in self.source.items():
        css_rules = self._parse_rules(css, path)
        if any(rule.errors for rule in css_rules):
            error_renderable = StylesheetErrors(css_rules)
            raise StylesheetParseError(error_renderable)
        add_rules(css_rules)
    self._rules = rules
    self._require_parse = False</code></pre>
</details>
</dd>
<dt id="textual.css.stylesheet.Stylesheet.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, filename: str | PurePath) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Read Textual CSS file.</p>
<h2 id="args">Args</h2>
<p>filename (str | PurePath): filename of CSS.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StylesheetError</code></dt>
<dd>If the CSS could not be read.</dd>
<dt><code><a title="textual.css.stylesheet.StylesheetParseError" href="#textual.css.stylesheet.StylesheetParseError">StylesheetParseError</a></code></dt>
<dd>If the CSS is invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, filename: str | PurePath) -&gt; None:
    &#34;&#34;&#34;Read Textual CSS file.

    Args:
        filename (str | PurePath): filename of CSS.

    Raises:
        StylesheetError: If the CSS could not be read.
        StylesheetParseError: If the CSS is invalid.
    &#34;&#34;&#34;
    filename = os.path.expanduser(filename)
    try:
        with open(filename, &#34;rt&#34;) as css_file:
            css = css_file.read()
        path = os.path.abspath(filename)
    except Exception as error:
        raise StylesheetError(f&#34;unable to read {filename!r}; {error}&#34;)
    self.source[str(path)] = css
    self._require_parse = True</code></pre>
</details>
</dd>
<dt id="textual.css.stylesheet.Stylesheet.reparse"><code class="name flex">
<span>def <span class="ident">reparse</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Re-parse source, applying new variables.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StylesheetError</code></dt>
<dd>If the CSS could not be read.</dd>
<dt><code><a title="textual.css.stylesheet.StylesheetParseError" href="#textual.css.stylesheet.StylesheetParseError">StylesheetParseError</a></code></dt>
<dd>If the CSS is invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparse(self) -&gt; None:
    &#34;&#34;&#34;Re-parse source, applying new variables.

    Raises:
        StylesheetError: If the CSS could not be read.
        StylesheetParseError: If the CSS is invalid.

    &#34;&#34;&#34;
    # Do this in a fresh Stylesheet so if there are errors we don&#39;t break self.
    stylesheet = Stylesheet(variables=self.variables)
    for path, css in self.source.items():
        stylesheet.add_source(css, path)
    stylesheet.parse()
    self._rules = stylesheet.rules
    self.source = stylesheet.source</code></pre>
</details>
</dd>
<dt id="textual.css.stylesheet.Stylesheet.set_variables"><code class="name flex">
<span>def <span class="ident">set_variables</span></span>(<span>self, variables: dict[str, str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set CSS variables.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variables</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>A mapping of name to variable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variables(self, variables: dict[str, str]) -&gt; None:
    &#34;&#34;&#34;Set CSS variables.

    Args:
        variables (dict[str, str]): A mapping of name to variable.
    &#34;&#34;&#34;
    self.variables = variables</code></pre>
</details>
</dd>
<dt id="textual.css.stylesheet.Stylesheet.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, root: DOMNode, animate: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update a node and its children.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, root: DOMNode, animate: bool = False) -&gt; None:
    &#34;&#34;&#34;Update a node and its children.&#34;&#34;&#34;
    apply = self.apply
    for node in root.walk_children():
        apply(node, animate=animate)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.css.stylesheet.StylesheetErrors"><code class="flex name class">
<span>class <span class="ident">StylesheetErrors</span></span>
<span>(</span><span>rules: list[RuleSet], variables: dict[str, str] | None = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StylesheetErrors:
    def __init__(
        self, rules: list[RuleSet], variables: dict[str, str] | None = None
    ) -&gt; None:
        self.rules = rules
        self.variables: dict[str, str] = {}
        self._css_variables: dict[str, list[Token]] = {}
        if variables:
            self.set_variables(variables)

    @classmethod
    def _get_snippet(cls, code: str, line_no: int) -&gt; RenderableType:
        syntax = Syntax(
            code,
            lexer=&#34;scss&#34;,
            theme=&#34;ansi_light&#34;,
            line_numbers=True,
            indent_guides=True,
            line_range=(max(0, line_no - 2), line_no + 2),
            highlight_lines={line_no},
        )
        return syntax

    def set_variables(self, variable_map: dict[str, str]) -&gt; None:
        &#34;&#34;&#34;Pre-populate CSS variables.&#34;&#34;&#34;
        self.variables.update(variable_map)
        self._css_variables = tokenize_values(self.variables)

    def __rich_console__(
        self, console: Console, options: ConsoleOptions
    ) -&gt; RenderResult:
        error_count = 0
        for rule in self.rules:
            for token, message in rule.errors:
                error_count += 1

                if token.path:
                    path = Path(token.path)
                    filename = path.name
                else:
                    path = None
                    filename = &#34;&lt;unknown&gt;&#34;

                if token.referenced_by:
                    line_idx, col_idx = token.referenced_by.location
                    line_no, col_no = line_idx + 1, col_idx + 1
                    path_string = (
                        f&#34;{path.absolute() if path else filename}:{line_no}:{col_no}&#34;
                    )
                else:
                    line_idx, col_idx = token.location
                    line_no, col_no = line_idx + 1, col_idx + 1
                    path_string = (
                        f&#34;{path.absolute() if path else filename}:{line_no}:{col_no}&#34;
                    )

                link_style = Style(
                    link=f&#34;file://{path.absolute()}&#34;,
                    color=&#34;red&#34;,
                    bold=True,
                    italic=True,
                )

                path_text = Text(path_string, style=link_style)
                title = Text.assemble(Text(&#34;Error at &#34;, style=&#34;bold red&#34;), path_text)
                yield &#34;&#34;
                yield Panel(
                    self._get_snippet(token.code, line_no),
                    title=title,
                    title_align=&#34;left&#34;,
                    border_style=&#34;red&#34;,
                )
                yield Padding(message, pad=(0, 0, 1, 3))

        yield &#34;&#34;
        yield render(
            f&#34; [b][red]CSS parsing failed:[/] {error_count} error{&#39;s&#39; if error_count != 1 else &#39;&#39;}[/] found in stylesheet&#34;
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="textual.css.stylesheet.StylesheetErrors.set_variables"><code class="name flex">
<span>def <span class="ident">set_variables</span></span>(<span>self, variable_map: dict[str, str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Pre-populate CSS variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variables(self, variable_map: dict[str, str]) -&gt; None:
    &#34;&#34;&#34;Pre-populate CSS variables.&#34;&#34;&#34;
    self.variables.update(variable_map)
    self._css_variables = tokenize_values(self.variables)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.css.stylesheet.StylesheetParseError"><code class="flex name class">
<span>class <span class="ident">StylesheetParseError</span></span>
<span>(</span><span>errors: <a title="textual.css.stylesheet.StylesheetErrors" href="#textual.css.stylesheet.StylesheetErrors">StylesheetErrors</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StylesheetParseError(StylesheetError):
    def __init__(self, errors: StylesheetErrors) -&gt; None:
        self.errors = errors

    def __rich__(self) -&gt; RenderableType:
        return self.errors</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textual.css.errors.StylesheetError" href="errors.html#textual.css.errors.StylesheetError">StylesheetError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual.css" href="index.html">textual.css</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.css.stylesheet.Stylesheet" href="#textual.css.stylesheet.Stylesheet">Stylesheet</a></code></h4>
<ul class="two-column">
<li><code><a title="textual.css.stylesheet.Stylesheet.add_source" href="#textual.css.stylesheet.Stylesheet.add_source">add_source</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.apply" href="#textual.css.stylesheet.Stylesheet.apply">apply</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.css" href="#textual.css.stylesheet.Stylesheet.css">css</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.parse" href="#textual.css.stylesheet.Stylesheet.parse">parse</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.read" href="#textual.css.stylesheet.Stylesheet.read">read</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.reparse" href="#textual.css.stylesheet.Stylesheet.reparse">reparse</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.replace_rules" href="#textual.css.stylesheet.Stylesheet.replace_rules">replace_rules</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.rules" href="#textual.css.stylesheet.Stylesheet.rules">rules</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.set_variables" href="#textual.css.stylesheet.Stylesheet.set_variables">set_variables</a></code></li>
<li><code><a title="textual.css.stylesheet.Stylesheet.update" href="#textual.css.stylesheet.Stylesheet.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.css.stylesheet.StylesheetErrors" href="#textual.css.stylesheet.StylesheetErrors">StylesheetErrors</a></code></h4>
<ul class="">
<li><code><a title="textual.css.stylesheet.StylesheetErrors.set_variables" href="#textual.css.stylesheet.StylesheetErrors.set_variables">set_variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.css.stylesheet.StylesheetParseError" href="#textual.css.stylesheet.StylesheetParseError">StylesheetParseError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>