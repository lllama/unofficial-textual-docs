<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>textual.css.tokenizer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>textual.css.tokenizer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import re
from pathlib import PurePath
from typing import NamedTuple

from rich.console import Group, RenderableType
from rich.highlighter import ReprHighlighter
from rich.padding import Padding
from rich.panel import Panel
import rich.repr
from rich.syntax import Syntax
from rich.text import Text

from ._error_tools import friendly_list
from .._loop import loop_last


class TokenError(Exception):
    &#34;&#34;&#34;Error raised when the CSS cannot be tokenized (syntax error).&#34;&#34;&#34;

    def __init__(
        self,
        path: str,
        code: str,
        start: tuple[int, int],
        message: str,
        end: tuple[int, int] | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Args:
            path (str): Path to source or &#34;&lt;object&gt;&#34; if source is parsed from a literal.
            code (str): The code being parsed.
            start (tuple[int, int]): Line number of the error.
            message (str): A message associated with the error.
            end (tuple[int, int] | None): End location of token, or None if not known. Defaults to None.
        &#34;&#34;&#34;

        self.path = path
        self.code = code
        self.start = start
        self.end = end or start
        super().__init__(message)

    def _get_snippet(self) -&gt; Panel:
        &#34;&#34;&#34;Get a short snippet of code around a given line number.

        Args:
            code (str): The code.
            line_no (int): Line number.

        Returns:
            Panel: A renderable.
        &#34;&#34;&#34;
        line_no = self.start[0]
        # TODO: Highlight column number
        syntax = Syntax(
            self.code,
            lexer=&#34;scss&#34;,
            theme=&#34;ansi_light&#34;,
            line_numbers=True,
            indent_guides=True,
            line_range=(max(0, line_no - 2), line_no + 2),
            highlight_lines={line_no},
        )
        syntax.stylize_range(&#34;reverse bold&#34;, self.start, self.end)
        return Panel(syntax, border_style=&#34;red&#34;)

    def __rich__(self) -&gt; RenderableType:
        highlighter = ReprHighlighter()
        errors: list[RenderableType] = []

        message = str(self)
        errors.append(Text(&#34; Error in stylesheet:&#34;, style=&#34;bold red&#34;))

        line_no, col_no = self.start

        errors.append(highlighter(f&#34; {self.path or &#39;&lt;unknown&gt;&#39;}:{line_no}:{col_no}&#34;))
        errors.append(self._get_snippet())

        final_message = &#34;\n&#34;.join(
            f&#34;â€¢ {message_part.strip()}&#34; for message_part in message.split(&#34;;&#34;)
        )
        errors.append(
            Padding(
                highlighter(
                    Text(final_message, &#34;red&#34;),
                ),
                pad=(0, 1),
            )
        )

        return Group(*errors)


class EOFError(TokenError):
    pass


class Expect:
    def __init__(self, **tokens: str) -&gt; None:
        self.names = list(tokens.keys())
        self.regexes = list(tokens.values())
        self._regex = re.compile(
            &#34;(&#34;
            + &#34;|&#34;.join(f&#34;(?P&lt;{name}&gt;{regex})&#34; for name, regex in tokens.items())
            + &#34;)&#34;
        )
        self.match = self._regex.match
        self.search = self._regex.search
        self._expect_eof = False

    def expect_eof(self, eof: bool) -&gt; Expect:
        self._expect_eof = eof
        return self

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield from zip(self.names, self.regexes)


class ReferencedBy(NamedTuple):
    name: str
    location: tuple[int, int]
    length: int


@rich.repr.auto
class Token(NamedTuple):
    name: str
    value: str
    path: str
    code: str
    location: tuple[int, int]
    referenced_by: ReferencedBy | None = None

    @property
    def start(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Start line and column (1 indexed).&#34;&#34;&#34;
        line, offset = self.location
        return (line + 1, offset)

    @property
    def end(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;End line and column (1 indexed).&#34;&#34;&#34;
        line, offset = self.location
        return (line + 1, offset + len(self.value))

    def with_reference(self, by: ReferencedBy | None) -&gt; &#34;Token&#34;:
        &#34;&#34;&#34;Return a copy of the Token, with reference information attached.
        This is used for variable substitution, where a variable reference
        can refer to tokens which were defined elsewhere. With the additional
        ReferencedBy data attached, we can track where the token we are referring
        to is used.
        &#34;&#34;&#34;
        return Token(
            name=self.name,
            value=self.value,
            path=self.path,
            code=self.code,
            location=self.location,
            referenced_by=by,
        )

    def __str__(self) -&gt; str:
        return self.value

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;name&#34;, self.name
        yield &#34;value&#34;, self.value
        yield &#34;path&#34;, self.path
        yield &#34;code&#34;, self.code if len(self.code) &lt; 40 else self.code[:40] + &#34;...&#34;
        yield &#34;location&#34;, self.location
        yield &#34;referenced_by&#34;, self.referenced_by, None


class Tokenizer:
    def __init__(self, text: str, path: str | PurePath = &#34;&#34;) -&gt; None:
        self.path = str(path)
        self.code = text
        self.lines = text.splitlines(keepends=True)
        self.line_no = 0
        self.col_no = 0

    def get_token(self, expect: Expect) -&gt; Token:
        line_no = self.line_no
        col_no = self.col_no
        if line_no &gt;= len(self.lines):
            if expect._expect_eof:
                return Token(
                    &#34;eof&#34;,
                    &#34;&#34;,
                    self.path,
                    self.code,
                    (line_no + 1, col_no + 1),
                    None,
                )
            else:
                raise EOFError(
                    self.path,
                    self.code,
                    (line_no + 1, col_no + 1),
                    &#34;Unexpected end of file&#34;,
                )
        line = self.lines[line_no]
        match = expect.match(line, col_no)
        if match is None:
            expected = friendly_list(&#34; &#34;.join(name.split(&#34;_&#34;)) for name in expect.names)
            message = f&#34;Expected one of {expected}.; Did you forget a semicolon at the end of a line?&#34;
            raise TokenError(
                self.path,
                self.code,
                (line_no, col_no),
                message,
            )
        iter_groups = iter(match.groups())
        next(iter_groups)

        for name, value in zip(expect.names, iter_groups):
            if value is not None:
                break
        else:
            # For MyPy&#39;s benefit
            raise AssertionError(&#34;can&#39;t reach here&#34;)

        token = Token(
            name,
            value,
            self.path,
            self.code,
            (line_no, col_no),
            referenced_by=None,
        )
        col_no += len(value)
        if col_no &gt;= len(line):
            line_no += 1
            col_no = 0
        self.line_no = line_no
        self.col_no = col_no
        return token

    def skip_to(self, expect: Expect) -&gt; Token:
        line_no = self.line_no
        col_no = self.col_no

        while True:
            if line_no &gt;= len(self.lines):
                raise EOFError(
                    self.path, self.code, line_no, col_no, &#34;Unexpected end of file&#34;
                )
            line = self.lines[line_no]
            match = expect.search(line, col_no)

            if match is None:
                line_no += 1
                col_no = 0
            else:
                self.line_no = line_no
                self.col_no = match.span(0)[0]
                return self.get_token(expect)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="textual.css.tokenizer.EOFError"><code class="flex name class">
<span>class <span class="ident">EOFError</span></span>
<span>(</span><span>path:Â str, code:Â str, start:Â tuple[int,Â int], message:Â str, end:Â tuple[int,Â int]Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Error raised when the CSS cannot be tokenized (syntax error).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to source or "<object>" if source is parsed from a literal.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>The code being parsed.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>Line number of the error.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>A message associated with the error.</dd>
</dl>
<p>end (tuple[int, int] | None): End location of token, or None if not known. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EOFError(TokenError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="textual.css.tokenizer.TokenError" href="#textual.css.tokenizer.TokenError">TokenError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="textual.css.tokenizer.Expect"><code class="flex name class">
<span>class <span class="ident">Expect</span></span>
<span>(</span><span>**tokens:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Expect:
    def __init__(self, **tokens: str) -&gt; None:
        self.names = list(tokens.keys())
        self.regexes = list(tokens.values())
        self._regex = re.compile(
            &#34;(&#34;
            + &#34;|&#34;.join(f&#34;(?P&lt;{name}&gt;{regex})&#34; for name, regex in tokens.items())
            + &#34;)&#34;
        )
        self.match = self._regex.match
        self.search = self._regex.search
        self._expect_eof = False

    def expect_eof(self, eof: bool) -&gt; Expect:
        self._expect_eof = eof
        return self

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield from zip(self.names, self.regexes)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="textual.css.tokenizer.Expect.expect_eof"><code class="name flex">
<span>def <span class="ident">expect_eof</span></span>(<span>self, eof:Â bool) â€‘>Â <a title="textual.css.tokenizer.Expect" href="#textual.css.tokenizer.Expect">Expect</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_eof(self, eof: bool) -&gt; Expect:
    self._expect_eof = eof
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.css.tokenizer.ReferencedBy"><code class="flex name class">
<span>class <span class="ident">ReferencedBy</span></span>
<span>(</span><span>name:Â str, location:Â tuple[int,Â int], length:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>ReferencedBy(name, location, length)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferencedBy(NamedTuple):
    name: str
    location: tuple[int, int]
    length: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="textual.css.tokenizer.ReferencedBy.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="textual.css.tokenizer.ReferencedBy.location"><code class="name">var <span class="ident">location</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="textual.css.tokenizer.ReferencedBy.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="textual.css.tokenizer.Token"><code class="flex name class">
<span>class <span class="ident">Token</span></span>
<span>(</span><span>name:Â str, value:Â str, path:Â str, code:Â str, location:Â tuple[int,Â int], referenced_by:Â <a title="textual.css.tokenizer.ReferencedBy" href="#textual.css.tokenizer.ReferencedBy">ReferencedBy</a>Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Token(name, value, path, code, location, referenced_by)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Token(NamedTuple):
    name: str
    value: str
    path: str
    code: str
    location: tuple[int, int]
    referenced_by: ReferencedBy | None = None

    @property
    def start(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;Start line and column (1 indexed).&#34;&#34;&#34;
        line, offset = self.location
        return (line + 1, offset)

    @property
    def end(self) -&gt; tuple[int, int]:
        &#34;&#34;&#34;End line and column (1 indexed).&#34;&#34;&#34;
        line, offset = self.location
        return (line + 1, offset + len(self.value))

    def with_reference(self, by: ReferencedBy | None) -&gt; &#34;Token&#34;:
        &#34;&#34;&#34;Return a copy of the Token, with reference information attached.
        This is used for variable substitution, where a variable reference
        can refer to tokens which were defined elsewhere. With the additional
        ReferencedBy data attached, we can track where the token we are referring
        to is used.
        &#34;&#34;&#34;
        return Token(
            name=self.name,
            value=self.value,
            path=self.path,
            code=self.code,
            location=self.location,
            referenced_by=by,
        )

    def __str__(self) -&gt; str:
        return self.value

    def __rich_repr__(self) -&gt; rich.repr.Result:
        yield &#34;name&#34;, self.name
        yield &#34;value&#34;, self.value
        yield &#34;path&#34;, self.path
        yield &#34;code&#34;, self.code if len(self.code) &lt; 40 else self.code[:40] + &#34;...&#34;
        yield &#34;location&#34;, self.location
        yield &#34;referenced_by&#34;, self.referenced_by, None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="textual.css.tokenizer.Token.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="textual.css.tokenizer.Token.end"><code class="name">var <span class="ident">end</span> :Â tuple[int,Â int]</code></dt>
<dd>
<div class="desc"><p>End line and column (1 indexed).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;End line and column (1 indexed).&#34;&#34;&#34;
    line, offset = self.location
    return (line + 1, offset + len(self.value))</code></pre>
</details>
</dd>
<dt id="textual.css.tokenizer.Token.location"><code class="name">var <span class="ident">location</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="textual.css.tokenizer.Token.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="textual.css.tokenizer.Token.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="textual.css.tokenizer.Token.referenced_by"><code class="name">var <span class="ident">referenced_by</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="textual.css.tokenizer.Token.start"><code class="name">var <span class="ident">start</span> :Â tuple[int,Â int]</code></dt>
<dd>
<div class="desc"><p>Start line and column (1 indexed).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self) -&gt; tuple[int, int]:
    &#34;&#34;&#34;Start line and column (1 indexed).&#34;&#34;&#34;
    line, offset = self.location
    return (line + 1, offset)</code></pre>
</details>
</dd>
<dt id="textual.css.tokenizer.Token.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="textual.css.tokenizer.Token.with_reference"><code class="name flex">
<span>def <span class="ident">with_reference</span></span>(<span>self, by:Â <a title="textual.css.tokenizer.ReferencedBy" href="#textual.css.tokenizer.ReferencedBy">ReferencedBy</a>Â |Â None) â€‘>Â '<a title="textual.css.tokenizer.Token" href="#textual.css.tokenizer.Token">Token</a>'</span>
</code></dt>
<dd>
<div class="desc"><p>Return a copy of the Token, with reference information attached.
This is used for variable substitution, where a variable reference
can refer to tokens which were defined elsewhere. With the additional
ReferencedBy data attached, we can track where the token we are referring
to is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_reference(self, by: ReferencedBy | None) -&gt; &#34;Token&#34;:
    &#34;&#34;&#34;Return a copy of the Token, with reference information attached.
    This is used for variable substitution, where a variable reference
    can refer to tokens which were defined elsewhere. With the additional
    ReferencedBy data attached, we can track where the token we are referring
    to is used.
    &#34;&#34;&#34;
    return Token(
        name=self.name,
        value=self.value,
        path=self.path,
        code=self.code,
        location=self.location,
        referenced_by=by,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="textual.css.tokenizer.TokenError"><code class="flex name class">
<span>class <span class="ident">TokenError</span></span>
<span>(</span><span>path:Â str, code:Â str, start:Â tuple[int,Â int], message:Â str, end:Â tuple[int,Â int]Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Error raised when the CSS cannot be tokenized (syntax error).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to source or "<object>" if source is parsed from a literal.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>The code being parsed.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>Line number of the error.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>A message associated with the error.</dd>
</dl>
<p>end (tuple[int, int] | None): End location of token, or None if not known. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TokenError(Exception):
    &#34;&#34;&#34;Error raised when the CSS cannot be tokenized (syntax error).&#34;&#34;&#34;

    def __init__(
        self,
        path: str,
        code: str,
        start: tuple[int, int],
        message: str,
        end: tuple[int, int] | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Args:
            path (str): Path to source or &#34;&lt;object&gt;&#34; if source is parsed from a literal.
            code (str): The code being parsed.
            start (tuple[int, int]): Line number of the error.
            message (str): A message associated with the error.
            end (tuple[int, int] | None): End location of token, or None if not known. Defaults to None.
        &#34;&#34;&#34;

        self.path = path
        self.code = code
        self.start = start
        self.end = end or start
        super().__init__(message)

    def _get_snippet(self) -&gt; Panel:
        &#34;&#34;&#34;Get a short snippet of code around a given line number.

        Args:
            code (str): The code.
            line_no (int): Line number.

        Returns:
            Panel: A renderable.
        &#34;&#34;&#34;
        line_no = self.start[0]
        # TODO: Highlight column number
        syntax = Syntax(
            self.code,
            lexer=&#34;scss&#34;,
            theme=&#34;ansi_light&#34;,
            line_numbers=True,
            indent_guides=True,
            line_range=(max(0, line_no - 2), line_no + 2),
            highlight_lines={line_no},
        )
        syntax.stylize_range(&#34;reverse bold&#34;, self.start, self.end)
        return Panel(syntax, border_style=&#34;red&#34;)

    def __rich__(self) -&gt; RenderableType:
        highlighter = ReprHighlighter()
        errors: list[RenderableType] = []

        message = str(self)
        errors.append(Text(&#34; Error in stylesheet:&#34;, style=&#34;bold red&#34;))

        line_no, col_no = self.start

        errors.append(highlighter(f&#34; {self.path or &#39;&lt;unknown&gt;&#39;}:{line_no}:{col_no}&#34;))
        errors.append(self._get_snippet())

        final_message = &#34;\n&#34;.join(
            f&#34;â€¢ {message_part.strip()}&#34; for message_part in message.split(&#34;;&#34;)
        )
        errors.append(
            Padding(
                highlighter(
                    Text(final_message, &#34;red&#34;),
                ),
                pad=(0, 1),
            )
        )

        return Group(*errors)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="textual.css.errors.UnresolvedVariableError" href="errors.html#textual.css.errors.UnresolvedVariableError">UnresolvedVariableError</a></li>
<li><a title="textual.css.tokenizer.EOFError" href="#textual.css.tokenizer.EOFError">EOFError</a></li>
</ul>
</dd>
<dt id="textual.css.tokenizer.Tokenizer"><code class="flex name class">
<span>class <span class="ident">Tokenizer</span></span>
<span>(</span><span>text:Â str, path:Â strÂ |Â PurePathÂ =Â '')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tokenizer:
    def __init__(self, text: str, path: str | PurePath = &#34;&#34;) -&gt; None:
        self.path = str(path)
        self.code = text
        self.lines = text.splitlines(keepends=True)
        self.line_no = 0
        self.col_no = 0

    def get_token(self, expect: Expect) -&gt; Token:
        line_no = self.line_no
        col_no = self.col_no
        if line_no &gt;= len(self.lines):
            if expect._expect_eof:
                return Token(
                    &#34;eof&#34;,
                    &#34;&#34;,
                    self.path,
                    self.code,
                    (line_no + 1, col_no + 1),
                    None,
                )
            else:
                raise EOFError(
                    self.path,
                    self.code,
                    (line_no + 1, col_no + 1),
                    &#34;Unexpected end of file&#34;,
                )
        line = self.lines[line_no]
        match = expect.match(line, col_no)
        if match is None:
            expected = friendly_list(&#34; &#34;.join(name.split(&#34;_&#34;)) for name in expect.names)
            message = f&#34;Expected one of {expected}.; Did you forget a semicolon at the end of a line?&#34;
            raise TokenError(
                self.path,
                self.code,
                (line_no, col_no),
                message,
            )
        iter_groups = iter(match.groups())
        next(iter_groups)

        for name, value in zip(expect.names, iter_groups):
            if value is not None:
                break
        else:
            # For MyPy&#39;s benefit
            raise AssertionError(&#34;can&#39;t reach here&#34;)

        token = Token(
            name,
            value,
            self.path,
            self.code,
            (line_no, col_no),
            referenced_by=None,
        )
        col_no += len(value)
        if col_no &gt;= len(line):
            line_no += 1
            col_no = 0
        self.line_no = line_no
        self.col_no = col_no
        return token

    def skip_to(self, expect: Expect) -&gt; Token:
        line_no = self.line_no
        col_no = self.col_no

        while True:
            if line_no &gt;= len(self.lines):
                raise EOFError(
                    self.path, self.code, line_no, col_no, &#34;Unexpected end of file&#34;
                )
            line = self.lines[line_no]
            match = expect.search(line, col_no)

            if match is None:
                line_no += 1
                col_no = 0
            else:
                self.line_no = line_no
                self.col_no = match.span(0)[0]
                return self.get_token(expect)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="textual.css.tokenizer.Tokenizer.get_token"><code class="name flex">
<span>def <span class="ident">get_token</span></span>(<span>self, expect:Â <a title="textual.css.tokenizer.Expect" href="#textual.css.tokenizer.Expect">Expect</a>) â€‘>Â <a title="textual.css.tokenizer.Token" href="#textual.css.tokenizer.Token">Token</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_token(self, expect: Expect) -&gt; Token:
    line_no = self.line_no
    col_no = self.col_no
    if line_no &gt;= len(self.lines):
        if expect._expect_eof:
            return Token(
                &#34;eof&#34;,
                &#34;&#34;,
                self.path,
                self.code,
                (line_no + 1, col_no + 1),
                None,
            )
        else:
            raise EOFError(
                self.path,
                self.code,
                (line_no + 1, col_no + 1),
                &#34;Unexpected end of file&#34;,
            )
    line = self.lines[line_no]
    match = expect.match(line, col_no)
    if match is None:
        expected = friendly_list(&#34; &#34;.join(name.split(&#34;_&#34;)) for name in expect.names)
        message = f&#34;Expected one of {expected}.; Did you forget a semicolon at the end of a line?&#34;
        raise TokenError(
            self.path,
            self.code,
            (line_no, col_no),
            message,
        )
    iter_groups = iter(match.groups())
    next(iter_groups)

    for name, value in zip(expect.names, iter_groups):
        if value is not None:
            break
    else:
        # For MyPy&#39;s benefit
        raise AssertionError(&#34;can&#39;t reach here&#34;)

    token = Token(
        name,
        value,
        self.path,
        self.code,
        (line_no, col_no),
        referenced_by=None,
    )
    col_no += len(value)
    if col_no &gt;= len(line):
        line_no += 1
        col_no = 0
    self.line_no = line_no
    self.col_no = col_no
    return token</code></pre>
</details>
</dd>
<dt id="textual.css.tokenizer.Tokenizer.skip_to"><code class="name flex">
<span>def <span class="ident">skip_to</span></span>(<span>self, expect:Â <a title="textual.css.tokenizer.Expect" href="#textual.css.tokenizer.Expect">Expect</a>) â€‘>Â <a title="textual.css.tokenizer.Token" href="#textual.css.tokenizer.Token">Token</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_to(self, expect: Expect) -&gt; Token:
    line_no = self.line_no
    col_no = self.col_no

    while True:
        if line_no &gt;= len(self.lines):
            raise EOFError(
                self.path, self.code, line_no, col_no, &#34;Unexpected end of file&#34;
            )
        line = self.lines[line_no]
        match = expect.search(line, col_no)

        if match is None:
            line_no += 1
            col_no = 0
        else:
            self.line_no = line_no
            self.col_no = match.span(0)[0]
            return self.get_token(expect)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="textual.css" href="index.html">textual.css</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="textual.css.tokenizer.EOFError" href="#textual.css.tokenizer.EOFError">EOFError</a></code></h4>
</li>
<li>
<h4><code><a title="textual.css.tokenizer.Expect" href="#textual.css.tokenizer.Expect">Expect</a></code></h4>
<ul class="">
<li><code><a title="textual.css.tokenizer.Expect.expect_eof" href="#textual.css.tokenizer.Expect.expect_eof">expect_eof</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.css.tokenizer.ReferencedBy" href="#textual.css.tokenizer.ReferencedBy">ReferencedBy</a></code></h4>
<ul class="">
<li><code><a title="textual.css.tokenizer.ReferencedBy.length" href="#textual.css.tokenizer.ReferencedBy.length">length</a></code></li>
<li><code><a title="textual.css.tokenizer.ReferencedBy.location" href="#textual.css.tokenizer.ReferencedBy.location">location</a></code></li>
<li><code><a title="textual.css.tokenizer.ReferencedBy.name" href="#textual.css.tokenizer.ReferencedBy.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.css.tokenizer.Token" href="#textual.css.tokenizer.Token">Token</a></code></h4>
<ul class="two-column">
<li><code><a title="textual.css.tokenizer.Token.code" href="#textual.css.tokenizer.Token.code">code</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.end" href="#textual.css.tokenizer.Token.end">end</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.location" href="#textual.css.tokenizer.Token.location">location</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.name" href="#textual.css.tokenizer.Token.name">name</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.path" href="#textual.css.tokenizer.Token.path">path</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.referenced_by" href="#textual.css.tokenizer.Token.referenced_by">referenced_by</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.start" href="#textual.css.tokenizer.Token.start">start</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.value" href="#textual.css.tokenizer.Token.value">value</a></code></li>
<li><code><a title="textual.css.tokenizer.Token.with_reference" href="#textual.css.tokenizer.Token.with_reference">with_reference</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="textual.css.tokenizer.TokenError" href="#textual.css.tokenizer.TokenError">TokenError</a></code></h4>
</li>
<li>
<h4><code><a title="textual.css.tokenizer.Tokenizer" href="#textual.css.tokenizer.Tokenizer">Tokenizer</a></code></h4>
<ul class="">
<li><code><a title="textual.css.tokenizer.Tokenizer.get_token" href="#textual.css.tokenizer.Tokenizer.get_token">get_token</a></code></li>
<li><code><a title="textual.css.tokenizer.Tokenizer.skip_to" href="#textual.css.tokenizer.Tokenizer.skip_to">skip_to</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>